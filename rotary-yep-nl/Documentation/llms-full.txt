# Expo Documentation

Expo is an open-source React Native framework for apps that run natively on Android, iOS, and the web. Expo brings together the best of mobile and the web and enables many important features for building and scaling an app such as live updates, instantly sharing your app, and web support. The company behind Expo also offers Expo Application Services (EAS), which are deeply integrated cloud services for Expo and React Native apps.

# Get started

## Introduction

Get started creating apps with Expo.

Expo is a framework that makes developing Android and iOS apps easier. Our framework provides file-based routing, a standard library of native modules, and much more. Expo is open source with an active community on [GitHub](https://github.com/expo/expo) and [Discord](https://chat.expo.dev).
We also make [Expo Application Services (EAS)](https://expo.dev/eas), a set of services that complement the Expo framework in each step of the development process.
To get started visit:


## Create a project

Learn how to create a new Expo project.

System requirements:
- [Node.js (LTS)](https://nodejs.org/en/).
- macOS, Windows (Powershell and [WSL 2](https://expo.fyi/wsl)), and Linux are supported.
We recommend starting with the default project created by `create-expo-app`. The default project includes example code to help you get started.
To create a new project, run the following command:
```sh
$ npx create-expo-app@latest
```
> You can choose a different template by adding the [`--template` option](/more/create-expo/#--template).
## Next step
You have a project. Now it's time to set up your development environment so that you can start developing.


## Set up your environment

Learn how to set up your development environment to start building with Expo.

Let's set up a local development environment for running your project on Android and iOS.
## Where would you like to develop?
We recommend using a real device to develop, since you'll get to see exactly what your users will see.
## How would you like to develop?
Expo Go is a sandbox for trying out Expo quickly. A development build is a build of your own app that includes Expo's developer tools.
---
# Android Emulator Setup

## Set up an emulator
Step 1: 
On the Android Studio main screen, click **More Actions**, then **Virtual Device Manager** in the dropdown.
Step 2: 
Click the **Create device** button.
Step 3: 
Under **Add device**, choose the type of hardware you'd like to emulate. We recommend testing against a variety of devices, but if you're unsure where to start, the newest device in the Pixel line could be a good choice.
Step 4: 
Select an OS version to load on the emulator (probably one of the system images), and download the image (if required).
Step 5: 
Change any other settings you'd like, and press **Finish** to create the emulator. You can now run this emulator anytime by pressing the Play button in the AVD Manager window.


# Android Studio Environment Setup

## Install Watchman and JDK
<Tab label='macOS'>
#### Prerequisites
Use a package manager such as [Homebrew](https://brew.sh/) to install the following dependency.
#### Install dependencies
Step 1: 
[Install Watchman](https://facebook.github.io/watchman/docs/install#macos) using a tool such as Homebrew:
```sh
$ brew install watchman
```
Step 2: 
Install OpenJDK distribution called Azul Zulu using Homebrew. This distribution offers JDKs for both Apple Silicon and Intel Macs.
Run the following commands in a terminal:
```sh
$ brew install --cask zulu@17
```
After you install the JDK, add the `JAVA_HOME` environment variable in **~/.bash_profile** (or **~/.zshrc** if you use Zsh):
```bash
export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
```
<Tab label='Windows'>
#### Prerequisites
Use a package manager such as [Chocolatey](https://chocolatey.org/) to install the following dependencies.
#### Install dependencies
Install [Java SE Development Kit (JDK)](https://openjdk.org/):
```sh
$ choco install -y microsoft-openjdk17
```
For Linux: 
#### Install dependencies
Step 1: 
Follow [instructions from the Watchman documentation](https://facebook.github.io/watchman/docs/install#linux) to compile and install it from the source.
Step 2: 
Install [Java SE Development Kit (JDK)](https://openjdk.org/):
You can download and install [OpenJDK@17](http://openjdk.java.net/) from [AdoptOpenJDK](https://adoptopenjdk.net/) or your system packager.


# Android Studio Setup

## Set up Android Studio
For macOS: 
Step 1: 
Download and install [Android Studio](https://developer.android.com/studio).
Step 2: 
Open the **Android Studio** app, you will see the **SDK Components setup** screen. Click **Next** to continue to install the Android SDK and Android SDK Platform. Click **Next** again to verify the settings and install.
Step 3: 
By default, Android Studio will install the latest version of the Android SDK. However, Android 15 (`VanillaIceCream`) SDK is required to compile a React Native app.
Open Android Studio, go to **Settings** &gt; **Languages & Frameworks** &gt; **Android SDK**. From the **SDK Platforms** tab, and under **Android 15 (`VanillaIceCream`)**, select **Android SDK Platform 35** and **Sources for Android 35**.
Step 4: 
Then, click on the **SDK Tools** tab and make sure you have at least one version of the **Android SDK Build-Tools** and **Android Emulator** installed.
Step 5: 
Copy or remember the path listed in the box that says **Android SDK Location**.
Step 6: 
Add the following lines to your **/.zprofile** or **~/.zshrc** (if you are using bash, then **~/.bash_profile** or **~/.bashrc**) config file:
```sh
$ export ANDROID_HOME=$HOME/Library/Android/sdk
$ export PATH=$PATH:$ANDROID_HOME/emulator
$ export PATH=$PATH:$ANDROID_HOME/platform-tools
```
Step 7: 
Reload the path environment variables in your current shell:
```sh
$ source $HOME/.zshrc
$ source $HOME/.bashrc
```
Step 8: 
Finally, make sure that you can run `adb` from your terminal.
Note: Troubleshooting: Android Studio not recognizing JDK
---
If Android Studio doesn't recognize your homebrew installed JDK, you can create a Gradle configuration file to explicitly set the Java path:
1.  Create a Gradle properties file in your home directory:
    ```sh
$ touch ~/.gradle/gradle.properties
```
2.  Add the following line to the **gradle.properties** file, replacing the path with your actual Java installation path:
    ```bash gradle.properties
    java.home=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
    ```
3.  If you have an existing `.gradle` folder in your project directory, delete it and reopen your project in Android Studio:
    ```sh
$ rm -rf .gradle
```
This should resolve issues with Android Studio not detecting your JDK installation.
---
For Windows: 
Step 1: 
Download [Android Studio](https://developer.android.com/studio).
Step 2: 
Open **Android Studio Setup**. Under **Select components to install**, select Android Studio and Android Virtual Device. Then, click **Next**.
Step 3: 
In the Android Studio Setup Wizard, under **Install Type**, select **Standard** and click **Next**.
Step 4: 
The Android Studio Setup Wizard will ask you to verify the settings, such as the version of Android SDK, platform-tools, and so on. Click **Next** after you have verified.
Step 5: 
In the next window, accept licenses for all available components.
Step 6: 
By default, Android Studio will install the latest version of the Android SDK. However, Android 15 (`VanillaIceCream`) SDK is required to compile a React Native app.
Open Android Studio, go to **Settings** &gt; **Languages & Frameworks** &gt; **Android SDK**. From the **SDK Platforms** tab, and under **Android 15 (`VanillaIceCream`)**, select **Android SDK Platform 35** and **Sources for Android 35**.
Step 7: 
Then, click on the **SDK Tools** tab and make sure you have at least one version of the **Android SDK Build-Tools** and **Android Emulator** installed.
Step 8: 
After the tools installation is complete, configure the `ANDROID_HOME` environment variable. Go to **Windows Control Panel** > **User Accounts** > **User Accounts** (again) > **Change my environment variables** and click **New** to create a new `ANDROID_HOME` user variable. The value of this variable will point to the path to your Android SDK:
Note: How to find installed SDK location?
---
By default, the Android SDK is installed at the following location:
```bash
%LOCALAPPDATA%\Android\Sdk
```
To find the location of the SDK in Android Studio manually, go to **Settings** > **Languages & Frameworks** > **Android SDK**. See the location next to **Android SDK Location**.
---
Step 9: 
To verify that the new environment variable is loaded, open **PowerShell**, and copy and paste the following command:
```sh
$ Get-ChildItem -Path Env: 
```
The command will output all user environment variables. In this list, see if `ANDROID_HOME` has been added.
Step 10: 
To add platform-tools to the Path, go to **Windows Control Panel** > **User Accounts** > **User Accounts** (again) > **Change my environment variables** > **Path** > **Edit** > **New** and add the path to the platform-tools to the list as shown below:
Note: How to find installed platform-tools location
---
By default, the platform-tools are installed at the following location:
```bash
%LOCALAPPDATA%\Android\Sdk\platform-tools
```
---
Step 11: 
Finally, make sure that you can run `adb` from the PowerShell. For example, run the `adb --version` to see which version of the `adb` your system is running.


# Xcode Setup

Step 1: 
### Install Xcode
Open up the Mac App Store, search for [Xcode](https://apps.apple.com/us/app/xcode/id497799835), and click **Install** (or **Update** if you have it already).
Step 2: 
### Install Xcode Command Line Tools
Open Xcode, choose **Settings...** from the Xcode menu (or press <kbd>cmd ⌘</kbd> + <kbd>,</kbd>). Go to the **Locations** and install the tools by selecting the most recent version in the **Command Line Tools** dropdown.
Step 3: 
### Install an iOS Simulator in Xcode
To install an iOS Simulator, open **Xcode > Settings... > Components**, and under **Platform Support > iOS ...**, click **Get**.
Step 4: 
### Install Watchman
[Watchman](https://facebook.github.io/watchman/docs/install#macos) is a tool for watching changes in the filesystem. Installing it will result in better performance. You can install it with:
```sh
$ brew update
$ brew install watchman
```


# Create a development build for a physical Android device with EAS

## Set up an Android device with a development build
<BuildEnvironmentSwitch />
Step 1: 
### Install EAS CLI
To build your app, you will need to install EAS CLI. You can do this by running the following command in your terminal:
```sh
$ npm install -g eas-cli
```
Step 2: 
### Create an Expo account and login
To build your app, you will need to create an Expo account and login to the EAS CLI.
1. [Sign up](https://expo.dev/signup) for an Expo account.
2. Run the following command in your terminal to log in to the EAS CLI:
   ```sh
$ eas login
```
Step 3: 
### Configure your project
Run the following command to create an EAS config in your project:
```sh
$ eas build:configure
```
Step 4: 
### Create a build
Run the following command to create a development build:
```sh
$ eas build --platform android --profile development
```
Step 5: 
### Install the development build on your device
After the build is complete, scan the QR code in your terminal or open the link on your device. Tap **Install** to download the build on your device, then tap **Open** to install it.


# Create a development build for a physical Android device locally

## Set up an Android device with a development build
<BuildEnvironmentSwitch />
<AndroidStudioEnvironmentInstructions />
<AndroidStudioInstructions />
## Running your app on an Android device
Step 1: 
### Install expo-dev-client
Run the following command in your project's root directory:
```sh
$ npx expo install expo-dev-client
```
Step 2: 
### Enable debugging over USB
Most Android devices can only install and run apps downloaded from Google Play, by default. You will need to enable USB Debugging on your device to install your app during development.
To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going to **Settings** > **About phone** > **Software information** and then tapping the `Build number` row at the bottom seven times. You can then go back to **Settings** > **Developer options** to enable "USB debugging".
Step 3: 
### Plug in your device via USB
Plug in your Android device via USB to your computer.
Check that your device is properly connecting to ADB, the Android Debug Bridge, by running `adb devices` in your terminal. You should see your device listed with `device` listed next to it. For example:
```sh
$ adb devices
List of devices attached
8AHX0T32K	device
```
Step 4: 
### Run your app
Run the following from your terminal:
```sh
$ npx expo run:android
```
> This command runs a development server after building your app. You can skip running `npx expo start` on the next page.


# Run on a physical Android device with Expo Go

## Set up an Android device with Expo Go
Scan the QR code to download the app from the Google Play Store, or visit the Expo Go page on the [Google Play Store](https://play.google.com/store/apps/details?id=host.exp.exponent&referrer=docs).
<div className="inline-block rounded-lg border border-default bg-palette-white p-4">
  <QRCodeReact
    value="https://play.google.com/store/apps/details?id=host.exp.exponent&referrer=docs"
    size={228}
  />
</div>


# Create a development build for Android Emulator with EAS

## Set up an Android Emulator with a development build
<BuildEnvironmentSwitch />
<AndroidStudioInstructions />
<AndroidEmulatorInstructions />
## Create a development build
Step 1: 
### Install EAS CLI
To build your app, you will need to install EAS CLI. You can do this by running the following command in your terminal:
```sh
$ npm install -g eas-cli
```
Step 2: 
### Create an Expo account and login
To build your app, you will need to create an Expo account and login to the EAS CLI.
1. [Sign up](https://expo.dev/signup) for an Expo account.
2. Run the following command in your terminal to log in to the EAS CLI:
   ```sh
$ eas login
```
Step 3: 
### Configure your project
Run the following command to create an EAS config in your project:
```sh
$ eas build:configure
```
Step 4: 
### Create a build
Run the following command to create a development build:
```sh
$ eas build --platform android --profile development
```
Step 5: 
### Install the development build on your emulator
After the build is complete, the CLI will prompt you to automatically download and install it on the Android Emulator. When prompted, press <kbd>Y</kbd> to directly install it on the emulator.
If you miss this prompt, you can download the build from the link provided in the terminal and drag and drop it onto the Android Emulator to install it.


# Create a development build for Android Emulator locally

## Set up an Android Emulator with a development build
<BuildEnvironmentSwitch />
<AndroidStudioEnvironmentInstructions />
<AndroidStudioInstructions />
<AndroidEmulatorInstructions />
## Running your app on an Android Emulator
Step 1: 
### Install expo-dev-client
Run the following command in your project's root directory:
```sh
$ npx expo install expo-dev-client
```
Step 2: 
Run the following from your terminal:
```sh
$ npx expo run:android
```
> This command runs a development server after building your app. You can skip running `npx expo start` on the next page.


# Run on Android Emulator with Expo Go

## Set up an Android Emulator with Expo Go
<AndroidStudioInstructions />
<AndroidEmulatorInstructions />
## Install Expo Go
When you start a development server with `npx expo start` on the [start developing](/get-started/start-developing) page, press <kbd>a</kbd> to open the Android Emulator. Expo CLI will install Expo Go automatically.


# Create a development build for a physical iOS device with EAS

## Set up an iOS device with a development build
<BuildEnvironmentSwitch />
Step 1: 
### Enroll in the Apple Developer Program
To install a development build on your iOS device, you will need an active subscription to the Apple Developer Program. Sign up for the [Apple Developer Program here](https://developer.apple.com/programs/).
Step 2: 
### Install EAS CLI
To build your app, you will need to install EAS CLI. You can do this by running the following command in your terminal:
```sh
$ npm install -g eas-cli
```
Step 3: 
### Create an Expo account and login
Next, you will need to create an Expo account and login to the EAS CLI.
1. [Sign up](https://expo.dev/signup) for an Expo account.
2. Run the following command in your terminal to log in to the EAS CLI:
   ```sh
$ eas login
```
Step 4: 
### Configure your project
Run the following command to create an EAS config in your project:
```sh
$ eas build:configure
```
Step 5: 
### Create an ad hoc provisioning profile
To install a development build on your iOS device, you will need to create an ad hoc provisioning profile. Create one by running the following command in your terminal:
```sh
$ eas device:create
```
Step 6: 
### Create a development build
Run the following command to create a development build:
```sh
$ eas build --platform ios --profile development
```
Step 7: 
### Install the development build on your device
After the build is complete, scan the QR code in your terminal and tap **Open with iTunes** when it appears inside the Camera app. Alternatively, open the link displayed in the terminal on your device.
After confirming the installation, the app will appear in your device's app library.
Step 8: 
### Turn on developer mode
1. Open **Settings** > **Privacy & Security**, scroll down to the **Developer Mode** list item and navigate into it.
2. Tap the switch to enable **Developer Mode**. After you do so, Settings presents an alert to warn you that Developer Mode reduces your device's security. To continue enabling **Developer Mode**, tap the alert's **Restart** button.
3. After the device restarts and you unlock it, the device shows an alert confirming that you want to enable Developer Mode. Tap **Turn On**, and enter your device passcode when prompted.
> Alternatively, if you have Xcode installed on your Mac, you can use it to [enable iOS developer mode](/guides/ios-developer-mode/#connect-an-ios-device-with-a-mac).


# Create a development build for a physical iOS device locally

## Set up an iOS device with a development build
<BuildEnvironmentSwitch />
## Set up Xcode and Watchman
<XcodeInstructions />
## Configure your project
Step 1: 
### Install expo-dev-client
Run the following command in your project's root directory:
```sh
$ npx expo install expo-dev-client
```
Step 2: 
### Plug in your device via USB and enable developer mode
1. Connect your iOS device to your Mac using a USB cable. Unlock the device and tap **Trust** if prompted.
2. Open Xcode. From the menu bar, select **Window** > **Devices and Simulators**. You will see a warning in Xcode to enable developer mode.
3. On your iOS device, open **Settings** > **Privacy & Security**, scroll down to the **Developer Mode** list item and navigate into it.
4. Tap the switch to enable **Developer Mode**. After you do so, Settings presents an alert to warn you that Developer Mode reduces your device's security. To continue enabling **Developer Mode**, tap the alert's **Restart** button.
5. After the device restarts and you unlock it, the device shows an alert confirming that you want to enable Developer Mode. Tap **Turn On**, and enter your device passcode when prompted.
Step 3: 
### Run the project on your device
1. Add the `ios.bundleIdentifier` in the **app.json** file in the root directory to a unique value so that Xcode generates the provisioning profile for the app signing step.
2. Run the following command in your project's root directory and select your plugged in device from the list:
```sh
$ npx expo run:ios --device
```
> This command runs a development server after building your app. You can skip running `npx expo start` on the next page.


# Run on a physical iOS device with Expo Go

## Set up an iOS device with Expo Go
Scan the QR code to download the app from the App Store, or visit the Expo Go page on the [App Store](https://itunes.apple.com/app/apple-store/id982107779).
<div className="inline-block rounded-lg border border-default bg-palette-white p-4">
  <QRCodeReact value="https://itunes.apple.com/app/apple-store/id982107779" size={228} />
</div>


# Create a development build for iOS Simulator with EAS

## Set up an iOS Simulator with a development build
<BuildEnvironmentSwitch />
## Set up Xcode
<XcodeInstructions />
## Create a development build
Step 1: 
### Install EAS CLI
To build your app, you will need to install EAS CLI. You can do this by running the following command in your terminal:
```sh
$ npm install -g eas-cli
```
Step 2: 
### Create an Expo account and login
Next, you will need to create an Expo account and login to the EAS CLI.
1. [Sign up](https://expo.dev/signup) for an Expo account.
2. Run the following command in your terminal to log in to the EAS CLI:
   ```sh
$ eas login
```
Step 3: 
### Configure your project
Run the following command to create an EAS config in your project:
```sh
$ eas build:configure
```
Step 4: 
### Adjust your build profile
To create a simulator-compatible development build, you'll need to update your build profile in **eas.json** to set the `ios.simulator` property to `true`:
```json eas.json
{
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "simulator": true
      }
    }
  }
}
```
Step 5: 
### Create a development build
Run the following command to create a development build:
```sh
$ eas build --platform ios --profile development
```
Step 6: 
### Install the development build on your simulator
After the build is complete, the CLI will prompt you to automatically download and install it on the iOS Simulator. When prompted, press <kbd>Y</kbd> to directly install it on the simulator.
If you miss this prompt, you can download the build from the link provided in the terminal and drag and drop it onto the iOS Simulator to install it.


# Create a development build for iOS Simulator locally

## Set up an iOS Simulator with a development build
<BuildEnvironmentSwitch />
## Set up Xcode and Watchman
<XcodeInstructions />
## Running your app on an iOS Simulator
Step 1: 
### Install expo-dev-client
Run the following command in your project's root directory:
```sh
$ npx expo install expo-dev-client
```
Step 2: 
Run the following from your terminal:
```sh
$ npx expo run:ios
```
> This command runs a development server after building your app. You can skip running `npx expo start` on the next page.


# Run on iOS Simulator with Expo Go

## Set up an iOS Simulator with Expo Go
## Set up Xcode
<XcodeInstructions />
## Install Expo Go
When you start a development server with `npx expo start` on the [start developing](/get-started/start-developing) page, press <kbd>i</kbd> to open the iOS Simulator. Expo CLI will install Expo Go automatically.



## Next step
You have a project and a development environment. Now it's time to start developing.


## Start developing

Make your first change to an Expo project and see it live on your device.

Step 1: 
## Start a development server
To start the development server, run the following command:
```sh
$ npx expo start
```
Step 2: 
## Open the app on your device
After running the command above, you will see a QR code in your terminal. Scan this QR code to open the app on your device.
If you're using an Android Emulator or iOS Simulator, you can press <kbd>a</kbd> or <kbd>i</kbd> respectively to open the app.
Note: Having problems?
---
Make sure you are on the same Wi-Fi network on your computer and your device.
If it still doesn't work, it may be due to the router configuration &mdash; this is common for public networks. You can work around this by choosing the **Tunnel** connection type when starting the development server, then scanning the QR code again.
```sh
$ npx expo start --tunnel
```
> Using the **Tunnel** connection type will make the app reloads considerably slower than on **LAN** or **Local**, so it's best to avoid tunnel when possible. You may want to install and use an emulator or simulator to speed up development if **Tunnel** is required to access your machine from another device on your network.
---
Step 3: 
## Make your first change
Open the **app/(tabs)/index.tsx** file in your code editor and make a change.
```diff
diff --git a/app/(tabs)/index.tsx b/app/(tabs)/index.tsx
index 45cfa0e..4d1b384 100644
--- a/app/(tabs)/index.tsx
+++ b/app/(tabs)/index.tsx
@@ -17,7 +17,7 @@ export default function HomeScreen() {
      }
    >
      <ThemedView style={styles.titleContainer}>
-       <ThemedText type="title">Welcome!</ThemedText>
+       <ThemedText type="title">Hello World!</ThemedText>
        <HelloWave />
      </ThemedView>
      <ThemedView style={styles.stepContainer}>
```
Note: Changes not showing up on your device?
---
Expo Go is configured by default to automatically reload the app whenever a file is changed, but let's make sure to go over the steps to enable it in case somehow things aren't working.
- Make sure you have the [development mode enabled in Expo CLI](/workflow/development-mode#development-mode).
- Close the Expo app and reopen it.
- Once the app is open again, shake your device to reveal the developer menu. If you are using an emulator, press <kbd>Ctrl</kbd> + <kbd>M</kbd> for Android or <kbd>Cmd ⌘</kbd> + <kbd>D</kbd> for iOS.
- If you see **Enable Fast Refresh**, press it. If you see **Disable Fast Refresh**, dismiss the developer menu. Now try making another change.
---
---
## File structure
Below, you can get familiar with the default project's file structure:
<ProjectStructure />
## Features
The default project template has the following features:
<TemplateFeatures />


## Next steps

Develop, review, and submit your project.

Here are next steps to continue building your app:
### Reset your project
You can remove the boilerplate code and start fresh with a new project. Run the following command to reset your project:
```sh
$ npm run reset-project
```
This command will move the existing files in **app** to **app-example**, then create a new **app** directory with a new **index.tsx** file.
### Develop, review, and deploy
Learn how to develop by reading the docs in the Develop section. You'll learn how to create [UI elements](/develop/user-interface/splash-screen-and-app-icon/), add [unit tests](/develop/unit-testing/), include [native modules](/config-plugins/introduction/), and more.
Once you've developed your app, you can share it with your teammates for [review](/review/overview).
Finally, you can [build](/deploy/build-project/) and [submit](/deploy/submit-to-app-stores/) your project to the app stores.
### Step-by-step guide
For a guided, step-by-step walkthrough of building an app with Expo from start to finish, check out the [tutorial](/tutorial/introduction/).


# Develop

## Tools for development

An overview of Expo tools and websites that will help you during various aspects of your project-building journey.

When you create a new project with Expo, learning about the following essential tools and websites can help you during your app development journey. This page provides an overview of a list of recommended tools.
## Expo CLI
Expo CLI is a development tool and is installed automatically with `expo` package when you create a new project. You can use it by leveraging `npx` (a Node.js package runner).
It is designed to help you move faster during the app development phase. For example, your first interaction with Expo CLI is starting the development server by running the command: `npx expo start`.
The following is a list of common commands that you will use with Expo CLI while developing your app:
| Command                         | Description                                                                                                                                                      |
| ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `npx expo start`                | Starts the development server (whether you are using a development build or Expo Go).                                                                            |
| `npx expo prebuild`             | Generates native Android and iOS directories using [Prebuild](/workflow/prebuild/).                                                                              |
| `npx expo run:android`          | Compiles native Android app locally.                                                                                                                             |
| `npx expo run:ios`              | Compiles native iOS app locally.                                                                                                                                 |
| `npx expo install package-name` | Used to install a new library or validate and update specific libraries in your project by adding `--fix` option to this command.                                |
| `npx expo lint`                 | [Setup and configures](/guides/using-eslint/) ESLint. If ESLint is already configured, this command will [lint your project files](/guides/using-eslint/#usage). |
In a nutshell, Expo CLI allows you to develop, compile, start your app, and more. See [Expo CLI reference](/more/expo-cli/) for more available options and actions you can perform with the CLI.
## EAS CLI
EAS CLI is used to log in to your Expo account and compile your app using different EAS services such as Build, Update, or Submit. You can also use this tool to:
- Publish your app to the app stores
- Create a development, preview, or production build of your app
- Create over-the-air (OTA) updates
- Manage your app credentials
- Create an ad hoc provisioning profile for an iOS device
To use EAS CLI, you need to install it globally on your local machine by running the command:
```sh
$ npm install -g eas-cli
```
You can use `eas --help` in your terminal window to learn more about the available commands. For a complete reference, see [`eas-cli` npm page](https://www.npmjs.com/package/eas-cli).
## Expo Doctor
Expo Doctor is a command line tool used to diagnose issues in your Expo project. To use it, run the following command in your project's root directory:
```sh
$ npx expo-doctor
```
This command performs checks and analyzes your project's codebase for common issues in [app config](/workflow/configuration/) and **package.json** files, dependency compatibility, configuration files, and the overall health of the project. Once the check is complete, Expo Doctor outputs the results.
If Expo Doctor finds an issue, it provides a description of the problem along with advice on how to fix it or where to find help.
By default, Expo Doctor validates your project's packages against the [React Native directory](https://reactnative.directory/) and checks if app config properties are properly synced when native directories exist. You can configure these checks in your project's **package.json** file. See [`reactNativeDirectoryCheck`](/versions/latest/config/package-json/#reactnativedirectorycheck) and [`appConfigFieldsNotSyncedCheck`](/versions/latest/config/package-json/#appconfigfieldsnotsynced) for more details.
You can also use `npx expo-doctor --help` to display usage information.
## Orbit
Orbit is a macOS and Windows app that enables:
- Install and launch builds from EAS on physical devices and emulators.
- Install and launch updates from EAS on Android Emulators or iOS Simulators.
- Launch snack projects on Android Emulators or iOS Simulators.
- Use local files to install and launch apps. Orbit supports any Android **.apk**, iOS Simulator compatible **.app**, or ad hoc signed apps.
- See a list of pinned projects from your EAS dashboard.
### Installation
For macOS: 
You can download Orbit with Homebrew for macOS, or directly from the [GitHub releases](https://github.com/expo/orbit/releases).
```sh
$ brew install expo-orbit
```
If you want Orbit to start when you log in automatically, click on the Orbit icon in the menu bar, then **Settings** and select the **Launch on Login** option.
For Windows: 
> **important** Orbit for Windows is in preview and is only compatible with x64 and x86 machines. Compatibility for other architectures will be added in the future.
You can download Orbit for Windows directly from the [GitHub releases](https://github.com/expo/orbit/releases).
> **info** Orbit relies on the Android SDK on both macOS and Windows and `xcrun` for device management only on macOS, which requires setting up both [Android Studio](/workflow/android-studio-emulator/) and [Xcode](/workflow/ios-simulator/).
{/* ### Usage */}
## Expo Tools for VS Code
Expo Tools is a VS Code extension to improve your development experience when working with app config files. It provides features such as autocomplete and intellisense for files such as app config, EAS config, store config and Expo Module config files.
You can also use it to debug your app using VS Code's built-in debugger to set breakpoints, inspect variables, execute code through the debug console, and more. See [Debugging with VS Code](/debugging/tools/#debugging-with-vs-code) for how to use this extension for debugging.
## Test prototypes with Snack and Expo Go
### Snack
Snack is an in-browser development environment that works similarly to Expo Go. It's a great way to share code snippets and experiment with React Native without downloading any tools on your computer.
To use it, go to [snack.expo.dev](https://snack.expo.dev/), edit the `<Text>` component in **App.js**, choose a platform (Android, iOS, or web) in the right panel and see the changes live.
### Expo Go
[Expo Go](https://expo.dev/go) is a free open-source, sandbox for learning and experimenting with React Native. It works with Android and iOS.
For more information on how to use it:
- Click [this link](/get-started/set-up-your-environment/?mode=expo-go) to go to Set up your environment guide
- Select a platform to develop under **Where would you like to develop?**
- Select Expo Go under **How would you like to develop?**
- Follow the instructions described in that guide
> **Note:** Not recommended for building and distributing production apps to the app stores. Instead, use [development builds](/get-started/set-up-your-environment/?mode=development-build).
Note: What if I open a project with an unsupported SDK version?
---
When running a project that was created for an unsupported SDK version in Expo Go, you'll see the following error:
```sh
"Project is incompatible with this version of Expo Go"
```
To fix this, upgrading your project to a [supported SDK version](/versions/latest/#each-expo-sdk-version-depends-on-a-react-native-version) is recommended. If you want to learn how to do it, see [Upgrade the project to a new SDK Version](#how-do-i-upgrade-my-project-from).
---
Note: How do I upgrade my project from an unsupported SDK version?
---
See [Upgrading Expo SDK guide](/workflow/upgrading-expo-sdk-walkthrough) for instructions for upgrading to a specific SDK version.
---
## React Native directory
Any library that is compatible with React Native works in an Expo project when you use a development build to create your project.
[reactnative.directory](https://reactnative.directory/) is a searchable database for React Native libraries. If a library you are looking for is not included in Expo SDK, use the directory to find a compatible library for your project.


## Navigation in Expo and React Native apps

Learn about the recommended approach for integrating navigation in an Expo and React Native project.

The core React Native library does not include a built-in navigation solution, so you can choose a navigation library that best fits your needs. For Expo and React Native apps, it is generally a choice between [React Navigation](https://reactnavigation.org/) or [Expo Router](/router/introduction/).
## Why React Native apps needs a navigation library
React Native core includes basic UI components, touch handling, device APIs and networking, but excludes, among other things, storage, camera, maps, most device sensors, and **navigation**! These are intended to be covered by community libraries.
## React Navigation
React Navigation is a component-based navigation library widely used across the React Native ecosystem. It lets you compose stack, tab, and drawer navigators entirely in code so you can implement complex flows, custom transitions, and app-specific UX patterns.
The library offers platform-specific look-and-feel with smooth animations and gestures, unified mobile and web routing, automatic deep links, type routes with static configuration, and is highly customizable.
## Expo Router (recommended for Expo projects)
Expo Router is a file-based routing library for Expo and React Native projects and is a built on top of React Navigation. By following the **app** directory convention, it turns files into routes and is integrated with Expo for [Expo CLI](/more/expo-cli/) and bundling without additional setup. The library also adds features such as typed routes, dynamic routes, lazy bundling in development, static rendering for the web, and automatic deep linking.
New Expo projects created with `npx create-expo-app@latest` include Expo Router by default so you can ship cross-platform navigation quickly while still being able to reach for React Navigation APIs when needed.


## Authentication in Expo and React Native apps

Learn about setting up authentication in your Expo project.

Authentication is a critical part of 90 to 95 percent of modern apps. This guide explains common methods, patterns, and solutions to help you implement authentication in your Expo app.
> **info** **TL;DR**: Auth is hard. If you want to skip the complexity, jump to the [Auth solutions](/#auth-solutions) section for ready-made solutions. Otherwise, keep reading.
Implementing authentication involves more than writing client-side code. You'll need to manage server requests, password flows, third-party providers like Google or Apple, email handling, and OAuth standards. It can get complex quickly.
There are several types of authentication methods. Some are simple and effective, while others offer a better user experience but require more work. Let's look at the most common approaches and how you can implement them.
## Navigation auth flow
Let's start with the basics: any authentication system needs to separate **public screens** (such as login or signup) from **protected screens** (such as home or profile). At the navigation level, it comes down to a simple check: is the user authenticated?
To begin, you can simulate this using a hardcoded boolean value, like `isAuthenticated = true`, and build your navigation logic around it. Once everything is working, you can plug in your real authentication flow.
Note: Using Expo Router
---
Expo Router v5 introduced [protected routes](/router/advanced/protected), which prevent users from accessing certain screens unless they are authenticated. This feature works well for client-side navigation and simplifies your setup.
If you're using an older version of Expo Router, you can use [redirects](/router/advanced/authentication-rewrites) instead. Redirects provide the same result but require a bit more manual configuration. They are still supported in Expo Router v5 for backward compatibility.
Video Tutorial: [Expo Router Protected Routes](https://www.youtube.com/watch?v=zHZjJDTTHJg)
---
Note: Using React Navigation
---
If you're using React Navigation, they offer a helpful [authentication flow guide](https://reactnavigation.org/docs/auth-flow/) that explains how to structure your navigation logic. It includes examples for both [static](https://reactnavigation.org/docs/auth-flow/?config=static#how-it-will-work) and [dynamic](https://reactnavigation.org/docs/auth-flow/?config=dynamic#how-it-will-work) approaches based on the user's authentication state.
---
Both Expo Router and React Navigation give you flexible tools to implement protected navigation based on whether the user is logged in.
## Email and password
Email and password is a popular option when adding authentication to your app.
To make this flow user-friendly, you also need to implement forgot password and reset password functionality so users who lose access to their accounts can recover them.
If you want a quicker solution, several services offer built-in email and password authentication, including [Clerk](/#clerk), [Supabase](/#supabase), [Cognito](/#cognito), [Firebase](/#firebase-auth), and [Better Auth](/#better-auth). Most of these have generous free tiers, but it is a good idea to evaluate pricing if your app grows quickly.
The biggest advantage of these services is their ease of integration. They usually offer clear documentation, starter kits, and prebuilt components that save you time.
Note: Security checklist (OWASP) and store-review gotchas
---
If you're building this flow yourself, be sure to review the [Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html#authentication-cheat-sheet) by OWASP. It outlines best practices for password length, encryption, recovery, secure storage, and more.
> **info** Adding email and password authentication is usually enough to pass App Store and Play Store review. You can submit your app with this method first. If you include "Sign in with Google," Apple may reject your app unless you also support "Sign in with Apple." The same rule applies in reverse on Google Play.
---
## Passwordless login
Passwordless login removes the need for users to create or remember a password. Instead, they provide their email address or phone number during registration. Your app then sends a [magic link](https://auth0.com/docs/authenticate/passwordless/authentication-methods/email-magic-link#classic-login-flow-with-magic-links) or [one-time passcode (OTP)](https://en.wikipedia.org/wiki/One-time_password) to their inbox or device. This is a smoother experience for most users and reduces friction during onboarding.
Note: Magic Links
---
With magic links, the user receives an email containing a link that redirects them back into your app. If everything works correctly, the session is verified and established.
A key detail here is [deep linking](/linking/into-your-app). Since users leave the app to check their email, the link must open your app and route them to the correct screen. If deep linking fails, the session cannot be validated, and the login flow breaks.
If you're using Expo Router deep linking is handled automatically (for most cases). You usually don't need to configure anything extra to make magic links work properly, which makes this approach even easier to adopt. See [Linking into your app](/linking/into-your-app) to learn more.
[React Navigation](https://reactnavigation.org/) also supports deep linking, but you will need to configure it manually. See its [Deep Linking guide](https://reactnavigation.org/docs/deep-linking/) for more details.
---
Note: One-Time Passcodes (OTP)
---
An alternative to magic links is sending a one-time passcode by email or SMS. Instead of clicking a link, the user copies the code and manually returns to the app to enter it. This must happen within a specific time window before the code expires.
There's no deep linking involved here. The user stays in control of the flow and must return to the app themselves.
Fortunately, newer versions of Android and iOS automatically detect passcodes in incoming messages. This enables autofill suggestions above the keyboard, allowing users to enter the code with a single tap. When this works, the experience is seamless.
---
> **info** Magic links and passcodes are both valid authentication methods for Google Play Store and Apple App Store reviews. You can submit your app with either of these methods as the only option and get approved, even before adding social or OAuth login options.
## OAuth 2.0
To let your users log in using their existing accounts from services like Google, Apple, GitHub, and more, you can use OAuth 2.0.
[OAuth 2.0](https://oauth.net/2) is a widely used, secure protocol that allows your app to access user information from another service, without needing to handle passwords. It allows your users to log in with a single tap, which saves time, builds trust, and removes the need to manage passwords.
> **info** OAuth flows can be complex. If you're looking for a simple integration, most providers offer SDKs and services that handle everything for you. You can learn more about these in the [Auth solutions](#auth-solutions) section.
If you are looking for full control or want to understand how OAuth works under the hood, the following sections show how to implement a complete OAuth flow yourself using Expo.
### How OAuth works
OAuth works by introducing an authorization server that acts as a secure middleman. Instead of giving your app their password, users log in through this server and approve access to specific data (like their name or email). The server then issues a temporary code, which your app can exchange for a secure access token.
Once you understand this pattern, you can apply it to any provider. The setup for Google, Apple, or GitHub will follow the same general steps.
### Custom OAuth with Expo API Routes
The previous diagram shows a high-level overview of the OAuth flow. However, the preferred method for a client to obtain an authorization grant from the user is to use an authorization server as an intermediary, which is exactly what you can build using Expo API Routes.
The following diagram illustrates this flow in more detail:
Expo lets you implement the entire OAuth flow directly in your app using:
Some providers offer native APIs to handle the sign-in flow directly within the app. Google offers a native Sign in with Google experience on Android. If you're looking for a native implementation, see the [Google authentication guide](/guides/google-authentication). Apple provides Sign in with Apple, which uses a native bottom sheet and Face ID on iOS. See [`expo-apple-authentication`](/versions/latest/sdk/apple-authentication) reference.
The following setup gives you full control over the login experience across Android, iOS, and web.
Note: What are Expo API Routes?
---
[Expo Router API Routes](/router/web/api-routes) allow you to write server-side logic directly inside your Expo app. You can define functions that handle requests just like an Express or Next.js backend, no need for an external server.
This makes it easy to securely handle sensitive parts of the auth flow, like the [authorization code exchange](https://www.oauth.com/oauth2-servers/pkce/authorization-code-exchange), directly within your app. Since these routes run on the server, you can safely manage secrets, issue JWTs, and validate tokens.
> **info** You're essentially building a lightweight custom auth server scoped to your own application, all using your Expo project.
---
Note: What is Expo AuthSession?
---
[Expo AuthSession](/versions/latest/sdk/auth-session) is a client-side package that helps you open a web browser or native modal to start the OAuth login flow. It handles redirection, parses the authorization response, and brings the user back into your app.
It's the tool that kicks off the flow and talks to your API Route after the user authorizes access. See [Authentication with OAuth or OpenID providers](/guides/authentication/) for more information.
---
This setup lets you:
- Start the login flow using AuthSession
- Receive the auth code in your API Route
- Exchange the code for a token securely
- Generate a custom JWT with your own logic
- Return that token to the client
- Store sessions using cookies (Web) or JWTs (Native)
- Deploy instantly using EAS Hosting (free to start)
The following tutorials cover implementing OAuth on Android, iOS, and web, including how to create and verify custom JWTs, manage sessions, and protect API routes. If you're new to this flow, we recommend starting with the Google tutorial.
Video Tutorial: [Google Sign-In with Expo OAuth](https://www.youtube.com/watch?v=V2YdhR1hVNw)
Video Tutorial: [Sign in with Apple using Expo](https://www.youtube.com/watch?v=tqxTijhYhp8)
Note: Managing sessions after OAuth
---
Handling the OAuth flow securely is just the beginning. Once the user is authenticated, you need to think about how to store, restore, and validate their session.
This includes:
- Storing the session securely on the client
- Restoring it when the app restarts
- Protecting your API routes so only authenticated users can access them
Traditionally, [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies#what_cookies_are_used_for) are used to store sessions on the web, while [JSON Web Tokens (JWTs)](https://en.wikipedia.org/wiki/JSON_Web_Token) are common in native applications.
The above tutorials demonstrate exactly how to handle this. After receiving the ID token from a provider like Google or Apple, you generate a custom JWT on the server using Expo API Routes.
This gives you full control over the session, including:
- Structuring the payload using consistent fields across providers
- Customizing expiration times
- Signing the token with a secret key so your server can verify it later
Once the token is created:
- For Android and iOS apps, you can store it securely using [`expo-secure-store`](/versions/latest/sdk/securestore/)
- For web apps, you can set it as a secure cookie to maintain the session
On every request, the token is sent back to your server, where you verify the signature and check the expiration. If everything checks out, you continue processing the request.
This session model keeps your backend stateless, scalable, and secure, and works consistently across platforms.
All of this is covered in the video tutorials linked above, including:
- Generating and verifying custom JWTs
- Handling session storage with Secure Store and cookies
- Protecting API routes with authentication logic
---
## Auth solutions
If you prefer not to build a full authentication system from scratch, several services offer built-in solutions with first-class support for Expo. Here are some of the most popular options:
Note: Better Auth
---
[BetterAuth](https://www.better-auth.com/docs/integrations/expo) is a modern, open-source authentication provider built for developers. It integrates smoothly with Expo, and they offer a guide that shows how to use it with [Expo API Routes](https://www.better-auth.com/docs/integrations/expo) for full control. It works well with any provider and deploys easily with EAS Hosting.
---
Note: Clerk
---
[Clerk](https://clerk.com/expo-authentication) is a powerful, full-featured authentication service with excellent Expo support. It includes email/password, passcodes, magic links, OAuth providers, and even passkeys. They also offer a native Expo module that handles much of the integration for you.
---
Note: Supabase
---
[Supabase](https://supabase.com/docs/guides/getting-started/tutorials/with-expo-react-native) provides a full backend platform, including a built-in authentication service that works with any OAuth provider. It integrates well with Expo apps and also includes support for email, magic links, and more.
---
Note: Cognito
---
[AWS Cognito](https://medium.com/@juliuscecilia33/aws-cognito-and-react-native-bf23ef7fea23) is Amazon's solution for managing user pools and identity. It connects seamlessly with other AWS services and can be integrated into Expo apps using AWS Amplify. It does require more configuration, but it's robust and scalable.
---
Note: Firebase Auth
---
[Firebase Authentication](https://rnfirebase.io/auth/usage) is Google's auth platform and supports email, magic links, and OAuth providers. It works with React Native through [`react-native-firebase`](https://github.com/invertase/react-native-firebase), which is compatible with Expo development builds.
---
## Modern methods
Once you have a working authentication system in place, you can improve the user experience by adding optional but powerful enhancements like biometrics and passkeys. These features add convenience, trust, and speed to your login flows.
Note: Biometrics
---
Biometrics like Face ID and Touch ID can be used to unlock the app or confirm identity after a valid session is established. These are not authentication methods on their own, but act as a local gate that makes re-authentication faster and more secure.
React Native provides access to biometric APIs through libraries like [`expo-local-authentication`](/versions/latest/sdk/local-authentication) or [`react-native-biometrics`](https://github.com/SelfLender/react-native-biometrics).
---
Note: Passkeys
---
[Passkeys](https://safety.google/authentication/passkey) are a new, passwordless way to log in to apps and websites. Backed by Apple, Google, and Microsoft, they use platform-level cryptography and biometrics to authenticate users without passwords.
Passkeys offer a seamless and secure experience, but they require a user to already be authenticated before registering one. They also require extra configuration if you're not using a provider that handles them for you.
- React Native passkey support: [`react-native-passkeys`](https://github.com/peterferguson/react-native-passkeys)
- Native passkey support with Clerk: [Clerk Passkeys for Expo](https://clerk.com/docs/references/expo/passkeys)
---
## Recommendations
This guide covers a lot of ground, from basic email and password flows to fully custom OAuth implementations, session management, and modern methods like biometrics and passkeys. Not all of these need to be implemented at once.
In many cases, starting simple is the best approach. Shipping your app with something like email authentication using a magic link or one-time passcode is often more than enough to get through the App Store review process and start collecting feedback from real users.
That said, if you're building an app where you expect high traffic from day one or need to support sign-in across platforms with minimal friction, investing in a more complete authentication flow early on can make a big difference. It can help improve user onboarding, trust, and retention right from the start.
Modern solutions like OAuth, biometrics, and passkeys are not required, but they can be excellent additions once your core system is in place.
The key is to build authentication that fits your current needs, while staying flexible enough to grow with your product.


## Unit testing with Jest

Learn how to set up and configure the jest-expo library to write unit and snapshot tests for a project with Jest.

[Jest](https://jestjs.io) is the most widely used unit and snapshot JavaScript testing framework. In this guide, you will learn how to set up Jest in your project, write a unit test, write a snapshot test, and best practices for structuring your tests when using Jest with React Native.
You will also use the [`jest-expo`](https://github.com/expo/expo/tree/main/packages/jest-expo) library, which is a Jest preset that mocks the native part of the Expo SDK and handles most of the configuration required for your Expo project.
## Installation and configuration
After creating your Expo project, follow the instructions below to install and configure `jest-expo` in your project:
Step 1: 
Install `jest-expo` and other required dev dependencies in your project. Run the following command from your project's root directory:
For macOS/Linux: 
```sh
$ npx expo install jest-expo jest @types/jest --dev
```
For Windows: 
```sh
$ npx expo install jest-expo jest @types/jest "--" --dev
```
> **Note:** If your project is not using TypeScript, you can skip installing `@types/jest`.
Step 2: 
Open **package.json**, add a script for running tests, and add the preset for using the base configuration from `jest-expo`:
```json package.json
{
  "scripts": {
  },
  "jest": {
    "preset": "jest-expo"
  }
}
```
Step 3: 
In **package.json**, add `jest-expo` as a preset so that a base for Jest's configuration is set up:
```json package.json
{
  "jest": {
    "preset": "jest-expo"
  }
}
```
Note: Additional configuration for using 
---
You can transpile node modules your project uses by configuring [`transformIgnorePatterns`](https://jestjs.io/docs/configuration#transformignorepatterns-arraystring) in your **package.json**. This property takes a regex pattern as its value:
For npm/Yarn: 
```json package.json
"jest": {
  "preset": "jest-expo",
  "transformIgnorePatterns": [
    "node_modules/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?/.*|@expo-google-fonts/.*|react-navigation|@react-navigation/.*|@sentry/react-native|native-base|react-native-svg)"
  ]
}
```
For pnpm: 
```json package.json
"jest": {
  "preset": "jest-expo",
  "transformIgnorePatterns": [
    "node_modules/(?!(?:.pnpm/)?((jest-)?react-native|@react-native(-community)?|expo(nent)?|@expo(nent)?/.*|@expo-google-fonts/.*|react-navigation|@react-navigation/.*|@sentry/react-native|native-base|react-native-svg))"
  ]
}
```
Jest has many configuration options, but the above configuration should cover most of your needs. However, you can always add to this pattern list. For more details, see [Configuring Jest](https://jestjs.io/docs/configuration).
---
## Install React Native Testing Library
The [React Native Testing Library (`@testing-library/react-native`)](https://callstack.github.io/react-native-testing-library/) is a lightweight solution for testing React Native components. It provides utility functions and works with Jest.
To install it, run the following command:
For macOS/Linux: 
```sh
$ npx expo install @testing-library/react-native --dev
```
For Windows: 
```sh
$ npx expo install @testing-library/react-native "--" --dev
```
> **warning** **Deprecated:** `@testing-library/react-native` replaces the deprecated `react-test-renderer` because `react-test-renderer` does not support React 19 and above. Remove the deprecated library from your project if you are currently using it. See [React's documentation for more information](https://react.dev/warnings/react-test-renderer).
## Unit test
A unit test checks the smallest unit of code, usually a function. To write your first unit test, take a look at the following example:
Step 1: 
Inside the **app** directory of your project, create a new file called **index.tsx**, and the following code to render a simple component:
```tsx index.tsx
import { PropsWithChildren } from 'react';
import { StyleSheet, Text, View } from 'react-native';
export const CustomText = ({ children }: PropsWithChildren) => <Text>{children}</Text>;
export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <CustomText>Welcome!</CustomText>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
Step 2: 
Create a **\_\_tests\_\_** directory at the root of your project's directory. If this directory already exists in your project, use that. Then, create a new file called **HomeScreen-test.tsx**. The `jest-expo` preset customizes the Jest configuration to also identify files with **-test.ts|tsx** extensions as tests.
Add the following example code in **HomeScreen-test.tsx**:
```tsx HomeScreen-test.tsx
import { render } from '@testing-library/react-native';
import HomeScreen, { CustomText } from '@/app/index';
describe('<HomeScreen />', () => {
  test('Text renders correctly on HomeScreen', () => {
    const { getByText } = render(<HomeScreen />);
    getByText('Welcome!');
  });
});
```
In the above example, the `getByText` query helps your tests find relevant element in your app's user interface and make assertion whether or not the certain element exists. The React Native Testing Library provides this query, and each [query variant](https://callstack.github.io/react-native-testing-library/docs/api/queries#query-variant) differs in its return type. For more examples and detailed API information, see the React Native Testing Library's [Queries API reference](https://callstack.github.io/react-native-testing-library/docs/api/queries).
Step 3: 
Run the following command in a terminal window to execute the test:
```sh
$ npm run test
```
You will see one test being passed.
## Structure your tests
Organizing your test files is important to make them easier to maintain. A common pattern is creating a **\_\_tests\_\_** directory and putting all your tests inside.
An example structure of tests next to the **components** directory is shown below:
```
├── __tests__/
│   └── ThemedText-test.tsx
└── components/
    ├── ThemedText.tsx
    └── ThemedView.tsx
```
Alternatively, you can have multiple **\_\_tests\_\_** sub-directories for different areas of your project. For example, create a separate test directory for **components**, and so on:
```
├── components/
│   ├── ThemedText.tsx
│   └── __tests__/
│       └── ThemedText-test.tsx
└── utils/
    ├── index.tsx
    └── __tests__/
        └── index-test.tsx
```
It's all about preferences, and it is up to you to decide how you want to organize your project directory.
## Snapshot test
> **info** **Note:** For UI testing, we recommend end-to-end tests instead of snapshot unit tests. See the [E2E tests with Maestro](/eas/workflows/examples/e2e-tests/) guide.
A [snapshot test](https://jestjs.io/docs/en/snapshot-testing) is used to make sure that UI stays consistent, especially when a project is working with global styles that are potentially shared across components.
To add a snapshot test for `<HomeScreen />`, add the following code snippet in the `describe()` in **HomeScreen-test.tsx**:
```tsx HomeScreen-test.tsx
describe('<HomeScreen />', () => {
  test('CustomText renders correctly', () => {
    const tree = render(<CustomText>Some text</CustomText>).toJSON();
    expect(tree).toMatchSnapshot();
  });
});
```
Run `npm run test` command, and you will see a snapshot created inside **\_\_tests\_\_\\\_\_snapshots\_\_** directory, and two tests passed.
## Code coverage reports
Code coverage reports can help you understand how much of your code is tested. To see the code coverage report in your project using the HTML format, in **package.json**, under `jest`, set the `collectCoverage` to true and use `collectCoverageFrom` to specify a list of files to ignore when collecting the coverage.
```json package.json
"jest": {
  ...
  "collectCoverage": true,
  "collectCoverageFrom": [
    "**/*.{ts,tsx,js,jsx}",
    "!**/coverage/**",
    "!**/node_modules/**",
    "!**/babel.config.js",
    "!**/expo-env.d.ts",
    "!**/.expo/**"
  ]
}
```
Run `npm run test`. You will see a **coverage** directory created in your project. Find the **lcov-report/index.html** and open it in a browser to see the coverage report.
> Usually, we don't recommend uploading **index.html** file to git. Add `coverage/**/*` in the **.gitignore** file to prevent it from being tracked.
## Jest flows (optional)
You can also use different flows to run your tests. Below are a few example scripts that you can try:
```json package.json
"scripts": {
  "test": "jest --watch --coverage=false --changedSince=origin/main",
  "testDebug": "jest -o --watch --coverage=false",
  "testFinal": "jest",
  "updateSnapshots": "jest -u --coverage=false"
}
```
For more information, see [CLI Options](https://jestjs.io/docs/en/cli) in Jest documentation.
## Additional information


# User interface

## Splash screen and app icon

Learn how to add a splash screen and app icon to your Expo project.

A splash screen and an app icon are fundamental elements of a mobile app. They play an important role in the user experience and branding of the app. This guide provides steps on how to create and add them to your app.
Video Tutorial: [Create an App Icon and Splash Screen](https://www.youtube.com/watch?v=3Bsw8a1BJoQ)
---
## Splash screen
A splash screen, also known as a launch screen, is the first screen a user sees when they open your app. It stays visible while the app is loading. You can also control the behavior of when a splash screen disappears by using the native [SplashScreen API](/versions/latest/sdk/splash-screen).
The [`expo-splash-screen`](/versions/latest/sdk/splash-screen) has a built-in [config plugin](/config-plugins/introduction) that lets you configure properties such as the splash icon and background color.
> **warning** **Do not use Expo Go or a development build to test your splash screen**. Expo Go renders your app icon while the splash screen is visible, which can interfere with testing. Development builds include `expo-dev-client`, which has its own splash screen and may cause conflicts. **Instead, use a [preview build](/build/eas-json/#preview-builds) or a [production build](/build/eas-json/#production-builds)**.
Step 1: 
### Create a splash screen icon
To create a splash screen icon, you can use this [Figma template](https://www.figma.com/community/file/1466490409418563617). It provides a bare minimum design for an icon and splash images for Android and iOS.
**Recommended:**
- Use a 1024x1024 image.
- Use a **.png** file.
- Use a transparent background.
Step 2: 
### Export the splash icon as a .png
After creating a splash screen icon, export it as a **.png** and save it in the **assets/images** directory. By default, Expo uses **splash-icon.png** as the file name. If you decide to change the name of your splash screen file, make sure to use that in the next step.
> **Note:** **Currently, only .png images are supported** to use as a splash screen icon in an Expo project. If you use another image format, making a production build of your app will fail.
Step 3: 
### Configure the splash screen icon
Open the app config file, and under plugins, set the following properties:
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-splash-screen",
        {
          "backgroundColor": "#232323",
          "image": "./assets/images/splash-icon.png",
          "dark": {
            "image": "./assets/images/splash-icon-dark.png",
            "backgroundColor": "#000000"
          },
          "imageWidth": 200
        }
      ]
    ]
  }
}
```
To test your new splash screen, build your app for [internal distribution](/tutorial/eas/internal-distribution-builds) or for production, see guides on [Android](/tutorial/eas/android-production-build/) and [iOS](/tutorial/eas/ios-production-build/).
Note: Configuring  properties separately for Android and iOS
---
[`expo-splash-screen`](/versions/latest/sdk/splash-screen) also supports `android` and `ios` properties for configuring the splash screen for a specific platform. See the following example:
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-splash-screen",
        {
          "ios": {
            "backgroundColor": "#ffffff",
            "image": "./assets/images/splash-icon.png",
            "resizeMode": "cover"
          },
          "android": {
            "backgroundColor": "#0c7cff",
            "image": "./assets/images/splash-android-icon.png",
            "imageWidth": 150
          }
        }
      ]
    ]
  }
}
```
---
Note: Not using prebuild?
---
If your app does not use [Expo Prebuild](/workflow/prebuild) (formerly the _managed workflow_) to generate the native **android** and **ios** directories, then changes in the app config will have no effect. For more information, see [how you can customize the configuration manually](https://github.com/expo/expo/tree/main/packages/expo-splash-screen#-installation-in-bare-react-native-projects).
---
Note: Troubleshooting: New splash screen not appearing on iOS
---
For SDK versions below 52, in iOS development builds, launch screens can sometimes remain cached between builds, making it harder to test new images. Apple recommends clearing the _derived data_ directory before rebuilding, this can be done with Expo CLI by running:
```sh
$ npx expo run:ios --no-build-cache
```
See [Apple's guide on testing launch screens](https://developer.apple.com/documentation/technotes/tn3118-debugging-your-apps-launch-screen) for more information.
---
## App icon
An app's icon is what your app users see on their device's home screen and app stores. Android and iOS have different and strict requirements.
Step 1: 
### Create an app icon
To create an app icon, you can use this [Figma template](https://www.figma.com/community/file/1466490409418563617). It provides a bare minimum design for an icon and splash images for Android and iOS.
Step 2: 
### Export the icon image as a .png
After creating an app icon, export it as **.png** and save it in the **assets/images** directory. By default, Expo uses **icon.png** as the file name. If you decide to use a different file name, make sure to use that in the next step.
Step 3: 
### Add the icon in app config
Open the app config and add the local path as the value of [`icon`](/versions/latest/config/app/#icon) property to point it to your new app icon:
```json app.json
{
  "icon": "./assets/images/icon.png"
}
```
Note: Custom configuration tips for Android and iOS
---
#### Android
Further customization of the Android icon is possible using the [`android.adaptiveIcon`](/versions/latest/config/app/#adaptiveicon) property, which will override both of the previously mentioned settings.
The Android Adaptive Icon is formed from two separate layers &mdash; a foreground image and a background color or image. This allows the OS to mask the icon into different shapes and also supports visual effects. For Android 13 and later, the OS supports a themed app icon that uses a wallpaper and theme to determine the color set by the device's theme.
The design you provide should follow the [Android Adaptive Icon Guidelines](https://developer.android.com/develop/ui/views/launch/icon_design_adaptive) for launcher icons. You should also:
- Use **.png** files.
- Use the `android.adaptiveIcon.foregroundImage` property to specify the path to your foreground image.
- Use the `android.adaptiveIcon.monochromeImage` property to specify the path to your monochrome image.
- The default background color is white; to specify a different background color, use the `android.adaptiveIcon.backgroundColor` property. You can instead specify a background image using the `android.adaptiveIcon.backgroundImage` property. Make sure that it has the same dimensions as your foreground image.
You may also want to provide a separate icon for older Android devices that do not support Adaptive Icons. You can do so with the `android.icon` property. This single icon would be a combination of your foreground and background layers.
> See [Apple best practices](https://developer.apple.com/design/human-interface-guidelines/app-icons/#Best-practices) to ensure your icon looks professional, such as testing your icon on different wallpapers and avoiding text beside your product's wordmark. Provide an icon that's at least 512x512 pixels.
#### iOS
<VideoBoxLink
  videoId="RZ_QMym3adw"
  title="Icon Composer"
  description="Learn how to use the new Icon Composer to create app icons for an Expo project."
  className="mb-4"
/>
For iOS, your app's icon should follow the [Apple Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/app-icons/). You can use the [Icon Composer](https://developer.apple.com/icon-composer/) app to create your app icon. This will output a **.icon** directory that you can add to your project's **assets** directory. You can then provide the path to this directory in your app config. Adding support for dark mode is handled in Icon Composer, so you do not need to provide variants when using this approach.
> **info** **Note:** Providing an Icon Composer **.icon** directory via `ios.icon` is supported **in SDK 54** and later.
```json app.json
{
  "expo": {
    "ios": {
      "icon": "./assets/app.icon"
    }
  }
}
```
Alternatively, the previous approach of providing an image is still supported. You should:
- Use a **.png** file.
- 1024x1024 is a good size. If you have an Expo project created using `npx create-expo-app`, [EAS Build](/build/setup/) will generate the other sizes for you. In case of a bare React Native project, generate the icons on your own. The largest size EAS Build generates is 1024x1024.
- The icon must be exactly square. For example, a 1023x1024 icon is not valid.
- Make sure the icon fills the whole square, with no rounded corners or other transparent pixels. The operating system will mask your icon when appropriate.
- Use `ios.icon` to specify different icons for various system appearances (for example, dark and tinted) can be provided. If specified, this overrides the top-level icon key in the app config file. See the example below:
```json app.json
{
  "expo": {
    "ios": {
      "icon": {
        "dark": "./assets/images/ios-dark.png",
        "light": "./assets/images/ios-light.png",
        "tinted": "./assets/images/ios-tinted.png"
      }
    }
  }
}
```
---


## Safe areas

Learn how to add safe areas for screen components inside your Expo project.

Creating a safe area ensures your app screen's content is positioned correctly. This means it doesn't get overlapped by notches, status bars, home indicators, and other interface elements that are part of the device's physical hardware or are controlled by the operating system. When the content gets overlapped, it gets concealed by these interface elements.
Here's an example of an app screen's content getting concealed by the status bar on Android. On iOS, the same content is concealed by rounded corners, notch, and the status bar.
## Use `react-native-safe-area-context` library
[`react-native-safe-area-context`](https://github.com/AppAndFlow/react-native-safe-area-context) provides a flexible API for handling Android and iOS device's safe area insets. It also provides a `SafeAreaView` component that you can use instead of a [`<View>`](https://reactnative.dev/docs/view) to account for safe areas automatically in your screen components.
Using the library, the result of the previous example changes as it displays the content inside a safe area, as shown below:
### Installation
You can skip installing `react-native-safe-area-context` if you have created a project using [the default template](/get-started/create-a-project/). This library is installed as peer dependency for Expo Router library. Otherwise, install it by running the following command:
```sh
$ npx expo install react-native-safe-area-context
```
### Usage
You can directly use [`SafeAreaView`](https://appandflow.github.io/react-native-safe-area-context/api/safe-area-view) to wrap the content of your screen's component. It is a regular `<View>` with the safe area insets applied as extra padding or margin.
```tsx app/index.tsx
import { Text } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
export default function HomeScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <Text>Content is in safe area.</Text>
    </SafeAreaView>
  );
}
```
Note: Using a different Expo template and don't have Expo Router installed?
---
Import and add [`SafeAreaProvider`](https://appandflow.github.io/react-native-safe-area-context/api/safe-area-provider) to the root component file (such as **App.tsx**) before using `SafeAreaView` in your screen component.
```tsx App.tsx
import { SafeAreaProvider } from 'react-native-safe-area-context';
export default function App() {
  return (
    return <SafeAreaProvider>...</SafeAreaProvider>;
  );
}
```
---
## Alternate: `useSafeAreaInsets` hook
Alternate to `SafeAreaView`, you can use [`useSafeAreaInsets`](https://appandflow.github.io/react-native-safe-area-context/api/use-safe-area-insets) hook in your screen component. It provides direct access to the safe area insets, allowing you to apply padding for each edge of the `<View>` using an inset from this hook.
The example below uses the `useSafeAreaInsets` hook. It applies top padding to a `<View>` using `insets.top`.
```tsx app/index.tsx
import { Text, View } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
export default function HomeScreen() {
  const insets = useSafeAreaInsets();
  return (
    <View style={{ flex: 1, paddingTop: insets.top }}>
      <Text>Content is in safe area.</Text>
    </View>
  );
}
```
The hook provides the insets in the following object:
```ts
{
  top: number,
  right: number,
  bottom: number,
  left: number
}
```
## Additional information
### Minimal example
Below is a minimal working example that uses the `useSafeAreaInsets` hook to apply top padding to a view.
#### Using react-native-safe-area-context
```tsx collapseHeight=320
import { Text, View } from 'react-native';
import { SafeAreaProvider, useSafeAreaInsets } from 'react-native-safe-area-context';
function HomeScreen() {
  const insets = useSafeAreaInsets();
  return (
    <View style={{ flex: 1, paddingTop: insets.top }}>
      <Text style={{ fontSize: 28 }}>Content is in safe area.</Text>
    </View>
  );
}
export default function App() {
  return (
    <SafeAreaProvider>
      <HomeScreen />
    </SafeAreaProvider>
  );
}
```
### Usage with React Navigation
By default, React Navigation supports safe areas and uses `react-native-safe-area-context` as a peer dependency. For more information, see the [React Navigation documentation](https://reactnavigation.org/docs/handling-safe-area/).
### Usage with web
If you are targeting the web, set up `SafeAreaProvider` as described in the [usage section](#usage). If you are doing server-side rendering (SSR), see the [Web SSR section](https://appandflow.github.io/react-native-safe-area-context/optimizations#web-ssr) in the library's documentation.


## System bars

Learn how to handle and customize system bars for safe areas and edge-to-edge layout in your Expo project.

System bars are the UI elements at the edges of the screen that provide essential device information and navigation controls. Depending on the mobile OS, they include the status bar ([Android](https://developer.android.com/design/ui/mobile/guides/foundations/system-bars) and [iOS](https://developer.apple.com/design/human-interface-guidelines/status-bars)), caption bar ([Android](https://medium.com/androiddevelopers/insets-handling-tips-for-android-15s-edge-to-edge-enforcement-872774e8839b#:~:text=or%20SHORT_EDGES.-,Caption%20bars,-When%20your%20app) only), navigation bar ([Android](https://developer.android.com/design/ui/mobile/guides/foundations/system-bars#navigation-bar) and [iOS](https://developer.apple.com/design/human-interface-guidelines/navigation-bars)), and home indicator (iOS only).
These components are used to display device information such as battery level, time, notification alerts, and provide direct interaction with the device from anywhere in the device's interface. For example, an app user can pull down the status bar to access quick settings and notifications regardless of which app they're currently using.
System bars are fundamental to the mobile experience, and understanding how to work with them properly is important for creating your app.
## Handling overlaps using safe areas
Some of your app's content may draw behind the system bars. To handle this, you need to position your app's content correctly by avoiding the overlap and ensuring that the controls from the system bars are present.
The following guide walks you through how to use `SafeAreaView` or a hook to apply insets directly for each edge of the screen.
### Safe areas and edge-to-edge layout on Android
Before [edge-to-edge on Android](https://expo.dev/blog/edge-to-edge-display-now-streamlined-for-android), it was common to have a translucent status bar and navigation bar. With this approach, the content drawn behind these bars was already underneath them, and it was typically not necessary to factor in safe areas.
Now, [with edge-to-edge on Android](https://expo.dev/blog/edge-to-edge-display-now-streamlined-for-android), you will need to use safe areas to ensure that content does not overlap with system bars.
## Customizing system bars
System bars can be customized to match your app's design and provide better visibility in different scenarios. When using Expo, there are two libraries available for this: `expo-status-bar` and `expo-navigation-bar` (Android only).
### Status bar configuration
The status bar appears at the top of the screen on both Android and iOS. You can customize it using [`expo-status-bar`](/versions/latest/sdk/status-bar). It provides a `StatusBar` component that you can use to control the appearance of the status bar while your app is running using the [`style`](/versions/latest/sdk/status-bar/#style) property or the [`setStatusBarStyle`](/versions/latest/sdk/status-bar/#statusbarsetstatusbarstylestyle-animated) method:
```tsx app/_layout.tsx
import { StatusBar } from 'expo-status-bar';
export default function RootLayout() {
  <>
    {/* Use light text instead of dark text in the status bar to provide more contrast with a dark background. */}
    <StatusBar style="light" />
  </>;
}
```
> **Note:** In Expo default template, the `style` property is set to `auto`. It automatically picks the appropriate style depending on the color scheme (light or dark mode) currently used by your app.
To control the `StatusBar` visibility, you can set the [`hidden`](/versions/latest/sdk/status-bar/#hidden) property to `true` or use the [`setStatusBarHidden`](/versions/latest/sdk/status-bar/#statusbarsetstatusbarhiddenhidden-animation) method.
**With edge-to-edge enabled on Android, features from `expo-status-bar` that depend on an opaque status bar [are unavailable](https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge)**. It's only possible to customize the style and visibility. Other properties will no-op and warn.
### Navigation bar configuration (Android only)
On Android devices, the Navigation Bar appears at the bottom of the screen. You can customize it using the [`expo-navigation-bar`](/versions/latest/sdk/navigation-bar) library. It provides a `NavigationBar` component that you can use to set the style of the navigation bar using the [`setStyle`](/versions/latest/sdk/navigation-bar/#navigationbarsetstylestyle) method:
```tsx app/_layout.tsx
import { Platform } from 'react-native';
import * as NavigationBar from 'expo-navigation-bar';
import { useEffect } from 'react';
useEffect(() => {
  if (Platform.OS === 'android') {
    // Set the navigation bar style
    NavigationBar.setStyle('dark');
  }
}, []);
```
To control the `NavigationBar` visibility, you can use the [`setVisibilityAsync`](/versions/latest/sdk/navigation-bar/#navigationbarsetvisibilityasyncvisibility) method.
**With edge-to-edge enabled on Android, features from `expo-navigation-bar` that depend on an opaque navigation bar [are unavailable](https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge)**. It's only possible to customize the style and visibility. Other properties will no-op and warn.


## Fonts

Learn how to integrate custom fonts in your app using local files or Google Font packages

Android and iOS come with their own set of platform fonts. To provide a consistent user experience and enhance your app's branding, you can use custom fonts.
This guide covers different ways you can add and load a custom font into your project and also provides additional information related to fonts.
## Add a custom font
There are two ways you can add a custom font into your project:
- Add a font file into your local assets. For example, a font file in the **assets/fonts** directory.
- Install a Google Font package. For example, installing [`@expo-google-fonts/inter`](https://www.npmjs.com/package/@expo-google-fonts/inter) package.
### Supported font formats
Expo SDK officially supports OTF and TTF font formats across Android, iOS and web platforms. If your font is in another font format, you have to set up advanced configuration to support that format in your project.
### Variable fonts
Variable fonts, including variable font implementations in OTF and TTF, do not have support across all platforms. For full platform support, use static fonts. Alternatively, use a utility such as [fontTools](https://fonttools.readthedocs.io/en/latest/varLib/mutator.html) to extract the specific axis configuration you want to use from the variable font and save it as a separate font file.
### How to choose between OTF and TTF
If the font you're using has both OTF and TTF versions, prefer OTF. The **.otf** files are smaller than **.ttf** files. Sometimes, OTF also renders slightly better in certain contexts.
## Use a local font file
Copy the file into your project's **assets/fonts** directory.
> **info** **assets/fonts** directory path is a common convention in React Native apps to put font files. You can place these files elsewhere if you follow a custom convention.
Two ways to use the local font file in your project:
- Embed the font file with [`expo-font` config plugin](/versions/latest/sdk/font/#configuration-in-app-config) (Android and iOS only).
- Load the font file with [`useFonts`](/versions/latest/sdk/font/#usefontsmap) hook at runtime (Android, iOS, and web).
### With `expo-font` config plugin
The `expo-font` config plugin allows embedding one or more font files in your project's native code. It supports `ttf` and `otf` for both Android and iOS, and `woff` and `woff2` are supported on iOS only.
> **Note:** Config plugins only run on native platforms (Android and iOS). For web, use the [`useFonts` hook](#with-usefonts-hook) instead.
This is the recommended method for adding fonts to your app due to its benefits:
- Fonts are available immediately when the app starts on a device.
- No additional code required to load fonts in a project asynchronously when the app starts.
- Fonts are consistently available across all devices where the app is installed because they're bundled within the app.
However, this method also has some limitations:
- Doesn't work with Expo Go since this method requires [creating a development build](/develop/development-builds/create-a-build/).
To embed a font in a project, follow the steps below:
Step 1: 
After adding a custom font file in your project, install the `expo-font` library.
```sh
$ npx expo install expo-font
```
Step 2: 
Add the config plugin to your [app config](/versions/latest/config/app/#plugins) file. The configuration must contain the path to the font file using [`fonts`, `android` or `ios`](/versions/latest/sdk/font/#configurable-properties) properties which take an array of one or more font definitions. The path to each font file is relative to the project's root.
The example below showcases all valid ways a font can be specified: as an array of objects that specify `fontFamily` and other properties, or an array of paths to font files.
For Android, you can specify the `fontFamily`, `weight`, and optionally `style` (defaults to `"normal"`), which will embed the fonts as native [XML resources](https://developer.android.com/develop/ui/views/text-and-emoji/fonts-in-xml). If you provide only the font file paths in an array, the file name becomes the font family name on Android. iOS always extracts the font family name from the font file itself.
If you plan to refer to fonts using just the `fontFamily`, provide an array of font paths (see `FiraSans-MediumItalic.ttf` below) and follow our [recommendation for file naming](#how-to-determine-which-font-family-name-to-use).
If you want to refer to fonts using a combination of `fontFamily`, `weight`, and `style`, provide an array of objects (see `Inter` below).
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-font",
        {
          "fonts": [
            "./assets/fonts/FiraSans-MediumItalic.ttf"
          ],
          "android": {
            "fonts": [
              {
                "fontFamily": "Inter",
                "fontDefinitions": [
                  {
                    "path": "./assets/fonts/Inter-BoldItalic.ttf",
                    "weight": 700,
                    "style": "italic"
                  },
                  {
                    "path": "./assets/fonts/Inter-Bold.ttf",
                    "weight": 700
                  }
                ]
              }
            ]
          },
          "ios": {
            "fonts": ["./assets/fonts/Inter-Bold.ttf", "./assets/fonts/Inter-BoldItalic.ttf"]
          }
        }
      ]
    ]
  }
}
```
Step 3: 
After embedding the font with the config plugin, create a [new development build](/develop/development-builds/create-a-build/) and install it on your device or Android Emulator or iOS Simulator.
You can use the font with `<Text>` by specifying the `fontFamily` style prop. The examples below correspond to the fonts defined in the configuration above.
```tsx
<Text style={{ fontFamily: 'Inter', fontWeight: '700' }}>Inter Bold</Text>
<Text style={{ fontFamily: 'Inter', fontWeight: '700', fontStyle: 'italic' }}>Inter Bold Italic</Text>
<Text style={{ fontFamily: 'FiraSans-MediumItalic' }}>Fira Sans Medium Italic</Text>
```
<ConfigReactNative title="Using this method in an existing React Native project?">
- **Android:** Copy font files to **android/app/src/main/assets/fonts**.
- **iOS:** See [Adding a Custom Font to Your App](https://developer.apple.com/documentation/uikit/text_display_and_fonts/adding_a_custom_font_to_your_app) in the Apple Developer documentation.
</ConfigReactNative>
#### How to determine which font family name to use
- If you provide fonts as an array of file paths (as described above), on Android, the file name (without the extension) becomes the font family name. On iOS, the font family name is read from the font file itself. We recommend naming the font file same as its [PostScript name](#what-is-postscript-name-of-a-font) so the font family name is consistent on both platforms.
- If you use the object syntax, provide the "Family Name". This can be found in the Font Book app on macOS, [fontdrop.info](https://fontdrop.info/) or other programs.
Note: What is PostScript name of a font file?
---
The **PostScript name** of a font file is a unique identifier assigned to the font that follows Adobe's PostScript standard. It is used by operating systems and apps to refer to the font. It is not a font's **display name**.
For example, Inter Black font file's PostScript name is `Inter-Black`.
_Screenshot from Font Book app on macOS._
---
### With `useFonts` hook
The `useFonts` hook from `expo-font` library allows loading the font file asynchronously. This hook keeps track of the loading state and loads the font when an app is initialized.
It works with all Expo SDK versions and with Expo Go. To load a font in a project using `useFonts` hook, follow the steps below:
Step 1: 
After adding a custom font file in your project, install the `expo-font` and `expo-splash-screen` libraries.
```sh
$ npx expo install expo-font expo-splash-screen
```
The [`expo-splash-screen`](/versions/latest/sdk/splash-screen/) library provides `SplashScreen` component that you can use to prevent rendering the app until the font is loaded and ready.
Step 2: 
Map the font file using the `useFonts` hook in a top level component such as the root layout (**app/layout.tsx**) file in your project:
```tsx app/_layout.tsx
import {useEffect} from 'react';
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
  const [loaded, error] = useFonts({
    'Inter-Black': require('./assets/fonts/Inter-Black.otf'),
  });
  useEffect(() => {
    if (loaded || error) {
      SplashScreen.hideAsync();
    }
  }, [loaded, error]);
  if (!loaded && !error) {
    return null;
  }
  return (
  )
}
```
Step 3: 
Use the font on the `<Text>` by using `fontFamily` style prop in a React component:
```tsx
<Text style={{ fontFamily: 'Inter-Black' }}>Inter Black</Text>
```
## Use Google Fonts
Expo has first-class support for all fonts listed in [Google Fonts](https://fonts.google.com/). They are available using [`@expo-google-fonts`](https://github.com/expo/google-fonts) library. With any of the font package from this library, you can quickly integrate that font and its variants.
Two ways to use a Google Font in your project:
- Embed the installed font with [`expo-font` config plugin](/versions/latest/sdk/font/#configuration-in-appjsonappconfigjs).
- Load the installed font with [`useFonts`](/versions/latest/sdk/font/#usefontsmap) hook at runtime asynchronously.
### With `expo-font` config plugin
> **Note:** Embedding a Google Font using `expo-font` config plugin has same benefits and limitations as embedding a custom font on your own. See [using a local font file with `expo-font` config plugin](#with-expo-font-config-plugin) for more information.
Step 1: 
Install the font package. For example, to use Inter Black font, install the [`@expo-google-fonts/inter`](https://www.npmjs.com/package/@expo-google-fonts/inter) package with the command below.
```sh
$ npx expo install expo-font @expo-google-fonts/inter
```
Step 2: 
Add the config plugin to your [app config](/versions/latest/config/app/#plugins) file. The configuration must contain the path to the font file using [`fonts`](/versions/latest/sdk/font/#configurable-properties) property which takes an array of one or more font files. The path to the font file is defined from the font package inside the `node_modules` directory. For example, if you have a font package named `@expo-google-fonts/inter`, then the name of the file is **Inter_900Black.ttf**.
```json app.json
{
  "plugins": [
    [
      "expo-font",
      {
        "fonts": ["node_modules/@expo-google-fonts/inter/900Black/Inter_900Black.ttf"]
      }
    ]
  ]
}
```
Step 3: 
After embedding the font with the config plugin, create a [new development build](/develop/development-builds/create-a-build/) and install it on your device or Android Emulator or iOS Simulator.
On Android, you can use the font file name. For example, `Inter_900Black`. On iOS, use the font and its weight name ([PostScript name](#what-is-postscript-name-of-a-font)). The example below demonstrates how to use [`Platform`](https://reactnative.dev/docs/platform-specific-code#platform-module) to select the correct font family name for each platform:
```tsx
import { Platform } from 'react-native';
// Inside a React component:
<Text
  style={{
    fontFamily: Platform.select({
      android: 'Inter_900Black',
      ios: 'Inter-Black',
    }),
  }}>
  Inter Black
</Text>
```
### With `useFonts` hook
> **Note:** Loading a Google Font using `useFonts` hook has same benefits and limitations as embedding a custom font on your own. See [using a local font file with `useFonts` hook](#with-usefonts-hook) for more information.
Each google Fonts package provides the `useFonts` hook to load the fonts asynchronously. This hook keeps track of the loading state and loads the font when an app is initialized. The font package also imports the font file so you don't have to explicitly import it.
Step 1: 
Install the Google Fonts package, `expo-font` and `expo-splash-screen` libraries.
```sh
$ npx expo install @expo-google-fonts/inter expo-font expo-splash-screen
```
The [`expo-splash-screen`](/versions/latest/sdk/splash-screen/) library provides `SplashScreen` component that you can use to prevent rendering the app until the font is loaded and ready.
Step 2: 
After installing the font package, map the font using the `useFonts` hook in a top level component such as the root layout (**app/layout.tsx**) file in your project:
```tsx app/_layout.tsx
// Rest of the import statements
import { Inter_900Black, useFonts } from '@expo-google-fonts/inter';
import * as SplashScreen from 'expo-splash-screen';
import {useEffect} from 'react';
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
  const [loaded, error] = useFonts({
    Inter_900Black,
  });
  useEffect(() => {
    if (loaded || error) {
      SplashScreen.hideAsync();
    }
  }, [loaded, error]);
  if (!loaded && !error) {
    return null;
  }
  return (
  )
}
```
Step 3: 
Use the font on the `<Text>` by using `fontFamily` style prop in a React component:
```tsx
<Text style={{ fontFamily: 'Inter_900Black' }}>Inter Black</Text>
```
## Additional information
### Minimal example
### Beyond OTF and TTF
If your font is in format other than OTF or TTF, you have to [customize the Metro bundler configuration to include it as an extra asset](/guides/customizing-metro#adding-more-file-extensions-to-assetexts) for it to work. In some cases, rendering a font format that a platform doesn't support may cause your app to crash.
For reference, the following table provides the list formats that work on each native platform:
| Format | Android     | iOS         | Web         |
| ------ | ----------- | ----------- | ----------- |
| bdf    | <NoIcon />  | <NoIcon />  | <NoIcon />  |
| dfont  | <YesIcon /> | <NoIcon />  | <NoIcon />  |
| eot    | <NoIcon />  | <NoIcon />  | <YesIcon /> |
| fon    | <NoIcon />  | <NoIcon />  | <NoIcon />  |
| otf    | <YesIcon /> | <YesIcon /> | <YesIcon /> |
| ps     | <NoIcon />  | <NoIcon />  | <NoIcon />  |
| svg    | <NoIcon />  | <NoIcon />  | <YesIcon /> |
| ttc    | <NoIcon />  | <NoIcon />  | <NoIcon />  |
| ttf    | <YesIcon /> | <YesIcon /> | <YesIcon /> |
| woff   | <NoIcon />  | <YesIcon /> | <YesIcon /> |
| woff2  | <NoIcon />  | <YesIcon /> | <YesIcon /> |
### Platform built-in fonts
If you don't want to use a custom font by specifying a `fontFamily`, platform's default font will be used. Each platform has a set of built in fonts. On Android, the default font is Roboto. On iOS, it's SF Pro.
A platform's default font is usually easy-to-read. However, don't be surprised when the system default font is changed to use another font that is not easy to read. In this case, use your custom font so you have precise control over what the user will see.
### Handle `@expo/vector-icons` initial load
When the icons from `@expo/vector-icons` library load for the first time, they appear as invisible icons in your app. Once they load, they're cached for all the app's subsequent usage. To avoid showing invisible icons on your app's first load, preload during the initial loading screen with [`useFonts`](/versions/latest/sdk/font/#usefontsmap). For example:
```tsx app/_layout.tsx
import { useFonts } from 'expo-font';
import Ionicons from '@expo/vector-icons/Ionicons';
export default function RootLayout() {
  useFonts([require('./assets/fonts/Inter-Black.otf', Ionicons.font)]);
  return (
  )
}
```
Now, you can use any icon from the `Ionicons` library in a React component:
```tsx
<Ionicons name="checkmark-circle" size={32} color="green" />
```
### Loading a remote font directly from the web
> **warning** **If you're loading remote fonts, make sure they are being served from an origin with CORS properly configured**. If you don't do this, your remote font might not load properly on the web platform.
Loading fonts from a local asset is the safest way to load a font in your app. When including fonts as local assets, after you submit your app to the app stores, these fonts are bundled with the app download and will be available immediately. You don't have to worry about CORS or other potential issues.
However, loading a font file directly from web is done by replacing the `require('./assets/fonts/FontName.otf')` with the URL of your font as shown in the example below.
#### Using a remote font
```tsx
import { useFonts } from 'expo-font';
import { Text, View, StyleSheet } from 'react-native';
export default function App() {
  const [loaded, error] = useFonts({
    'Inter-SemiBoldItalic': 'https://rsms.me/inter/font-files/Inter-SemiBoldItalic.otf?v=3.12',
  });
  if (!loaded || !error) {
    return null;
  }
  return (
    <View style={styles.container}>
      <Text style={{ fontFamily: 'Inter-SemiBoldItalic', fontSize: 30 }}>Inter SemiBoldItalic</Text>
      <Text style={{ fontSize: 30 }}>Platform Default</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```


## Assets

Learn about using static assets in your project, including images, videos, sounds, database files, and fonts.

A **static asset** is a file that is bundled with your app's binary (native binary). This file type is not part of your app's JavaScript bundle which contain your app's code. Common types of static assets include images, videos, sounds, database files for SQLite, and fonts. These assets can be served locally from your project or remotely over the network.
This guide covers different ways you can load and use static assets in your project and also provides additional information on how to optimize and minify assets.
## Serve an asset locally
When an asset is stored in your project's file system, it can be embedded in your app binary at build time or loaded at runtime. You can import it like a JavaScript module using `require` or `import` statements.
For example, to render an image called **example.png** in **App.js**, you can use `require` to import the image from the project's **assets/images** directory and pass it to the `<Image>` component:
```tsx app/index.tsx
<Image source={require('./assets/images/example.png')} />
```
In the above example, the bundler reads the imported image's metadata and automatically provides the width and height. For more information, see [Static Image Resources](https://reactnative.dev/docs/images#static-image-resources).
Libraries such as `expo-image` and `expo-file-system` work similarly to the `<Image>` component with local assets.
### How are assets served locally
Locally stored assets are served over HTTP in development. They are automatically bundled into your app binary at the build time for production apps and served from disk on a device.
### Load an asset at build time with `expo-asset` config plugin
To load an asset at build time, you can use the [config plugin](/versions/latest/sdk/asset/#example-appjson-with-config-plugin) from the `expo-asset` library. This plugin will embed the asset file in your native project.
Step 1: 
Install the `expo-asset` library.
```sh
$ npx expo install expo-asset
```
Step 2: 
Add the config plugin to your project's [app config](/versions/latest/config/app/#plugins) file. The configuration must contain the path to the asset file using [`assets`](/versions/latest/sdk/asset/#configurable-properties) property which takes an array of one or more files or directories to link to the native project.
The path to each asset file must be relative to your project's root since the app config file is located in the project's root directory.
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-asset",
        {
          "assets": ["./assets/images/example.png"]
        }
      ]
    ]
  }
}
```
Step 3: 
After embedding the asset with the config plugin, [create a new development build](/develop/development-builds/create-a-build/). Now, you can import and use the asset in your project without using a `require` or an `import` statement.
For example, the **example.png** is linked by the above config plugin. You can directly import it into your component and use its resource name as the URI. Note that when rendering assets without using `require`, you need to explicitly provide a width / height.
```tsx app/index.tsx
import { Image } from 'expo-image';
export default function HomeScreen() {
  return <Image source={{ uri: 'example' }} style={{ width: 100, height: 100 }} />;
}
```
> **info** Different file formats are supported with the `expo-asset` config plugin. For more information on these formats, see [Assets API reference](/versions/latest/sdk/asset/#configurable-properties). If you don't see a file format supported by the config plugin, you can use the [`useAssets`](#load-an-asset-at-runtime-with-useassets-hook) hook to load the asset at runtime.
### Load an asset at runtime with `useAssets` hook
The `useAssets` hook from `expo-asset` library allows loading assets asynchronously. This hook downloads and stores an asset locally and after the asset is loaded, it returns a list of that asset's instances.
Step 1: 
Install the `expo-asset` library.
```sh
$ npx expo install expo-asset
```
Step 2: 
Import the [`useAssets`](/versions/latest/sdk/asset/#useassetsmoduleids) hook from the `expo-asset` library in your screen component:
```tsx app/index.tsx
import { useAssets } from 'expo-asset';
export default function HomeScreen() {
  const [assets, error] = useAssets([
    require('path/to/example-1.jpg'),
    require('path/to/example-2.png'),
  ]);
  return assets ? <Image source={assets[0]} /> : null;
}
```
## Serve an asset remotely
When an asset is served remotely, it is not bundled into the app binary at build time. You can use the URL of the asset resource in your project if it is hosted remotely. For example, pass the URL to the `<Image>` component to render a remote image:
```jsx App.js
import { Image } from 'expo-image';
function App() {
  return (
    <Image source={{ uri: 'https://example.com/logo.png' }} style={{ width: 50, height: 50 }} />
  );
}
```
There is no guarantee about the availability of images served remotely using a web URL because an internet connection may not be available, or the asset might be removed.
Additionally, loading assets remotely also requires you to provide an asset's metadata. In the above example, since the bundler cannot retrieve the image's width and height, those values are passed explicitly to the `<Image>` component. If you don't, the image will default to 0px by 0px.
## Additional information
### Manual optimization methods
#### Images
You can compress images using the following:
- [`guetzli`](https://github.com/google/guetzli)
- [`pngcrush`](https://pmt.sourceforge.io/pngcrush/)
- [`optipng`](http://optipng.sourceforge.net/)
Some image optimizers are lossless. They re-encode your image to be smaller without any change or loss in the pixels displayed. When you need each pixel to be untouched from the original image, a lossless optimizer and a lossless image format like PNG are a good choice.
Other image optimizers are lossy. The optimized image differs from the original image. Often, lossy optimizers are more efficient because they discard visual information that reduces file size while making the image look nearly identical to humans. Tools like `imagemagick` can use comparison algorithms like [SSIM](https://en.wikipedia.org/wiki/Structural_similarity) to show how similar two images look. It's quite common for an optimized image that is over 95% similar to the original image to be far less than 95% of the original file size.
#### Other assets
For assets like GIFs or videos, or non-code and non-image assets, it's up to you to optimize and minify those assets.
> **Note**: GIFs are a very inefficient format. Modern video codecs can produce significantly smaller file sizes with better quality.
### Fonts
See [Add a custom font](/develop/user-interface/fonts/#add-a-custom-font) for more information on how to add a custom font to your app.


## Color themes

Learn how to support light and dark modes in your app.

It's common for apps to support light and dark color schemes. Here is an example of how supporting both modes looks in an Expo project:
## Configuration
> **info** For Android and iOS projects, additional configuration is required to support switching between light and dark mode. For web, no additional configuration is required.
To configure supported appearance styles, you can use the [`userInterfaceStyle`](/versions/latest/config/app/#userinterfacestyle) property in your project's [app config](/versions/latest/config/app). By default, this property is set to `automatic` when you create a new project with the [default template](/get-started/create-a-project/).
Here is an example configuration:
```json app.json
{
  "expo": {
    "userInterfaceStyle": "automatic"
  }
}
```
You can also configure `userInterfaceStyle` property for a specific platforms by setting either [`android.userInterfaceStyle`](/versions/latest/config/app/#userinterfacestyle-2) or [`ios.userInterfaceStyle`](/versions/latest/config/app/#userinterfacestyle-1) to the preferred value.
> **info** The app will default to the `light` style if this property is absent.
When you are creating a development build, you have to install [`expo-system-ui`](/versions/latest/sdk/system-ui/#installation) to support the appearance styles for Android. Otherwise, the `userInterfaceStyle` property is ignored.
```sh
$ npx expo install expo-system-ui
```
If the project is misconfigured and doesn't have `expo-system-ui` installed, the following warning will be shown in the terminal:
```sh
» android: userInterfaceStyle: Install expo-system-ui in your project to enable this feature.
```
You can also use the following command to check if the project is misconfigured:
```sh
$ npx expo config --type introspect
```
Note: Using bare React Native app?
---
#### Android
Ensure that the `uiMode` flag is present on your `MainActivity` (and any other activities where this behavior is desired) in **AndroidManifest.xml**:
```xml
<activity android:configChanges="keyboard|keyboardHidden|orientation|screenSize|uiMode">
```
Implement the `onConfigurationChanged` method in **MainActivity.java**:
```java
import android.content.Intent;
import android.content.res.Configuration;
public class MainActivity extends ReactActivity {
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    Intent intent = new Intent("onConfigurationChanged");
    intent.putExtra("newConfig", newConfig);
    sendBroadcast(intent);
  }
}
```
#### iOS
You can configure supported styles with the [`UIUserInterfaceStyle`](https://developer.apple.com/documentation/bundleresources/information_property_list/uiuserinterfacestyle) key in your app **Info.plist**. Use `Automatic` to support both light and dark modes.
---
### Supported appearance styles
The `userInterfaceStyle` property supports the following values:
- `automatic`: Follow system appearance settings and notify about any change the user makes.
- `light`: Restrict the app to support light theme only.
- `dark`: Restrict the app to support dark theme only.
## Detect the color scheme
To detect the color scheme in your project, use `Appearance` or `useColorScheme` from `react-native`:
```tsx app/index.tsx
import { Appearance, useColorScheme } from 'react-native';
```
Then, you can use `useColorScheme()` hook as shown below:
```tsx app/index.tsx
function MyComponent() {
  let colorScheme = useColorScheme();
  if (colorScheme === 'dark') {
    // render some dark thing
  } else {
    // render some light thing
  }
}
```
In some cases, you will find it helpful to get the current color scheme imperatively with [`Appearance.getColorScheme()` or listen to changes with `Appearance.addChangeListener()`](https://reactnative.dev/docs/appearance).
## Additional information
### Minimal example
#### useColorScheme example
```tsx
import { StatusBar } from 'expo-status-bar';
export default function App() {
  const colorScheme = useColorScheme();
  const themeTextStyle = colorScheme === 'light' ? styles.lightThemeText : styles.darkThemeText;
  const themeContainerStyle =
    colorScheme === 'light' ? styles.lightContainer : styles.darkContainer;
  return (
    <View style={[styles.container, themeContainerStyle]}>
      <Text style={[styles.text, themeTextStyle]}>Color scheme: {colorScheme}</Text>
      <StatusBar />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    fontSize: 20,
  },
  lightContainer: {
    backgroundColor: '#d0d0c0',
  },
  darkContainer: {
    backgroundColor: '#242c40',
  },
  lightThemeText: {
    color: '#242c40',
  },
  darkThemeText: {
    color: '#d0d0c0',
  },
});
```
### Tips
While you are developing your project, you can change your simulator's or device's appearance by using the following shortcuts:
- If using an Android Emulator, you can run `adb shell "cmd uimode night yes"` to enable dark mode, and `adb shell "cmd uimode night no"` to disable dark mode.
- If using a physical Android device or an Android Emulator, you can toggle the system dark mode setting in the device's settings.
- If working with an iOS emulator locally, you can use the <kbd>Cmd ⌘</kbd> + <kbd>Shift</kbd> + <kbd>a</kbd> shortcut to toggle between light and dark modes.


## Animation

Learn how to integrate React Native animations and use it in your Expo project.

Animations are a great way to enhance and provide a better user experience. In your Expo projects, you can use the [Animated API](https://reactnative.dev/docs/next/animations) from React Native. However, if you want to use more advanced animations with better performance, you can use the [`react-native-reanimated`](https://docs.swmansion.com/react-native-reanimated/) library. It provides an API that simplifies the process of creating smooth, powerful, and maintainable animations.
## Installation
You can skip installing `react-native-reanimated` if you have created a project using [the default template](/get-started/create-a-project/). This library is already installed. Otherwise, install it by running the following command:
```sh
$ npx expo install react-native-reanimated
```
## Usage
### Minimal example
The following example shows how to use the `react-native-reanimated` library to create a simple animation. For more information on the API and advanced usage, see [`react-native-reanimated` documentation](https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/your-first-animation).
#### Using react-native-reanimated
```tsx
import Animated, {
  useSharedValue,
  withTiming,
  useAnimatedStyle,
  Easing,
} from 'react-native-reanimated';
import { View, Button, StyleSheet } from 'react-native';
export default function AnimatedStyleUpdateExample() {
  const randomWidth = useSharedValue(10);
  const config = {
    duration: 500,
    easing: Easing.bezier(0.5, 0.01, 0, 1),
  };
  const style = useAnimatedStyle(() => {
    return {
      width: withTiming(randomWidth.value, config),
    };
  });
  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, style]} />
      <Button
        title="toggle"
        onPress={() => {
          randomWidth.value = Math.random() * 350;
        }}
      />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  box: {
    width: 100,
    height: 80,
    backgroundColor: 'black',
    margin: 30,
  },
});
```
## Other animation libraries
You can use other animation packages such as [Moti](https://moti.fyi/) in your Expo project. It works on Android, iOS, and web.


## Store data

Learn about different libraries available to store data in your Expo project.

Storing data can be essential to the features implemented in your mobile app. There are different ways to save data in your Expo project depending on the type of data you want to store and the security requirements of your app. This page lists a variety of libraries to help you decide which solution is best for your project.
## Expo SecureStore
`expo-secure-store` provides a way to encrypt and securely store key-value pairs locally on the device.
## Expo FileSystem
`expo-file-system` provides access to a file system stored locally on the device. Within Expo Go, each project has a separate file system and no access to other Expo projects' files. However, it can save content shared by other projects to the local filesystem and share local files with other projects. It is also capable of uploading and downloading files from network URLs.
## Expo SQLite
`expo-sqlite` package gives your app access to a database that can be queried through a WebSQL-like API. The database is persisted across restarts of your app. You can use it for importing an existing database, opening databases, creating tables, inserting items, querying and displaying results, and using prepared statements.
## Async Storage
[Async Storage](https://react-native-async-storage.github.io/async-storage/) is an asynchronous, unencrypted, persistent key-value storage for React Native apps. It has a simple API and is a good choice for storing small amounts of data. It is also a good choice for storing data that does not need encryption, such as user preferences or app state.
## Other libraries
There are other libraries available for storing data for different purposes. For example, you might not need encryption in your project or are looking for a faster solution similar to Async Storage.
We recommend checking out [React Native for a list of libraries](https://reactnative.directory/?search=storage) to help you store your project's data.


## Next steps

A list of useful resources to learn more about implementing navigation and UI in your app.

# Development builds

## Introduction to development builds

Why use development builds and how to get started.

**Development build** is the term that we use for a "Debug" build of an app that includes the [`expo-dev-client`](/versions/latest/sdk/dev-client/) library. This library augments the built-in React Native development tooling with additional capabilities, such as support for inspecting network requests and a "launcher" UI that lets you switch between different development servers (such as between a server running on your machine or a teammate's machine) and deployments of your app (such as published updates with EAS Update).
Note: Difference between Expo Go and development builds
---
When you create your first React Native project with `npx create-expo-app` and ran it with `npx expo start`, you most likely start off using the [Expo Go](https://expo.dev/go) app for development. Expo Go is a native app that the Expo team built and submitted to the [Google Play Store](https://play.google.com/store/apps/details?id=host.exp.exponent) and [Apple App Store](https://apps.apple.com/us/app/expo-go/id982107779) so you can get coding quickly. It is a sandbox app with a number of native libraries included within (see the [dependencies list](https://github.com/expo/expo/blob/main/apps/expo-go/package.json#L23)). This means that developers may update their app's JavaScript code on their local machine and see the changes on Expo Go.
A React Native app consists of two parts: the **native app (Expo Go)** and the **JavaScript bundle (`npx expo start`)**. It is immutable and when you're using the Expo Go app for development, you can only rely on the native code and tools that exist in Expo Go. The only way to get around it is to build your native app yourself instead of using Expo's pre-packaged sandbox. This is exactly what a **Development Build is, your own version of Expo Go**, where you are free to use any native libraries and change any native config.
---
Note: Native app and JavaScript bundle
---
The **native app (Expo Go)** is immutable once installed. Native build tools are required to create this bundle, and it needs to be signed to be installable on real devices. To add a new library with native code or change metadata that is shipped with the app (for example app name, icon, splash screen) the app needs to be rebuilt and re-installed on the device.
The **JavaScript bundle (`npx expo start`)** is where your app's UI code and business logic are. In production apps, there is one **main.js** bundle that is shipped with the app itself. In development, this JS bundle is live reloaded from your local machine. The main role of React Native is to provide a way for the JavaScript code to access the native APIs (Image, Camera, Notifications, and more). However, only APIs and libraries that were bundled in the **native app** can be used.
---
Video Tutorial: [Expo Go & Development Builds: which should you use?](https://www.youtube.com/watch?v=FdjczjkwQKE)
## Why use a development build (a.k.a what _can't_ you do in Expo Go and why)
Expo Go is the perfect tool for learning, prototyping, and experimenting, but most production apps will convert to using development builds sooner rather than later. It helps to know exactly what is _impossible_ in Expo Go and _why_, so you can make an informed decision on when and why to make this move.
Note: Use libraries with native code that aren't in Expo Go
---
Consider [`react-native-webview`](/versions/latest/sdk/webview/) as an example, a library that contains native code, but [is included in Expo Go](https://github.com/expo/expo/blob/main/apps/expo-go/package.json#L23). When you run `npx expo install react-native-webview` command in your project, it will install the library in your **node_modules** directory, which includes both the JS code and the native code. But the JS bundle you are building _only_ uses the JS code. Then, your JS bundle gets uploaded to Expo Go, and it interacts with the native code that was already bundled with the app.
Instead, when you try to use a library that is not included, for example, [`react-native-firebase`](/guides/using-firebase/#using-react-native-firebase), then you can use the JS code and hot reload the new bundle into Expo Go but it will immediately error because the JS code tries to call the native code from the React Native Firebase package that does not exist in Expo Go. There is no way to get the native code into the Expo Go app unless it was already included in the bundle that was uploaded to the app stores.
---
Note: Test changes in app icon, name, splash screen
---
If you're developing your app in Expo Go only, you can build a store version that will use your provided values and images; it just won't be possible to test it in Expo Go.
These native assets are shipped with the native bundle and are immutable once the app is installed. The Expo Go app does show a splash screen, which is your app icon on a solid color background. This is a dev-only emulation to view how the splash screen will probably look. However, it is limited, for example, you cannot test `SplashScreen.setOptions` to animate the splash screen.
---
Note: Remote push notifications
---
While [in-app notifications](/versions/latest/sdk/notifications/) are available in Expo Go, remote push notifications (that is, sending a push notification from a server to the app) are not. This is because a push notification service should be tied to your own push notification certificates, and while it is possible to make it work in Expo Go, it often causes confusion for production builds. It is recommended to test remote push notifications in development builds so you can ensure parity in behavior between development and production.
---
Note: Implementing App/Universal links
---
Both [Android App Links](/linking/android-app-links/) and [iOS Universal Links](/linking/ios-universal-links/) require a two-way association between the native app and the website. In particular, it requires the native app to include the linked website's URL. This is impossible with Expo Go due to the aforementioned native code immutability.
---
Note: Open projects using older SDKs (iOS device only)
---
Expo Go can only support one SDK version at a time. When a new SDK version is released, Expo Go is updated to support the newer version, and this will be the only version of Expo Go available to install from the stores.
If you're developing on an Android Device, Android Emulator, or iOS Simulator, a compatible version of Expo Go can be [downloaded and installed](https://expo.dev/go). The only platform where this is impossible is iPhone devices because Apple does not support side-loading older versions of apps.
---


## Switch from Expo Go to a development build

How to switch from your Expo Go project to use development builds.

To switch from Expo Go to a development build, you'll need to follow the steps below:
Step 1: 
## Install the `expo-dev-client`
The Expo Dev Client library includes the launcher UI (shown in the screenshots below), dev menu, extensions to test over-the-air updates, and more. The Expo Go app has the dev menu built in, and that's why you need to install it separately for a development build.
```sh
$ npx expo install expo-dev-client
```
> We recommend using the `expo-dev-client` for the best development experience, but it is possible to use development builds without installing this library. If not using the dev client, in [Step 3](/develop/development-builds/expo-go-to-dev-build/#start-the-dev-client), start the bundler with `--dev-client`. Otherwise, it will default to opening in Expo Go.
Step 2: 
## Build your native app
With Expo Go, you only needed to build the JavaScript bundle, but with development builds you also need to compile the native app. With Expo, there are two parts to building your native app:
1. Generate the native **android** and/or **ios** directories ([read more](/develop/development-builds/expo-go-to-dev-build/#cng-and-prebuild) on when and how you'll need to do this)
2. Use native build tools to compile the native app(s)
Once you've built your native app, you won't need to build it again unless you add or update a library with native code, or change any native code or configuration, such as the app name.
> The **android** and **ios** directories are automatically added to **.gitignore** when you create a new project, so they won't be checked into Git. This ensures you can always regenerate the code locally or on CI with [CNG](/workflow/continuous-native-generation/) when needed and never have to edit native code manually.
### Option 1: Build on your local machine
To build a native app on your local machine, follow the setup your environment guides for [Android](/workflow/android-studio-emulator/) and [iOS](/workflow/ios-simulator/) platforms. This involves setting up and configuring native build tools like Android Studio for Android and Xcode for iOS.
Once you have everything set up, run the following command:
For Build for Android: 
```sh
$ npx expo run:android
```
For Build for iOS: 
```sh
$ npx expo run:ios
```
By default, this will build and install the app on an Android Emulator/iOS Simulator. If you need to run the build on your phone, plug it into your computer (on Android, select trust device and allow USB debugging if prompted, and on iOS, enable [developer mode](/get-started/set-up-your-environment/?mode=development-build&buildEnv=local&platform=ios&device=physical#plug-in-your-device-via-usb-and-enable-developer-mode)) and run the above commands with the `--device` flag.
### Option 2: Build on EAS
Building on EAS servers is useful when:
- You can't or don't want to set up your local development environment
- You want to build an iOS app but don't own a Mac
- You want to share the development builds with your team
Step 3: 
## Start the bundler
After building locally, `npx expo run:android|ios` will start the bundler automatically. But if you closed the bundler or are working on a dev client you built earlier, (re)start the Metro bundler with:
```sh
$ npx expo start
```
When your project has `expo-dev-client` installed, the bundler will print out **Using development build**, and the QR code it shows will link into the development build you created instead of Expo Go.
## Prebuild
[**Prebuild** ](/workflow/continuous-native-generation/#prebuild) is a concept unique to Expo projects. It refers to the process of generating the **android** and **ios** directories based on your local configuration and properties.
### When should you run prebuild
You will need to run prebuild locally if you are building via `npx expo run:android|ios`, and change any native dependencies or configuration, such as:
- Installing or updating a library containing native code
- Changing [app config](/workflow/configuration/)(`app.json`)
- Upgrading your Expo SDK version
In these cases, you'll want to rebuild the native directories with:
```sh
$ npx expo prebuild --clean
```
Then, rebuild your app with the updated native code, with:
For Build for Android: 
```sh
$ npx expo run:android
```
For Build for iOS: 
```sh
$ npx expo run:ios
```
### When you don't need to run prebuild
All Expo build tools (`npx expo run:android|ios` and `eas build`) will **prebuild** automatically if no existing native folders are found. This means that there is no need to run prebuild manually when you're running `npx expo run:android|ios` for the first time or `eas build`.


## Create a development build on EAS

Learn how to create development builds for a project.

When you create a new Expo app with `npx create-expo-app`, you start off with a project where you update the JavaScript code on your local machine and view the changes in the Expo Go app. A **development build** is essentially **your own version of Expo Go** where you are free to use any native libraries and change any native config. In this guide, you will learn how to convert your project that runs on Expo Go into a development build, which will make the native side of your app fully customizable.
Video Tutorial: [How to create a development build](https://www.youtube.com/watch?v=uQCE9zl3dXU)
## Prerequisites
The instructions assume you already have an existing Expo project that runs on Expo Go.
The requirements for building the native app depend on which platform you are using, which platform you are building for, and whether you want to build on EAS or on your local machine.
Note: Build on EAS
---
This is the easiest way to build your native app, as it requires no native build tools on your side. The builds happen on the EAS servers, which makes it possible to trigger iOS builds from non-macOS platforms.
|             | Android    | iOS Simulator | iPhone device   |
| ----------- | ---------- | ------------- | --------------- |
| **macOS**   | <YesIcon/> | <YesIcon/>    | <YesIcon/> (\*) |
| **Windows** | <YesIcon/> | <YesIcon/>    | <YesIcon/> (\*) |
| **Linux**   | <YesIcon/> | <YesIcon/>    | <YesIcon/> (\*) |
(\*) All builds that run on an iPhone device require a paid [Apple Developer](https://developer.apple.com) account for build signing.
---
Note: Build locally using the EAS CLI
---
Any EAS CLI command can be built on your local machine with the `--local` flag. This requires your local [development environment](https://reactnative.dev/docs/set-up-your-environment?os=macos&platform=ios) to be set up with native build tools. Read more about [local app development](/build-reference/local-builds/).
|             | Android           | iOS Simulator | iPhone device   |
| ----------- | ----------------- | ------------- | --------------- |
| **macOS**   | <YesIcon/>        | <YesIcon/>    | <YesIcon/> (\*) |
| **Windows** | <YesIcon/> (\*\*) | <NoIcon />    | <NoIcon />      |
| **Linux**   | <YesIcon/>        | <NoIcon />    | <NoIcon />      |
(\*) All builds that run on an iPhone device require a paid [Apple Developer](https://developer.apple.com) account for build signing.
(\*\*) No first-class support, but possible with [WSL](http://expo.fyi/wsl.md).
---
Note: Build locally without EAS
---
To build locally without EAS requires your local [development environment](https://reactnative.dev/docs/set-up-your-environment?os=macos&platform=ios) to be set up with native build tools. This is the only way to test your iOS build on an iPhone device without a paid Apple Developer Account (only possible on macOS). Read more about [local app compilation](/guides/local-app-development/#local-app-compilation) and see the [Expo Go to Development Build](/develop/development-builds/expo-go-to-dev-build/) guide.
|             | Android    | iOS Simulator | iPhone device |
| ----------- | ---------- | ------------- | ------------- |
| **macOS**   | <YesIcon/> | <YesIcon/>    | <YesIcon/>    |
| **Windows** | <YesIcon/> | <NoIcon />    | <NoIcon />    |
| **Linux**   | <YesIcon/> | <NoIcon />    | <NoIcon />    |
---
## Get started
For detailed, step-by-step instructions, see our [EAS Tutorial](/tutorial/eas/introduction). Available also as a [tutorial series](https://www.youtube.com/playlist?list=PLsXDmrmFV_AS14tZCBin6m9NIS_VCUKe2) on YouTube.
Step 1: 
### Install expo-dev-client
```sh
$ npx expo install expo-dev-client
```
Note: Are you using this library in a existing (bare) React Native apps?
---
Apps that don't use [Continuous Native Generation](/workflow/continuous-native-generation/) or are created with `npx react-native`, require further configuration after installing this library. See steps 1 and 2 from [Install `expo-dev-client` in an existing React Native app](/bare/install-dev-builds-in-bare/).
---
Step 2: 
### Build the native app (Android)
<Prerequisites numberOfRequirements={3}>
  <Requirement number={1} title="Expo account">
    Sign up for an [Expo](https://expo.dev/signup) account, if you haven't already.
  </Requirement>
  <Requirement number={2} title="EAS CLI">
    The [EAS CLI](/build/setup/#install-the-latest-eas-cli) installed and logged in.
    ```sh
$ npm install -g eas-cli && eas login
```
  </Requirement>
  <Requirement number={3} title="An Android Emulator (optional)">
    An [Android Emulator](/workflow/android-studio-emulator/) is optional if you want to test your
    app on an emulator.
  </Requirement>
</Prerequisites>
```sh
$ eas build --platform android --profile development
```
Read more about [Android builds on EAS](/tutorial/eas/android-development-build).
Step 2: 
### Build the native app (iOS Simulator)
<Prerequisites numberOfRequirements={3}>
  <Requirement number={1} title="Expo account">
    Sign up for an [Expo](https://expo.dev/signup) account, if you haven't already.
  </Requirement>
  <Requirement number={2} title="EAS CLI">
    The [EAS CLI](/build/setup/#install-the-latest-eas-cli) installed and logged in.
    ```sh
$ npm install -g eas-cli && eas login
```
  </Requirement>
  <Requirement number={3} title="macOS with iOS Simulator installed">
    iOS Simulators are available only on macOS. Make sure you have the [iOS
    Simulator](/workflow/ios-simulator/) installed.
  </Requirement>
</Prerequisites>
Edit `development` profile in **eas.json** and set the [`simulator`](/eas/json/#simulator) option to `true` (you have to create a separate profile for simulator builds if you also want to create iOS device builds for this project).
```json eas.json
{
  "build": {
    "development": {
      "ios": {
        "simulator": true
      }
    }
  }
}
```
```sh
$ eas build --platform ios --profile development
```
iOS Simulator builds can only be installed on simulators and not on real devices.
Read more about [iOS Simulator builds on EAS](/tutorial/eas/ios-development-build-for-simulators/).
Step 2: 
### Build the native app (iOS device)
<Prerequisites numberOfRequirements={3}>
  <Requirement number={1} title="Expo account">
    Sign up for an [Expo](https://expo.dev/signup) account, if you haven't already.
  </Requirement>
  <Requirement number={2} title="EAS CLI">
    The [EAS CLI](/build/setup/#install-the-latest-eas-cli) installed and logged in.
    ```sh
$ npm install -g eas-cli && eas login
```
  </Requirement>
  <Requirement number={3} title="Apple Developer account">
    A paid [Apple Developer](https://developer.apple.com/) account for creating [signing
    credentials](/app-signing/managed-credentials/#generating-app-signing-credentials) so the app
    could be installed on an iOS device.
  </Requirement>
</Prerequisites>
```sh
$ eas build --platform ios --profile development
```
iOS device builds can only be installed on iPhone devices and not on iOS Simulators.
Read more about [iOS device builds on EAS](/tutorial/eas/ios-development-build-for-devices/).
Step 3: 
### Install the app
You'll need to install the native app on your device, emulator, or simulator.
#### When building on EAS
If you create your development build on EAS, the CLI will prompt you to install the app after the build is finished. You can also install previous builds from the [expo.dev](https://expo.dev/) dashboard or using [Expo Orbit](https://expo.dev/orbit).
#### When building locally using EAS CLI
When building locally the output of the build will be an archive. You may drag and drop this on your Android Emulator/iOS Simulator to install it, or use [Expo Orbit](https://expo.dev/orbit) to install a build from your local machine.
Step 4: 
### Start the bundler
The development client built in **step 2** is the native side of your app (basically your own version of Expo Go). To continue developing, you'll also want to start the JavaScript bundler.
Depending on how you built the app, this may already be running, but if you close the process for any reason, there is no need to rebuild your development client. Simply restart the JavaScript bundler with:
```sh
$ npx expo start
```
This is the same command you would have used with Expo Go. It detects whether your project has `expo-dev-client` installed, in which case it will default to targeting your development build instead of Expo Go.
## Video walkthroughs


## Use a development build

Learn how to use development builds for a project.

Usually, creating a new native build from scratch takes long enough that you'll be tempted to switch tasks and lose your focus. However, with the development build installed on your device or an emulator/simulator, you won't have to wait for the native build process until you [change the underlying native code](#rebuild-a-development-build) that powers your app.
## Start the development server
To start developing, run the following command to start the development server:
```sh
$ npx expo start
```
To open the project inside your development client:
- Press <kbd>a</kbd> or <kbd>i</kbd> keys to open your project on an Android Emulator or an iOS Simulator.
- On a physical device, scan the QR code from your system's camera or a QR code reader to open the project on your device.
## The launcher screen
If you launch the development build from your device's Home screen, you will see your launcher screen, which looks similar to the following:
If a bundler is detected on your local network, or if you have signed in to an Expo account in both Expo CLI and your development build, you can connect to it directly from this screen. Otherwise, you can connect by scanning the QR code displayed by the Expo CLI.
## Rebuild a development build
If you add a library to your project that contains native code APIs, for example, [`expo-secure-store`](/versions/latest/sdk/securestore/), you will have to rebuild the development client. This is because the native code of the library is not included in the development client automatically when installing the library as a dependency on your project.
## Debug a development build
When you need to, you can access the menu by pressing <kbd>Cmd ⌘</kbd> + <kbd>d</kbd> or <kbd>Ctrl</kbd> + <kbd>d</kbd> in Expo CLI or by shaking your phone or tablet. Here you'll be able to access all of the functions of your development build, any debugging functionality you need, or switch to a different version of your app.
See [Debugging](/debugging/runtime-issues/) guide for more information.


## Share a development build with your team

Learn how to install and share the development with your team or run it on multiple devices.

Android and iOS both offer ways to install a build of your application directly on devices. This gives you full control of putting specific builds on devices, allowing you to iterate quickly and have multiple builds of your application available for review at the same time. You can also share it with your team or run it on multiple test devices.
## Share the URL
When a development build is ready, a shareable URL is generated for your build with instructions on how to get it up and running. You can use this URL with a teammate or send it to your test device to install the build. The URL generated is unique to the build for your project.
> If you register any new iOS devices after creating a development build, you'll need to create a new development build to install it on those devices. For more information, see [internal distribution](/build/internal-distribution/).
### Use the EAS dashboard
You can also direct your teammate to the build page in the EAS dashboard. From there, they can download the build artifact directly on their device.
### Use EAS CLI
Your teammate can also download and install the development build using EAS CLI. They have to make sure that they are signed from the Expo account associated with the development build and then can run the following command:
```sh
$ eas build:run --profile development
```
If the profile name for the development build is different from `development`, use it instead with `--profile`.
### iOS-only instructions
> If you're running iOS 16 or above and haven't yet turned on Developer Mode, you'll need to [enable it](/guides/ios-developer-mode) before you can run your build. (This doesn't apply if you're using enterprise provisioning.)
You can use `eas build:resign` to codesign an existing **.ipa** for iOS to a new ad hoc provisioning profile. This helps reduce time when distributing with your team. For example, if you want to add a new test device to an existing build, you can use this command to update the provisioning profile to include the device without rebuilding the entire app from scratch. For more information, see [Re-signing new credentials](/app-signing/app-credentials/#re-signing-new-credentials).
## Next steps


## Tools, workflows and extensions

Learn more about different tools, workflows and extensions available when working with development builds.

Development builds allow you to iterate quickly. However, you can extend the capabilities of your development build to provide a better developer experience when working in teams or customize the build to suit your needs.
## Tools
### Tunnel URLs
Sometimes, restrictive network conditions make it difficult to connect to the development server. The `npx expo start` command exposes your development server on a publicly available URL that is accessible through firewalls from around the globe. This option is helpful if you are not able to connect to your development server with the default LAN option or if you want to get feedback on your implementation while you are developing.
To get a tunneled URL, pass the [`--tunnel` flag](/more/expo-cli/#tunneling) to `npx expo start` from the command line.
### Published updates
EAS CLI's `eas update` command bundles the current state of your JavaScript and asset files into an optimized "update". This update is stored on a hosting service by Expo. A development build of your app can load published updates without needing to check out a particular commit or leave a development machine running.
### Manually entering an update's URL
When a development build launches, it will expose UI to load a development server, or to "Enter URL manually". You can provide a URL manually that will launch a specific branch. The URL follows this pattern:
```text
https://u.expo.dev/[your-project-id]?channel-name=[channel-name]
# Example
https://u.expo.dev/F767ADF57-B487-4D8F-9522-85549C39F43F?channel-name=main
```
To get your project's ID, use the URL in the [app config's `expo.updates.url`](/versions/latest/config/app/#url) field. To see a list of channels, run `eas channel:list`.
### Deep linking to an update's URL
You can load your app on a device that has a compatible build of your custom client by opening a URL of the form `{scheme}://expo-development-client/?url={manifestUrl}`. You'll need to pass the following parameters:
| parameter     | value                                                                                                                                     |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `scheme`      | URL scheme of your client (defaults to `exp+{slug}` where [`slug`](/versions/latest/config/app/#slug) is the value set in the app config) |
| `manifestUrl` | URL-encoded URL of an update manifest to load. The URL will be `https://u.expo.dev/[your-project-id]?channel-name=[channel-name]`         |
Example:
```text
exp+app-slug://expo-development-client/?url=https%3A%2F%2Fu.expo.dev%2F767ADF57-B487-4D8F-9522-85549C39F43F%2F%3Fchannel-name%3Dmain
```
In the example above, the `scheme` is `exp+app-slug`, and the `manifestUrl` is a project with an ID of `F767ADF57-B487-4D8F-9522-85549C39F43F` and a channel of `main`.
#### Using updates deep links in automation scenarios
When launching an update URL in a development build on an emulator or simulator using automation, such as in a CI/CD workflow, you can add the `disableOnboarding=1` query parameter to the URL to skip the onboarding screen that appears on the first launch of a development build after installation.
#### App-specific deep links
When testing deep links in your development build, such as when navigating to a specific screen in an Expo Router app or testing redirecting back to your app during an Oauth login flow, construct the URL exactly as you would if you were deep-linking into a standalone build of your app (for example, `myscheme://path/to/screen`).
Your project must be already open in the development build for an app-specific deep link to work. Cold-launching a development build with an app-specific deep link is not currently supported. Avoid using `expo-development-client` in your app-specific deep links in the path, as it is a reserved path used for launching an updated URL.
### QR codes
You can use our endpoint to generate a QR code that can be easily loaded by a development build.
Requests send to `https://qr.expo.dev/development-client` when supplied the query parameters such as `appScheme` and `url` will receive a response with an SVG image containing a QR code that can be easily scanned to load a version of your project in your development build.
| parameter   | value                                                                                                                                                                    |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `appScheme` | URL-encoded deeplinking scheme of your development build (defaults to `exp+{slug}` where [`slug`](/versions/latest/config/app/#slug) is the value set in the app config) |
| `url`       | URL-encoded URL of an update manifest to load. The URL will be `https://u.expo.dev/[your-project-id]?channel-name=[channel-name]`                                        |
Example:
```text
https://qr.expo.dev/development-client?appScheme=exp%2Bapps-slug&url=https%3A%2F%2Fu.expo.dev%2FF767ADF57-B487-4D8F-9522-85549C39F43F0%3Fchannel-name%3Dmain
```
In the example above, the `scheme` is `exp+app-slug`, and the `url` is a project with an ID of `F767ADF57-B487-4D8F-9522-85549C39F43F` and a channel of `main`.
## Example workflows
These are a few examples of workflows to help your team get the most out of your development build. If you come up with others that would be useful for other teams, [submit a PR](https://github.com/expo/expo/tree/main/CONTRIBUTING.md#-updating-documentation) to share your knowledge!
### PR previews
You can set up your CI process to publish an EAS Update whenever a pull request is updated and add a QR code that is used to view the change in a compatible development build.
See [instructions for publishing app previews on pull requests](/eas-update/github-actions/#publish-previews-on-pull-requests) to implement this workflow in your project using GitHub Actions or serve as a template in your CI of choice.
## Extensions
Extensions allow you to extend your development client with additional capabilities.
### Extending the dev menu
The dev menu can be extended to include extra buttons by using the `registerDevMenuItems` API:
```tsx
import { registerDevMenuItems } from 'expo-dev-menu';
const devMenuItems = [
  {
    name: 'My Custom Button',
    callback: () => console.log('Hello world!'),
  },
];
registerDevMenuItems(devMenuItems);
```
This will create a new section in the dev menu that includes the buttons you have registered:
> Subsequent calls of `registerDevMenuItems` will override all previous entries.
### EAS Update
The EAS Update extension provides the ability to view and load published updates in your development client.
It's available for all development clients `v0.9.0` and above. To install it, you'll need the most recent publish of `expo-updates`:
```sh
$ npx expo install expo-dev-client expo-updates
```
#### Configure EAS Update
If you have not yet configured EAS Updates in your project, you can find [additional instructions on how to do so here.](/eas-update/getting-started/)
You can now view and load EAS Updates in your development build via the `Extensions` panel.
## Set runtimeVersion in app config
When you create a development build of your project, you'll get a stable environment to load any changes to your app that are defined in JavaScript or other asset-related changes. Other changes to your app, whether defined directly in **android** and **ios** directories or by packages or SDKs you choose to install, will require you to create a new build of your development build.
To enforce an API contract between the JavaScript and native layers of your app, you should set the [`runtimeVersion`](/eas-update/runtime-versions) value in the app config. Each build you make will have this value embedded and will only load bundles with the same `runtimeVersion`, in both development and production.


## Next steps

A list of useful resources to learn more about development builds and EAS Build.

# Config plugins

## Introduction to config plugins

An introduction to Expo config plugins.

When using [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) in a project, native project (**android** and **ios** directories) changes are implemented without directly interacting with the native project files. Instead, you can use a config plugin to automatically configure your native project beyond what can be configured using the default app config props.
## What is a config plugin
A config plugin is a top-level custom configuration point that is not built into the [app config](/workflow/configuration). Using a config plugin, you can modify native projects created during the [prebuild](/workflow/continuous-native-generation/#usage) process in CNG projects.
A config plugin is referenced in the `plugins` property of the [app config](/workflow/configuration) file and is made up of one or more plugin functions. These plugin functions are written in JavaScript and are executed during the prebuild process.
## Glossary
A typical config plugin is made up of one or more plugin functions that work together. The following diagram shows how the different parts of a config plugin interact with each other:
<ConfigPluginHierarchy highlightedNodeId="1" />
In the following guides, we will use the above diagram to highlight specific terminology explained below:
### Plugin
The top-level config plugin which is referenced in your app config's `plugins` array. This is the entry point for your plugin. Conventionally, it is named `with<Plugin Name>`. For example, `withMyPlugin`. It is made of one or more [plugin functions](#plugin-function).
### Plugin function
One or more functions inside a config plugin that are called _plugin functions_. They wrap the underlying logic of performing platform-specific modifications. Technically, plugin functions look just like the function for the top-level plugin itself, and could be used as a plugin independently. Breaking plugins into smaller functions is often helpful for testing and debugging.
### Mod plugin function
Wrapper functions from `expo/config-plugins` library that provide a safe way to modify native files using `mods`. As a developer, you will use these functions in your config plugin instead of underlying `mods`.
### Mod
The underlying platform-specific modifiers (like `mods.android.manifest` and `mods.ios.infoplist`) that directly modify native project files during prebuild.
## Why use a config plugin
Config plugins can add native configuration to your project that isn't included by default. They can be used to generate app icons, set the app name, configure **AndroidManifest.xml** and **Info.plist**, and so on.
In CNG projects, it is best to avoid modifying these native projects manually, because you cannot regenerate them safely without potentially overwriting manual modifications. Config plugins allow you to modify these native projects in a _predictable way_ by consolidating your native project changes into a configuration file and applying them when you run `npx expo prebuild` (either manually or automatically during a CI/CD process). For example, when you change the name of your app in app config and run `npx expo prebuild`, the name will change in your native projects automatically without the need to manually update **AndroidManifest.xml** and **Info.plist** files.
## Characteristics of a config plugin
Config plugins have the following characteristics:
- Plugins are **synchronous** functions that accept an [ExpoConfig](/workflow/configuration) and return a modified `ExpoConfig`. In rare cases, plugins can also be asynchronous if available methods to communicate with native projects are asynchronous, but they won't be performant.
- Plugins should be named using the following convention: `with<Plugin Functionality>`, for example, `withFacebook`
- Plugins should be synchronous and their return value should be serializable, except for adding any [`mods`](#mods)
- Plugins are always evaluated during the app config evaluation phase.
- Optionally, a second argument can be passed to the plugin to configure it
- Mods are only evaluated during the **syncing** phase of `npx expo prebuild` (prebuild process) and modify native files during code generation. Because of that, any modifications made to app config in a config plugin should be outside of a mod to ensure that they are executed in non-prebuild configuration scenarios.
## Get started


## Create and use config plugins

Learn how to create and use a config plugins in your Expo project.

This guide covers sections on how to create a config plugin, how to pass parameters to a config plugin, and how to chain multiple config plugins together. It also covers how to use a config plugin from an Expo library.
Using the diagram below, in this guide, you will learn the first two parts of the config plugin hierarchy:
<ConfigPluginHierarchy highlightedNodeIds={['1', '2']} />
> **info** **Note:** The following sections use dynamic [app config](/workflow/configuration/) (**app.config.js/app.config.ts** instead of **app.json**), which is not required to use a simple config plugin. However, it is required to use dynamic app config when you want to create/use a function-based config plugin that accepts parameters.
## Creating a config plugin
In the following section, let's create a local config plugin that adds an arbitrary property `HelloWorldMessage` to the **AndroidManifest.xml** for Android and **Info.plist** for iOS.
This example will create and modify the following files. To follow along, create a **plugins** directory in the root of your project, and inside it, create **withAndroidPlugin.ts**, **withIosPlugins.ts**, and **withPlugin.ts** files.
```
├── plugins/
│   ├── withAndroidPlugin.ts  # Contains Android-specific modifications
│   ├── withIosPlugin.ts  # Contains iOS-specific modifications
│   └── withPlugin.ts  # Main plugin file that combines both Android and iOS plugins
└── app.config.ts  # Dynamic app config file that uses the plugin
```
Step 1: 
### Create Android plugin
In **withAndroidPlugin.ts**, add the following code:
```ts withAndroidPlugin.ts
import { ConfigPlugin, withAndroidManifest } from 'expo/config-plugins';
const withAndroidPlugin: ConfigPlugin = config => {
  // Define a custom message
  const message = 'Hello world, from Expo plugin!';
  return withAndroidManifest(config, config => {
    const mainApplication = config?.modResults?.manifest?.application?.[0];
    if (mainApplication) {
      // Ensure meta-data array exists
      if (!mainApplication['meta-data']) {
        mainApplication['meta-data'] = [];
      }
      // Add the custom message as a meta-data entry
      mainApplication['meta-data'].push({
        $: {
          'android:name': 'HelloWorldMessage',
          'android:value': message,
        },
      });
    }
    return config;
  });
};
export default withAndroidPlugin;
```
The example code above adds a meta-data entry `HelloWorldMessage` to the **android/app/src/main/AndroidManifest.xml** file by importing `ConfigPlugin` and `withAndroidManifest` from the `expo/config-plugins` library. The [`withAndroidManifest`](/config-plugins/mods/#mod-plugins) mod plugin is an asynchronous function that accepts a config and a data object and modifies the value before returning an object.
Step 2: 
### Create iOS plugin
In **withIosPlugin.ts**, add the following code:
```ts withIosPlugin.ts
import { ConfigPlugin, withInfoPlist } from 'expo/config-plugins';
const withIosPlugin: ConfigPlugin = config => {
  // Define the custom message
  const message = 'Hello world, from Expo plugin!';
  return withInfoPlist(config, config => {
    // Add the custom message to the Info.plist file
    config.modResults.HelloWorldMessage = message;
    return config;
  });
};
export default withIosPlugin;
```
The example code above adds `HelloWorldMessage` as the custom key with a custom message in **ios/\<your-project-name\>/Info.plist** file by importing the `ConfigPlugin` and `withInfoPlist` from the `expo/config-plugins` library. The [`withInfoPlist`](/config-plugins/mods/#mod-plugins) mod plugin is an asynchronous function that accepts a config and a data object and modifies the value before returning an object.
Step 3: 
### Create a combined plugin
Now you can create a combined plugin that applies both platform-specific plugins. This approach allows the maintenance of platform-specific code separately while providing a single entry point.
In **withPlugin.ts**, add the following code:
```ts withPlugin.ts
import { ConfigPlugin } from 'expo/config-plugins';
import withAndroidPlugin from './withAndroidPlugin';
import withIosPlugin from './withIosPlugin';
const withPlugin: ConfigPlugin = config => {
  // Apply Android modifications first
  config = withAndroidPlugin(config);
  // Then apply iOS modifications and return
  return withIosPlugin(config);
};
export default withPlugin;
```
Step 4: 
### Add TypeScript support and convert to dynamic app config
We recommend writing config plugins in TypeScript, since this will provide intellisense for the configuration objects. However, your app config is ultimately evaluated by Node.js, which does not recognize TypeScript code by default. Therefore, you will need to add a parser for the TypeScript files from the **plugins** directory to **app.config.ts** file.
Install `tsx` library by running the following command:
```sh
$ npm install --save-dev tsx
```
Then, change the static app config (**app.json**) to the [dynamic app config (**app.config.ts**)](/workflow/configuration/#dynamic-configuration) file. You can do this by renaming the **app.json** file to **app.config.ts** and changing the content of the file as shown below. Ensure to add the following import statement at the top of your **app.config.ts** file:
```ts app.config.ts
import 'tsx/cjs';
module.exports = () => {
};
```
Step 5: 
### Call the config plugin from your dynamic app config
Now, you can call the config plugin from your dynamic app config. To do this, you need to add the path to the **withPlugin.ts** file to the plugins array in your app config:
```ts app.config.ts
import "tsx/cjs";
import { ExpoConfig } from "expo/config";
  plugins: [
      ["./plugins/withPlugin.ts"],
    ],
};
```
To see the custom config applied in native projects, run the following command:
```sh
$ npx expo prebuild --clean --no-install
```
To verify the custom config plugins applied, open **android/app/src/main/AndroidManifest.xml** and **ios/\<your-project-name\>/Info.plist** files:
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
<!-- ... rest of the configuration-->
	<application ...>
		<meta-data android:name="HelloWorldMessage" android:value="Hello world, from Expo plugin!"/>
		<!-- ... -->
	</application>
</manifest>
```
```xml
<plist version="1.0">
  <dict>
  <!-- ... -->
    <key>HelloWorldMessage</key>
    <string>Hello world, from Expo plugin!</string>
	<!-- ... -->
	</dict>
</plist>
```
## Passing a parameter to a config plugin
Your config plugin can accept parameters passed from your app config. To do so, you will need to read the parameter in your config plugin function, and then pass an object containing the parameter along with the config plugin function in your app config.
Step 1: 
Considering the previous example, let's pass a custom message to the plugin. Add an `options` object in **withAndroidPlugin.ts** and update the `message` variable to use the `options.message` property:
```ts withAndroidPlugin.ts
type AndroidProps = {
  message?: string;
};
const withAndroidPlugin: ConfigPlugin<AndroidProps> = (
  config,
) => {
  const message = options.message || 'Hello world, from Expo plugin!';
  return withAndroidManifest(config, config => {
  });
};
export default withAndroidPlugin;
```
Step 2: 
Similarly, add an `options` object in **withIosPlugin.ts** and update the `message` variable to use the `options.message` property:
```ts withIosPlugin.ts
type IosProps = {
  message?: string;
};
  const message = options.message || 'Hello world, from Expo plugin!';
};
export default withIosPlugin;
```
Step 3: 
Update the **withPlugin.ts** file to pass the `options` object to both plugins:
```ts withPlugin.ts
  config = withAndroidPlugin(config, options);
  return withIosPlugin(config, options);
};
```
Step 4: 
To pass a value dynamically to the plugin, you can pass an object with the `message` property to the plugin in your app config:
```ts app.config.ts
{
  plugins: [
    [
      "./plugins/withPlugin.ts",
      { message: "Custom message from app.config.ts" },
    ],
  ],
}
```
## Chaining config plugins
Config plugins can be chained together to apply multiple modifications. Each plugin in the chain runs in the order it appears, with the output of one plugin becoming the input for the next. This sequential execution ensures that dependencies between plugins are respected and allows you to control the precise order of modifications to your native code.
To chain config plugins, you can pass an array of plugins to the `plugins` array property in your app config. This is also supported in JSON app config file format (**app.json**).
```ts app.config.ts
module.exports = ({ config }: { config: ExpoConfig }) => {
  name: 'my app',
  plugins: [
    [withFoo, 'input 1'],
    [withBar, 'input 2'],
    [withDelta, 'input 3'],
  ],
};
```
The `plugins` array uses `withPlugins` method under the hood to chain the plugins. If your plugins array is getting long or has complex configuration, you can use the `withPlugins` method directly to make your configuration easier to read. `withPlugins` will chain the plugins together and execute them in order.
```ts app.config.ts
import { withPlugins } from 'expo/config-plugins';
// Create a base config object
const baseConfig = {
  name: 'my app',
};
// ❌ Hard to read
withDelta(withFoo(withBar(config, 'input 1'), 'input 2'), 'input 3');
// ✅ Easy to read
withPlugins(config, [
  [withFoo, 'input 1'],
  [withBar, 'input 2'],
  // When no input is required, you can just pass the method
  withDelta,
]);
// Export the base config with plugins applied
module.exports = ({ config }: { config: ExpoConfig }) => {
  return withPlugins(baseConfig, plugins);
};
```
## Using a config plugin
Expo config plugins are usually included in Node.js modules. You can install them just like other libraries in your project.
For example, `expo-camera` has a plugin that adds camera permissions to the **AndroidManifest.xml** and **Info.plist**. To install it in your project, run the following command:
```sh
$ npx expo install expo-camera
```
In your [app config](/versions/latest/config/app/), you can add `expo-camera` to the list of plugins:
```json app.json
{
  "expo": {
    "plugins": ["expo-camera"]
  }
}
```
Some config plugins offer flexibility by allowing you to pass options to customize their configuration. To do this, you can pass an array with the Expo library name as the first argument, and an object containing the options as the second argument. For example, the `expo-camera` plugin allows you to customize the camera permission message:
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-camera",
        {
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera."
        }
      ]
    ]
  }
}
```
> **info** **Tip**: For every Expo library that has a config plugin, you'll find more information about that in the library's API reference. For example, the [`expo-camera` library has a config plugin section](/versions/latest/sdk/camera/#configuration-in-appjsonappconfigjs).
On running the `npx expo prebuild`, the [`mods`](/config-plugins/introduction/#mods) are compiled, and the native files change.
The changes don't take effect until you rebuild the native project, for example, with Xcode. **If you're using config plugins in a project without native directories (CNG projects), they will be applied during the prebuild step in EAS Build** or when running `npx expo prebuild|android|ios` locally.


## Mods

Learn about mods and how to use them when creating a config plugin.

This guide explains what mods and mod plugins are, how they work, and how to use them effectively when creating config plugins for your Expo project.
Using the diagram below, in this guide, you will learn the last two parts of the config plugin hierarchy:
<ConfigPluginHierarchy highlightedNodeIds={['3', '4']} />
## Mod plugins
Mod plugins provide a way to modify native project files during the prebuild process. They are made available from `expo/config-plugins` library and wrap top-level mods (also known as _default [mods](#mods)_) because top-level mods are platform-specific and perform various tasks that can be difficult to understand at first.
> **info** **Tip:** If you are developing a feature that requires mods, you should use _mod plugins_ instead of interacting with top-level mods directly.
### Available mod plugins
The following mod plugins are available in the `expo/config-plugins` library:
#### Android
| Default Android mod               | Mod plugin                                                                                                                                                                             |    Dangerous    | Description                                                                                               |
| --------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------: | --------------------------------------------------------------------------------------------------------- |
| `mods.android.manifest`           | `withAndroidManifest` ([Example](https://github.com/expo/expo/blob/main/packages/expo-notifications/plugin/src/withNotificationsAndroid.ts))                                           |        -        | Modify the **android/app/src/main/AndroidManifest.xml** as JSON (parsed with [`xml2js`][xml2js])          |
| `mods.android.strings`            | `withStringsXml` ([Example](https://github.com/expo/expo/blob/d7fb5d254d5cb57ab06055136db72b9347d3db1e/packages/expo-navigation-bar/plugin/src/withNavigationBar.ts))                  |        -        | Modify the **android/app/src/main/res/values/strings.xml** as JSON (parsed with [`xml2js`][xml2js]).      |
| `mods.android.colors`             | `withAndroidColors` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/android/StatusBar.ts#L8))                                                    |        -        | Modify the **android/app/src/main/res/values/colors.xml** as JSON (parsed with [`xml2js`][xml2js]).       |
| `mods.android.colorsNight`        | `withAndroidColorsNight` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/prebuild-config/src/plugins/unversioned/expo-splash-screen/withAndroidSplashStyles.ts#L5)) |        -        | Modify the **android/app/src/main/res/values-night/colors.xml** as JSON (parsed with [`xml2js`][xml2js]). |
| `mods.android.styles`             | `withAndroidStyles` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/prebuild-config/src/plugins/unversioned/expo-splash-screen/withAndroidSplashStyles.ts#L5))      |        -        | Modify the **android/app/src/main/res/values/styles.xml** as JSON (parsed with [`xml2js`][xml2js]).       |
| `mods.android.gradleProperties`   | `withGradleProperties` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/android/BuildProperties.ts#L5))                                           |        -        | Modify the **android/gradle.properties** as a `Properties.PropertiesItem[]`.                              |
| `mods.android.mainActivity`       | `withMainActivity` ([Example](https://github.com/expo/expo/blob/main/packages/install-expo-modules/src/plugins/android/withAndroidModulesMainActivity.ts#L2))                          | <WarningIcon /> | Modify the **android/app/src/main/&lt;package&gt;/MainActivity.java** as a string.                        |
| `mods.android.mainApplication`    | `withMainApplication` ([Example](https://github.com/expo/expo/blob/main/packages/expo-web-browser/plugin/src/withWebBrowserAndroid.ts#L8))                                             | <WarningIcon /> | Modify the **android/app/src/main/&lt;package&gt;/MainApplication.java** as a string.                     |
| `mods.android.appBuildGradle`     | `withAppBuildGradle` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/android/GoogleServices.ts#L5))                                              | <WarningIcon /> | Modify the **android/app/build.gradle** as a string.                                                      |
| `mods.android.projectBuildGradle` | `withProjectBuildGradle` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/android/GoogleServices.ts#L5))                                          | <WarningIcon /> | Modify the **android/build.gradle** as a string.                                                          |
| `mods.android.settingsGradle`     | `withSettingsGradle` ([Example](https://github.com/expo/expo/blob/main/packages/install-expo-modules/src/plugins/android/withAndroidSettingsGradle.ts#L2))                             | <WarningIcon /> | Modify the **android/settings.gradle** as a string.                                                       |
#### iOS
| Default iOS mod              | Mod plugin                                                                                                                                    | Dangerous       | Description                                                                                                                         |
| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | --------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `mods.ios.infoPlist`         | `withInfoPlist` ([Example](https://github.com/expo/expo/blob/main/packages/expo-location/plugin/src/withLocation.ts))                         | -               | Modify the **ios/&lt;name&gt;/Info.plist** as JSON (parsed with [`@expo/plist`][expo-plist]).                                       |
| `mods.ios.entitlements`      | `withEntitlementsPlist` ([Example](https://github.com/expo/expo/blob/main/packages/expo-apple-authentication/plugin/src/withAppleAuthIOS.ts)) | -               | Modify the **ios/&lt;name&gt;/&lt;product-name&gt;.entitlements** as JSON (parsed with [`@expo/plist`][expo-plist]).                |
| `mods.ios.expoPlist`         | `withExpoPlist` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/ios/Updates.ts#L6))                     | -               | Modify the **ios/&lt;name&gt;/Expo.plist** as JSON (Expo updates config for iOS) (parsed with [`@expo/plist`][expo-plist]).         |
| `mods.ios.xcodeproj`         | `withXcodeProject` ([Example](https://github.com/expo/expo/blob/main/packages/expo-asset/plugin/src/withAssetsIos.ts))                        | -               | Modify the **ios/&lt;name&gt;.xcodeproj** as an `XcodeProject` object (parsed with [`xcode`](https://www.npmjs.com/package/xcode)). |
| `mods.ios.podfile`           | `withPodfile` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/ios/Maps.ts#L6)                           | -               | Modify the **ios/Podfile** as a string.                                                                                             |
| `mods.ios.podfileProperties` | `withPodfileProperties` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/ios/BuildProperties.ts#L4))     | -               | Modify the **ios/Podfile.properties.json** as JSON.                                                                                 |
| `mods.ios.appDelegate`       | `withAppDelegate` ([Example](https://github.com/expo/expo/blob/main/packages/%40expo/config-plugins/src/ios/Maps.ts#L6))                      | <WarningIcon /> | Modify the **ios/&lt;name&gt;/AppDelegate.m** as a string.                                                                          |
> **info** **Note about default Android and iOS mods:** 
> Default mods are provided by the mod compiler for common file manipulation. Dangerous modifications rely on regular expressions (regex) to modify application code, which may cause the build to break. Regex mods are also difficult to version, and therefore should be used sparingly. Always opt toward using application code to modify application code, that is, [Expo Modules](https://github.com/expo/expo/tree/main/packages/expo-modules-core) native API.
## Mods
Config plugins use **mods** (short for modifiers) to modify native project files during the prebuild process. Mods are asynchronous functions that allow you to make changes to platform-specific files such as **AndroidManifest.xml** and **Info.plist**, and other native configuration files without having to manually edit them. They execute only during the **syncing** phase of `npx expo prebuild` (prebuild process).
They accept a config and a data object, then modify and return both of them as a single object. For example, in native projects, `mods.android.manifest` modifies **AndroidManifest.xml** and `mods.ios.plist` modifies **Info.plist**.
**You don't use mods as top-level functions (for example `with.android.manifest`) directly in your config plugin.** When you need to use a mod, you use _mod plugins_ in your config plugins. These mod plugins are provided by the `expo/config-plugins` library and wrap top-level mod functions and behind the scenes they perform various tasks. To see a list of available mods, check out the [mod plugins provided by `expo/config-plugins`](#available-mod-plugins).
Note: How default mods work and their key characteristics
---
When a default mod resolves, it is added to the `mods` object of the app config. This `mods` object is different from the rest of the app config
because it doesn't get serialized, which means you can use it to perform actions _during_ code generation. Whenever possible, you should use available mod plugins instead of default mods since they are easier to work with.
Here is a high-level overview of how default mods work:
- The config is read using [`getPrebuildConfig`](https://github.com/expo/expo/blob/efc2db4eb1c909544e28792a15c89f8d22113c5b/packages/%40expo/prebuild-config/src/getPrebuildConfig.ts#L28) from `@expo/prebuild-config`
- All of the core functionality supported by Expo is added via plugins in `withIosExpoPlugins`. This includes name, version, icons, locales, and so on.
- The config is passed to the compiler `compileModsAsync`
- The compiler adds base mods that are responsible for reading data (like **Info.plist**), executing a named mod (like `mods.ios.infoPlist`), then writing the results to the file system
- The compiler iterates over all the mods and asynchronously evaluates them, providing some base props like the `projectRoot`
  - After each mod, error handling asserts if the mod chain was corrupted by an invalid mod
Here are some key characteristics of default mods:
- `mods` are omitted from the manifest and **cannot** be accessed via `Updates.manifest`. Mods exist for the sole purpose of modifying native project files during code generation!
- `mods` can be used to read and write files safely during the `npx expo prebuild` command. This is how Expo CLI modifies the **Info.plist**, entitlements, xcproj, and so on.
- `mods` are platform-specific and should always be added to a platform-specific object:
  ```ts app.config.ts
  module.exports = {
    name: 'my-app',
    mods: {
      ios: {
        /* iOS mods... */
      },
      android: {
        /* Android mods... */
      },
    },
  };
  ```
After mods are resolved, the contents of each mod will be written to disk. Custom mods can be added to support new native files. For example, you can create a mod to support the **GoogleServices-Info.plist**, and pass it to other mods.
---
### How mod plugins work
When a mod plugin is executed, it gets passed a `config` object with additional properties: `modResults` and `modRequest`.
#### `modResults`
The `modResults` object contains the data to modify and return. Its type depends on the mod that's being used.
#### `modRequest`
The `modRequest` object contains the following additional properties supplied by the mod compiler.
| Property              | Type          | Description                                                                                                   |
| --------------------- | ------------- | ------------------------------------------------------------------------------------------------------------- |
| `projectRoot`         | `string`      | Project root directory for the universal app.                                                                 |
| `platformProjectRoot` | `string`      | Project root for the specific platform.                                                                       |
| `modName`             | `string`      | Name of the mod.                                                                                              |
| `platform`            | `ModPlatform` | Name of the platform used in the mods config.                                                                 |
| `projectName`         | `string`      | (iOS only) The path component used for querying project files. For example, `projectRoot/ios/[projectName]/`. |
## Create your own mod
For example, if you want to write a mod to update the Xcode Project's "product name", you'll create a config plugin file that uses the [`withXcodeProject`](#ios) mod plugin.
```ts my-config-plugin.ts
import { ConfigPlugin, withXcodeProject, IOSConfig } from 'expo/config-plugins';
const withCustomProductName: ConfigPlugin<string> = (config, customName) => {
  return withXcodeProject(
    config,
    async (
    ) => {
      config.modResults = IOSConfig.Name.setProductName({ name: customName }, config.modResults);
      return config;
    }
  );
};
// Usage:
/// Create a config
const config = {
  name: 'my app',
};
/// Use the plugin
export default withCustomProductName(config, 'new_name');
```
## Plugin module resolution
When implementing plugins, there are two fundamental approaches to consider:
1. **Plugins defined within your app's project**: These plugins live locally within your project, making them easy to customize and maintain alongside your app's code. They are ideal for project-specific customizations.
2. **Standalone package plugins**: These plugins exist as separate packages and are published to npm. This approach is ideal for reusable plugins that can be shared across multiple projects.
Both approaches provide the same capabilities for modifying your native configuration, but differ in how they're structured and imported. The sections below explain how module resolution works for each approach.
> Any resolution pattern that isn't specified below is unexpected behavior, and subject to breaking changes.
### Plugins defined within your app's project
With plugins defined within your app's project, you can implement plugins directly in your project in several ways:
#### File import
You can quickly create a plugin in your project by creating a JavaScript/TypeScript file and use it in your config like any other JS/TS file.
```
├── app.config.ts  # import "./my-config-plugin"
└── my-config-plugin.ts  # Imported from config
```
In the above example, the config plugin file contains a bare minimum function:
```ts my-config-plugin.ts
module.exports = ({ config }: { config: ExpoConfig }) => {};
```
#### Inline function inside of dynamic app config
Expo config objects also support passing functions as-is to the `plugins` array. This is useful for testing, or if you want to use a plugin without creating a file.
```js app.config.ts
const withCustom = (config, props) => config;
const config = {
  plugins: [
    [
      withCustom,
      {
        /* props */
      },
    ],
    withCustom,
  ],
};
```
One caveat to using functions instead of strings is that serialization will replace the function with the function's name. This keeps **manifests** (kind of like the **index.html** for your app) working as expected. Here is what the serialized config would look like:
```json
{
  "plugins": [["withCustom", {}], "withCustom"]
}
```
### Standalone package plugins
> **info** See [Create a module with a config plugin](/modules/config-plugin-and-native-module-tutorial/) for a step-by-step guide on how to create a standalone package plugin.
Standalone package plugins can be implemented in two ways:
#### 1. Dedicated config plugin packages
These are npm packages whose sole purpose is to provide a config plugin. For a dedicated config plugin package, you can export your plugin using `app.plugin.js`:
```
├── app.config.ts  # import "expo-splash-screen"
└── node_modules/
    └── expo-splash-screen/  # Node module
        ├── app.plugin.js  # Entry file for custom plugins
        └── build/
            └── index.js  # Skipped in favor of "app.plugin.js"
```
#### 2. Config plugins with companion packages
When a config plugin is part of a Node module without an **app.plugin.js**, it uses the package's `main` entry point:
```
├── app.config.ts  # import "expo-splash-screen"
└── node_modules/
    └── expo-splash-screen/  # Node module
        ├── package.json  # "main": "./build/index.js"
        └── build/
            └── index.js  # Node resolve to this file
```
### Plugin resolution order
When you import a plugin package, files are resolved in this specific order:
1. **app.plugin.js in package root**
```
├── app.config.ts  # import "expo-splash-screen"
└── node_modules/
    └── expo-splash-screen/  # Node module
        ├── package.json  # "main": "./build/index.js"
        ├── app.plugin.js  # Entry file for custom plugins
        └── build/
            └── index.js  # Skipped in favor of app.plugin.js
```
2. **Package's main entry (from package.json)**
```
├── app.config.ts  # import "expo-splash-screen"
└── node_modules/
    └── expo-splash-screen/  # Node module
        ├── package.json  # "main": "./build/index.js"
        └── build/
            └── index.js  # Node resolve to this file
```
3. **Direct internal imports** (not recommended)
> **error** Avoid importing module internals directly as it bypasses the standard resolution order and may break in future updates.
```
├── app.config.ts  # import "expo-splash-screen/build/index.js"
└── node_modules/
    └── expo-splash-screen/
        ├── package.json  # "main": "./build/index.js"
        ├── app.plugin.js  # Ignored due to direct import
        └── build/
            └── index.js  # "expo-splash-screen/build/index.js"
```
### Why use app.plugin.js for plugins
The `app.plugin.js` approach is preferred for config plugins as it allows different transpilation settings from the main package code. This is particularly important because Node environments often require different transpilation presets compared to Android, iOS, or web JS environments (for example, `module.exports` instead of `import/export`).
[xml2js]: https://www.npmjs.com/package/xml2js
[expo-plist]: https://www.npmjs.com/package/@expo/plist


## Using a dangerous mod

Learn about dangerous mods and how to use them when creating a config plugin.

Dangerous mods in Expo provide direct access to native project files through string manipulation and regular expressions. While [existing mod plugins](/config-plugins/mods) are the recommended approach, dangerous mods serve as an escape hatch for modifications that cannot be achieved through existing mod plugins.
Note: Why are they considered dangerous?
---
Automated direct source code manipulation does not typically compose well. For example, if a dangerous mod replaces text in a source file, and a subsequent dangerous mod expects the original text to be there (perhaps it uses the original text as an anchor for a regular expression) then it is unlikely produce the desired result — depending on how it is written, it may either throw an error or log. Other types of mods are less prone to this type of problem, although it can happen with mods that manipulate source files directly like `withAndroidManifest` and `withPodfile`.
Unlike standard mods, which can run multiple times safely, dangerous mods are rarely guaranteed to be idempotent. Running the same dangerous mod multiple times may produce different results, cause duplicate modifications, or break the target file entirely.
---
## When to use a dangerous mod
Consider using a dangerous mod when:
- **Can't make the modification with a standard mod**: The modification you need isn't supported by existing mod plugins like [`withAndroidManifest`](/config-plugins/mods/#android), [`withPodfile`](/config-plugins/mods/#ios), and so on, or if a library requires specific native modifications that aren't covered by standard plugins.
- **Legacy Expo SDK compatibility:** You are targeting an older Expo SDK version that doesn't include the mod plugin you need.
- **Need to modify text with regexes or replace functions**: You need to perform intricate text manipulations that existing mod plugins do not support. Expo uses dangerous mods internally for large file system refactoring, for example, when a library's name changes.
## How to use a dangerous mod
In a real-world scenario, you can use the example config plugin described in this section directly in your project by following the standard config plugin usage pattern from the [Creating a config plugin section](/config-plugins/plugins/#creating-a-config-plugin). However, with the existing mod plugin called [`withPodfile`](/config-plugins/mods/#ios), you don't have to use the dangerous mod. The example below is just for demonstration of how a dangerous mod can be created and used.
Let's take a look at an example config plugin to modify a file inside a native directory (**ios**). This is useful when you are using Continuous Native Generation in your Expo project. With the help of this config plugin, the native file (**ios/Podfile**) will update anytime the `npx expo prebuild` command runs, whether you run it manually or using EAS Build). This example is an ideal use case when an existing mod plugin cannot edit and update a file inside a native directory.
Following the directory structure and steps to create a config plugin (steps 3, 4, and 5) from [Creating a config plugin section](/config-plugins/plugins/#creating-a-config-plugin), let's assume this config plugin is created inside the **plugins** directory of your Expo project:
```tsx withCustomPodfile.ts
import { ConfigPlugin, IOSConfig, withDangerousMod } from 'expo/config-plugins';
import fs from 'fs/promises';
import path from 'path';
const withCustomPodfile: ConfigPlugin = config => {
  return withDangerousMod(config, [
    'ios',
    async config => {
      const podfilePath = path.join(config.modRequest.platformProjectRoot, 'Podfile');
      try {
        let contents = await fs.readFile(podfilePath, 'utf8');
        const projectName = IOSConfig.XcodeUtils.getProjectName(config.modRequest.projectRoot);
        contents = addCustomPod(contents, projectName);
        await fs.writeFile(podfilePath, contents);
        console.log('✅ Successfully added custom pod to Podfile');
      } catch (error) {
        console.warn('⚠️ Podfile not found, skipping modification');
      }
      return config;
    },
  ]);
};
function addCustomPod(contents: string, projectName: string): string {
  if (contents.includes("pod 'Alamofire'")) {
    console.log('Alamofire pod already exists, skipping');
    return contents;
  }
  const targetRegex = new RegExp(
    `(target ['"]${projectName}['"] do[\\s\\S]*?use_expo_modules!)`,
    'm'
  );
  return contents.replace(targetRegex, `$1\n  pod 'Alamofire', '~> 5.6'`);
}
export default withCustomPodfile;
```
In the example above, the plugin **withCustomPodfile** will add a CocoaPod dependency automatically to your project's native **ios/Podfile** during the prebuild process. It uses `withDangerousMod` to provide access to the native file system directly and run after the native project is generated, but before any CocoaPod dependency is installed.
The **Podfile** requires direct text manipulation, which is done using a regex pattern inside `addCustomMod` function. This process also requires that the CocoaPod dependency is inserted into the **Podfile** at a specific location, which is after the `use_expo_modules!` statement.
## `withDangerousMod` syntax and requirements
Using `withDangerousMod` requires certain parameters:
1. A native platform (**android** or **ios**)
2. An asynchronous function that receives `config` object with file system access
3. Relative file name/path to access inside the native directory
4. Reading the existing file, modifying its contents, and writing back to the file
5. (Optional) Log custom messages for success and failure state when a plugin executes during the prebuild process
The code snippet below provides a skeleton of the required field and how the config plugin can be structured when using `withDangerousMod`:
```tsx
import { ConfigPlugin, withDangerousMod } from 'expo/config-plugins';
import fs from 'fs/promises';
import path from 'path';
const myPlugin: ConfigPlugin = config => {
  return withDangerousMod(config, [
    'platform', // 1. "ios" | "android"
    async config => {
      // 2. Async modification function
      // 3. Build file paths
      const filePath = path.join(
        config.modRequest.platformProjectRoot, // Native project root
        'path/to/file' // Relative path to target file
      );
      try {
        // 4. Read existing file, modify its contents, and write back to the file
        let contents = await fs.readFile(filePath, 'utf8');
        contents = modifyContents(contents);
        await fs.writeFile(filePath, contents);
        // 5. Log success and failure states
        console.log('✅ Successfully modified file');
      } catch (error) {
        console.warn('⚠️ File modification failed:', error);
      }
      return config;
    },
  ]);
};
// Helper functions to use regex to modify the contents of the file
```
### Available paths in config plugins
Different path properties available in config plugins:
| Path                                          | Type      | Description                                                                                                                                                                                                                                            |
| --------------------------------------------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `config.modRequest.projectRoot`               | `string`  | Universal app project root directory where **package.json** is located. Used for resolving assets, reading **package.json**, and cross-platform operations. Always verify the directory exists and contains **package.json**.                          |
| `config.modRequest.platformProjectRoot`       | `string`  | Platform-specific project root (**projectRoot/android** or **projectRoot/ios**). Used for platform-specific file operations like modifying native configuration files. Ensure the platform directory exists relative to main `projectRoot`.            |
| `config.modRequest.projectName`               | `string`  | [iOS only] Project name component for constructing iOS file paths (for example, **projectRoot/ios/[projectName]/**). Used for iOS-specific file path construction. Only available on iOS platform and should match the actual Xcode project structure. |
| `config.modRequest.introspect`                | `boolean` | Whether running in introspection mode where no filesystem changes should be made. When `true`, mods should only read and analyze files without writing. Used during config analysis and validation.                                                    |
| `config.modRequest.ignoreExistingNativeFiles` | `boolean` | Whether to ignore existing native files. Used in template-based operations, particularly affects entitlements and other native configs to ensure alignment with prebuild expectations.                                                                 |
## Considerations when using a dangerous mod
When using a dangerous mod, consider the following:
- **Limited idempotency guarantees.** Unlike standard mods, which are generally idempotent and can work without the clean flag, dangerous mods are **rarely guaranteed to be idempotent**. This means running the same dangerous mod multiple times may produce different results or cause issues.
- **Experimental and prone to breakage.** Be careful using `withDangerousMod` as it is subject to change in the future. Test your dangerous mods thoroughly with each SDK release, as they are especially prone to breakage when native template changes occur.
- **Use standard mod plugins**. Both Android and iOS offer mod plugins like `withAndroidManifest`, `withPodfile`, `withPodfileProperties`, and so on, to perform common native file modifications. Only use a dangerous mod when there are no [existing mod plugins available](/config-plugins/mods/#available-mod-plugins) to handle your use case.
- **Don't assume a file exists**. Always check the native directory and the relative path to the file before reading/writing to it. If you use CNG, you can always run `npx expo prebuild` to create native **android** and **ios** directories and manually verify a file's existence.
- **Dangerous mods run first**. The order in which dangerous mods execute might be unreliable since dangerous mods run before other modifiers. This can affect the predictability of your build process and may cause conflicts with other modifications.


## Plugin development for libraries

Learn how to develop config plugins for Expo and React Native libraries.

Expo config plugins in a React Native library represent a transformative approach to automating native project configuration. Rather than requiring library users to manually edit native files, such as **AndroidManifest.xml**, **Info.plist**, and so on, you can provide a plugin that handles these configurations automatically during the prebuild process. This changes developer experience from error-prone manual setup to reliable, automated configuration that can work consistently across different projects.
This guide explains key configuration steps and strategies that you can use to implement a config plugin in your library.
## Strategic value of a config plugin in a library
Config plugins tend to solve interconnected problems that have historically made React Native library adoption more difficult than it should be. At times, when a user installs a React Native library, they face a complex set of native configuration steps that must be performed correctly for the library to function. These steps are platform-specific and sometimes require deep knowledge of native development concepts.
By creating a config plugin within your library, you can transform this complex-looking manual process into a simple configuration declaration that a user can apply in their Expo project's app config file (usually, **app.json**). This reduces the barrier to adoption for your library and simultaneously makes the setup process reliable.
Beyond immediate user experience improvements, config plugins enable compatibility with [Continuous Native Generation](/workflow/continuous-native-generation/), where native directories are generated automatically rather than checked into version control. Without a config plugin, developers who have adopted CNG face a difficult choice: either abandon the CNG workflow to manually configure native files, or invest significant effort in creating their own automation solutions. This creates a substantial barrier to library adoption in modern Expo development workflows.
## Project structure
A directory structure is the foundation for maintaining config plugins within your library. Below is an example directory structure:
```
└── ./
    ├── android/  # Android native module code
    │   ├── src/
    │   │   └── main/
    │   │       └── java/
    │   │           └── com/
    │   │               └── your-awesome-library
    │   └── build.gradle
    ├── ios/  # iOS native module code
    │   ├── YourAwesomeLibrary
    │   └── YourAwesomeLibrary.podspec
    ├── src/
    │   ├── index.ts  # Main library entry point
    │   ├── YourAwesomeLibrary.ts  # Core library implementation
    │   └── types.ts  # TypeScript type definitions
    ├── plugin/
    │   ├── src/
    │   │   ├── index.ts  # Plugin entry point
    │   │   ├── withAndroid.ts  # Android-specific configurations
    │   │   └── withIos.ts  # iOS-specific configurations
    │   ├── build/
    │   │   └──   # Compiled plugin output (generated)
    │   ├── __tests__/
    │   │   └──   # Plugin-specific tests
    │   └── tsconfig.json  # Plugin-specific TypeScript config
    ├── example/
    │   ├── app.json  # Example app configuration
    │   ├── App.tsx  # Example app implementation
    │   └── package.json  # Example app dependencies
    ├── __tests__/
    │   └──   # Main library tests
    ├── app.plugin.js  # Plugin entry point for Expo CLI
    ├── package.json  # Package configuration
    ├── tsconfig.json  # Main TypeScript configuration
    ├── jest.config.js  # Testing configuration
    └── README.md  # Documentation
```
The directory structure example above highlights the following organizational principles:
- **Root-level separation**: Clear boundaries between library code (**src**) and plugin implementation (**plugin**)
- **Plugin directory organization**: Platform-specific files (**withAndroid.ts**, **withIos.ts**) enable focused testing and maintenance
- **Build output management**: Compiled JavaScript and TypeScript declarations in **plugins/build/** directory
- **Testing**: Separate plugin tests from library tests to reflect different concerns.
## Installation and configuration for development
The most straightforward approach to leverage Expo's tooling is to use `expo` and [`expo-module-scripts`](https://www.npmjs.com/package/expo-module-scripts).
- `expo` provides a config plugin API and types that your plugin will use.
- `expo-module-scripts` provides build tooling specifically designed for Expo modules and config plugins. It also handles TypeScript compilation.
```sh
$ npx expo install package
```
When using `expo-module-scripts`, it requires the following **package.json** configuration. For any already existing script with the same script name, replace it.
```json package.json
{
  "scripts": {
    "build": "expo-module build",
    "build:plugin": "expo-module build plugin",
    "clean": "expo-module clean",
    "test": "expo-module test",
    "prepare": "expo-module prepare",
    "prepublishOnly": "expo-module prepublishOnly"
  },
  "devDependencies": {
    "expo": "^54.0.0"
  },
  "peerDependencies": {
    "expo": ">=54.0.0"
  },
  "peerDependenciesMeta": {
    "expo": {
      "optional": true
    }
  }
}
```
The next step is to add TypeScript support within the **plugins** directory. Open **plugins/tsconfig.json** file and add the following:
```json plugins/tsconfig.json
{
  "extends": "expo-module-scripts/tsconfig.plugin",
  "compilerOptions": {
    "outDir": "build",
    "rootDir": "src"
  },
  "include": ["./src"],
  "exclude": ["**/__mocks__/*", "**/__tests__/*"]
}
```
You also need to define the main entry point for your config plugin in the **app.plugin.js** file, which exports the compiled plugin code from the **plugin/build** directory:
```js app.plugin.js
module.exports = require('./plugin/build');
```
The above configuration is essential because when the Expo CLI looks for a plugin, it checks for this file in the project root of your library. The **plugin/build** directory contains the JavaScript files generated from your config plugin's TypeScript source code.
## Key implementation patterns
Essential patterns for a successful config plugin implementation include:
- **Plugin structure**: Core patterns that every plugin should follow
- **Platform-specific implementations**: Handle Android and iOS configurations effectively
- **Test strategies:** Validating your plugin code through testing
### Plugin structure and platform-specific implementation
Every config plugin follows the same pattern: receives configuration and parameters, applies transformations through mods, and returns the modified configuration. Consider the following core plugin structure looks like:
For Index file: 
```ts plugin/src/index.ts|collapseHeight=480
import { type ConfigPlugin, withAndroidManifest, withInfoPlist } from 'expo/config-plugins';
export interface YourLibraryPluginProps {
  customProperty?: string;
  enableFeature?: boolean;
}
const withYourLibrary: ConfigPlugin<YourLibraryPluginProps> = (config, props = {}) => {
  // Apply Android configurations
  config = withAndroidConfiguration(config, props);
  // Apply iOS configurations
  config = withIosConfiguration(config, props);
  return config;
};
export default withYourLibrary;
```
For Android: 
```ts plugin/src/withAndroid.ts
import { type ConfigPlugin, withAndroidManifest, AndroidConfig } from 'expo/config-plugins';
export const withAndroidConfiguration: ConfigPlugin<YourLibraryPluginProps> = (config, props) => {
  return withAndroidManifest(config, config => {
    const mainApplication = AndroidConfig.Manifest.getMainApplicationOrThrow(config.modResults);
    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'your_library_config_key',
      props.customProperty || 'default_value'
    );
    return config;
  });
};
```
For iOS: 
```ts plugin/src/withIos.ts
import { type ConfigPlugin, withInfoPlist } from 'expo/config-plugins';
export const withIosConfiguration: ConfigPlugin<YourLibraryPluginProps> = (config, props) => {
  return withInfoPlist(config, config => {
    config.modResults.YourLibraryCustomProperty = props.customProperty || 'default_value';
    if (props.enableFeature) {
      config.modResults.YourLibraryFeatureEnabled = true;
    }
    return config;
  });
};
```
### Testing strategies
Config plugin testing differs from regular library testing because you are testing configuration transformations rather than runtime behavior. Your plugin receives configuration objects and returns modified configuration objects.
Effective testing for a config plugin can be a combination of one or more of the following:
- **Unit testing:** Test configuration transformation logic with mocked Expo configuration objects
- **Cross-platform validation**: Use an example app to verify the actual prebuild output
- **Error condition testing**: Use error handling
Since unit tests focus on a plugin's transformation logic without involving the file system, you can use Jest to create and run mock configuration objects, pass them through your plugin, and verify expected modifications are made correctly. For example:
```ts plugin/__tests__/withYourLibrary.test.ts
import { withYourLibrary } from '../src';
describe('withYourLibrary', () => {
  it('should configure Android with custom property', () => {
    const config = {
      name: 'test-app',
      slug: 'test-app',
      platforms: ['android', 'ios'],
    };
    const result = withYourLibrary(config, {
      customProperty: 'test-value',
    });
    // Verify the plugin was applied correctly
    expect(result.plugins).toBeDefined();
  });
});
```
Errors should be handled gracefully inside your config plugin to provide clear feedback when a configuration fails. Use `try-catch` blocks to intercept errors early:
```ts plugin/src/index.ts
const withYourLibrary: ConfigPlugin<YourLibraryPluginProps> = (config, props = {}) => {
  try {
    // Validate configuration early
    validateProps(props);
    // Apply configurations
    config = withAndroidConfiguration(config, props);
    config = withIosConfiguration(config, props);
    return config;
  } catch (error) {
    // Re-throw with more context if needed
    throw new Error(`Failed to configure YourLibrary plugin: ${error.message}`);
  }
};
```
## Alternative build approaches
If your library doesn't use `expo-module-scripts`, you have two options:
### Add a plugin to your main package
For libraries using different build tools (like those created with `create-react-native-library`), add an **app.plugin.js** file and build it along with your main package:
```js app.plugin.js
module.exports = require('./lib/plugin');
```
### Create a separate plugin package
Some libraries distribute their config plugin as a separate package from their main library. This approach allows you to maintain your config plugin separately from the rest of your native module. You need to include export in **app.plugin.js** and compile the **build** directory from your plugin.
```js app.plugin.js
{
  "name": "your-library-expo-plugin",
  "main": "app.plugin.js",
  "files": ["app.plugin.js", "build/"],
  "peerDependencies": {
    "expo": "*",
    "your-library": "*"
  }
}
```
## Plugin development best practices
- **Instructions in your README**: If the plugin is tied to a React Native module, then you should document manual setup instructions for the package. If anything goes wrong with the plugin, developers should be able to manually add the project modifications that were automated by the plugin. This also allows you to support projects that are not using [CNG](/workflow/continuous-native-generation/).
  - Document the available properties for the plugin, specifying if any of the properties are required.
  - If possible, plugins should be idempotent, meaning the changes they make are the same whether they are run on a fresh native project template or run again on a project template where its changes already exist. This allows developers to run `npx expo prebuild` without the `--clean` flag to sync changes to the config, rather than recreating the native project entirely. This may be more difficult with dangerous mods.
- **Naming conventions**: Use `withFeatureName` for the plugin function name if it applies to all platforms. If the plugin is platform-specific, use a camel case naming with the platform right after "with". For example, `withAndroidSplash`, `withIosSplash`.
- **Leverage built-in plugins**: If there's already a configuration available in [app config](/versions/latest/config/app/) and [prebuild config](https://github.com/expo/expo/blob/main/packages/%40expo/prebuild-config/src/plugins/withDefaultPlugins.ts), you don't need to write a config plugin for it.
- **Split up plugins by platform**: When using functions within the config plugin, split them by platform. For example, `withAndroidSplash`, `withIosSplash`. This makes using the `--platform` flag in `npx expo prebuild` a bit easier to follow in `EXPO_DEBUG` mode, as the logging will show which platform-specific functions are being executed.
- **Unit test your plugin**: Write Jest tests for complex modifications. If your plugin requires access to the filesystem,
  use a mock system (we strongly recommend [`memfs`](https://www.npmjs.com/package/memfs)), you can see examples of this in the [`expo-notifications`](https://github.com/expo/expo/blob/fc3fb2e81ad3a62332fa1ba6956c1df1c3186464/packages/expo-notifications/plugin/src/__tests__/withNotificationsAndroid-test.ts#L34) plugin tests.
  - Notice the root [\*\*/\_\_mocks\_\_/\*\*/\*](https://github.com/expo/expo/tree/main/packages/expo-notifications/plugin/__mocks__) directory and [**plugin/jest.config.js**](https://github.com/expo/expo/tree/main/packages/expo-notifications/plugin/jest.config.js).
- A TypeScript plugin is always preferable to a JavaScript due to added type-safety. Check out the [`expo-module-scripts` plugin](https://github.com/expo/expo/tree/main/packages/expo-module-scripts#-config-plugin) tooling for more info.
- Do not modify the `sdkVersion` via a config plugin, this can break commands like `expo install` and cause other unexpected issues.


## Developing and debugging a plugin

Learn about development best practices and debugging techniques for Expo config plugins.

Developing a plugin is a great way to extend the Expo ecosystem. However, there are times you'll want to debug your plugin. This page provides some of the best practices for developing and debugging a plugin.
## Plugin development
> Use [modifier previews](https://github.com/expo/vscode-expo#expo-preview-modifier) to debug the results of your plugin live.
To make plugin development easier, we've added plugin support to [`expo-module-scripts`](https://www.npmjs.com/package/expo-module-scripts).
Refer to the [config plugins guide](https://github.com/expo/expo/tree/main/packages/expo-module-scripts#-config-plugin) for more info on using TypeScript, and Jest to build plugins.
### Install dependencies
Use the following dependencies in a library that provides a config plugin:
```json package.json
{
  "dependencies": {},
  "devDependencies": {
    "expo": "^54.0.0"
  },
  "peerDependencies": {
    "expo": ">=54.0.0"
  },
  "peerDependenciesMeta": {
    "expo": {
      "optional": true
    }
  }
}
```
- You may update the exact version of `expo` to build against a specific version.
- For simple config plugins that depend on core, stable APIs, such as a plugin that only modifies **AndroidManifest.xml** or **Info.plist**, you can use a loose dependency such as in the example above.
- You may also want to install [`expo-module-scripts`](https://github.com/expo/expo/blob/main/packages/expo-module-scripts/README.md) as a development dependency, but it's not required.
### Import the config plugins package
The `expo/config-plugins` and `expo/config` packages are re-exported from the `expo` package.
```js
const { ... } = require('expo/config-plugins');
const { ... } = require('expo/config');
```
Importing through the `expo` package ensures that you are using the version of the `expo/config-plugins` and `expo/config` packages that are depended on by the `expo` package.
If you do not import the package through the `expo` re-export in this way, you may accidentally be importing an incompatible version
(depending on the implementation details of module hoisting in the package manager used by the developer consuming the module) or be unable to import the module at all (if using "plug and play" features of a package manager such as Yarn Berry or pnpm).
Config types are exported directly from `expo/config`, so there is no need to install or import from `expo/config-types`:
```ts
import { ExpoConfig, ConfigContext } from 'expo/config';
```
### Best practices for mods
- Avoid regex: [static modification](#static-modification) is key. If you want to modify a value in an Android gradle file, consider using `gradle.properties`. If you want to modify some code in the Podfile, consider writing to JSON and having the Podfile read the static values.
- Avoid performing long-running tasks like making network requests or installing Node modules in mods.
- Do not add interactive terminal prompts in mods.
- Generate, move, and delete new files in dangerous mods only. Failing to do so will break [introspection](#introspection).
- Utilize built-in config plugins like `withXcodeProject` to minimize the amount of times a file is read and parsed.
- Stick with the XML parsing libraries that prebuild uses internally, this helps prevent changes where code is rearranged needlessly.
## Plugin structure and scaffolding
### Versioning
By default, `npx expo prebuild` runs transformations on a [source template](https://github.com/expo/expo/tree/main/templates/expo-template-bare-minimum) associated with the Expo SDK version that a project is using. The SDK version is defined in the **app.json** or inferred from the installed version of `expo` that the project has.
When Expo SDK upgrades to a new version of React Native for instance, the template may change significantly to account for changes in React Native or new releases of Android or iOS.
If your plugin is mostly using [static modifications](#static-modification) then it will usually work well across SDK versions. If it's using a regular expression to transform application code, then you'll definitely want to document which Expo SDK version your plugin is intended for. During the SDK release cycle, there is a [beta period](https://github.com/expo/expo/blob/main/guides/releasing/Release%20Workflow.md#stage-4---beta-release) where you can test if your plugin works with the new version before it's released.
### Plugin properties
Properties are used to customize the way a plugin works during prebuild. They must always be static values (no functions, or promises). Consider the following types:
```ts
type StaticValue = boolean | number | string | null | StaticArray | StaticObject;
type StaticArray = StaticValue[];
interface StaticObject {
  [key: string]: StaticValue | undefined;
}
```
Static properties are required because the app config must be serializable to JSON for use as the app manifest.
If possible, attempt to make your plugin work without props, this will help resolution tooling like [`expo install`](#expo-install) or [VS Code Expo Tools](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-tools) work better. Remember that every property you add increases complexity, making it harder to change in the future and increases the amount of features you'll need to test. Good default values are preferred over mandatory configuration when feasible.
## Development environment
### Tooling
We highly recommend installing the [Expo Tools VS Code extension](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-tools) as this will perform automatic validation on the plugins and surface error information along with other quality of life improvements for Config Plugin development.
### Set up a playground environment
You can develop plugins easily using JS, but if you want to set up Jest tests and use TypeScript, you will want a monorepo.
A monorepo will enable you to work on a node module and import it in your app config like you would if it were published to npm. Expo config plugins have full monorepo support built-in so all you need to do is set up a project.
In your monorepo's `packages/` directory, create a module, and [bootstrap a config plugin](https://github.com/expo/expo/tree/main/packages/expo-module-scripts#-config-plugin) in it.
### Manually run a plugin
If you aren't comfortable setting up a monorepo, you can try manually running a plugin:
- Run `npm pack` in the package with the config plugin
- In your test project, run `npm install path/to/react-native-my-package-1.0.0.tgz`, this will add the package to your **package.json** `dependencies` object.
- Add the package to the `plugins` array in your **app.json**: `{ "plugins": ["react-native-my-package"] }`
  - If you have [VS Code Expo Tools](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-tools) installed, autocomplete should work for the plugin.
- If you need to update the package, change the `version` in the package's **package.json** and repeat the process.
## Modifying native files with plugins
### Modify AndroidManifest.xml
Packages should attempt to use the built-in **AndroidManifest.xml** [merging system](https://developer.android.com/studio/build/manage-manifests) before using a config plugin. This can be used for static, non-optional features like permissions. This will ensure features are merged during build-time and not prebuild-time, which minimizes the possibility of the configuration being missed due to users forgetting to prebuild. The drawback is that users cannot use [introspection](#introspection) to preview the changes and debug any potential issues.
Here is an example of a package's **AndroidManifest.xml**, which injects a required permission:
```xml AndroidManifest.xml
<!-- @info Include <code>xmlns:android="..."</code> to use <code>android:*</code> properties like <code>android:name</code> in your manifest. -->
<manifest package="expo.modules.filesystem" xmlns:android="http://schemas.android.com/apk/res/android">
  <!-- @end -->
  <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
```
If you're building a plugin for your local project, or if your package needs more control, then you should implement a plugin.
You can use built-in types and helpers to ease the process of working with complex objects.
Here's an example of adding a `<meta-data android:name="..." android:value="..."/>` to the default `<application android:name=".MainApplication" />`.
```ts my-config-plugin.ts
import { AndroidConfig, ConfigPlugin, withAndroidManifest } from 'expo/config-plugins';
import { ExpoConfig } from 'expo/config';
// Using helpers keeps error messages unified and helps cut down on XML format changes.
const { addMetaDataItemToMainApplication, getMainApplicationOrThrow } = AndroidConfig.Manifest;
export const withMyCustomConfig: ConfigPlugin = config => {
  return withAndroidManifest(config, async config => {
    // Modifiers can be async, but try to keep them fast.
    config.modResults = await setCustomConfigAsync(config, config.modResults);
    return config;
  });
};
// Splitting this function out of the mod makes it easier to test.
async function setCustomConfigAsync(
  config: Pick<ExpoConfig, 'android'>,
  androidManifest: AndroidConfig.Manifest.AndroidManifest
): Promise<AndroidConfig.Manifest.AndroidManifest> {
  const appId = 'my-app-id';
  // Get the <application /> tag and assert if it doesn't exist.
  const mainApplication = getMainApplicationOrThrow(androidManifest);
  addMetaDataItemToMainApplication(
    mainApplication,
    // value for `android:name`
    'my-app-id-key',
    // value for `android:value`
    appId
  );
  return androidManifest;
}
```
### Modify Info.plist
Using the `withInfoPlist` is a bit safer than statically modifying the `expo.ios.infoPlist` object in the **app.json** because it reads the contents of the Info.plist and merges it with the `expo.ios.infoPlist`, this means you can attempt to keep your changes from being overwritten.
Here's an example of adding a `GADApplicationIdentifier` to the **Info.plist**:
```ts my-config-plugin.ts
import { ConfigPlugin, withInfoPlist } from 'expo/config-plugins';
// Pass `<string>` to specify that this plugin requires a string property.
export const withCustomConfig: ConfigPlugin<string> = (config, id) => {
  return withInfoPlist(config, config => {
    config.modResults.GADApplicationIdentifier = id;
    return config;
  });
};
```
### Modify iOS Podfile
The iOS **Podfile** is the config file for CocoaPods, the dependency manager on iOS. It is similar to **package.json** for iOS.
The **Podfile** is a Ruby file, which means you **cannot** safely modify it from Expo config plugins and should opt for another approach, such as [Expo Autolinking](/modules/autolinking) hooks.
We do expose one mechanism for safely interacting with the Podfile, but it's very limited.
The versioned [template Podfile](https://github.com/expo/expo/tree/main/templates/expo-template-bare-minimum/ios/Podfile) is hard coded to read
from a static JSON file **Podfile.properties.json**, we expose a mod (`ios.podfileProperties`, `withPodfileProperties`) to safely read and write from this file.
This is used by [expo-build-properties](/versions/latest/sdk/build-properties) and to configure the JavaScript engine.
### Add plugins to `pluginHistory`
`_internal.pluginHistory` was created to prevent duplicate plugins from running while migrating from legacy UNVERSIONED plugins to versioned plugins.
```ts my-config-plugin.ts
import { ConfigPlugin, createRunOncePlugin } from 'expo/config-plugins';
// Keeping the name, and version in sync with it's package.
const pkg = require('my-cool-plugin/package.json');
const withMyCoolPlugin: ConfigPlugin = config => config;
// A helper method that wraps `withRunOnce` and appends items to `pluginHistory`.
export default createRunOncePlugin(
  // The plugin to guard.
  withMyCoolPlugin,
  // An identifier used to track if the plugin has already been run.
  pkg.name,
  // Optional version property, if omitted, defaults to UNVERSIONED.
  pkg.version
);
```
### Configure Android app startup
You may find that your project requires configuration to be setup before the JS engine has started.
For example, in `expo-splash-screen` on Android, we need to specify the resize mode in the **MainActivity.java**'s `onCreate` method.
Instead of attempting to dangerously regex these changes into the `MainActivity` via a dangerous mod, we use a system of lifecycle hooks and static settings
to safely ensure the feature works across all supported Android languages (Java, Kotlin), versions of Expo, and combination of config plugins.
This system is made up of three components:
- `ReactActivityLifecycleListeners`: An interface exposed by `expo-modules-core` to get a native callback when the project `ReactActivity`'s `onCreate` method is invoked.
- `withStringsXml`: A mod exposed by `expo/config-plugins` which writes a property to the Android **strings.xml** file, the library can safely read the strings.xml value and do initial setup. The string XML values follow a designated format for consistency.
- `SingletonModule` (optional): An interface exposed by `expo-modules-core` to create a shared interface between native modules and `ReactActivityLifecycleListeners`.
Consider this example: We want to set a custom "value" string to a property on the Android `Activity`, directly after the `onCreate` method was invoked.
We can do this safely by creating a node module `expo-custom`, implementing `expo-modules-core`, and Expo config plugins:
First, we register the `ReactActivity` listener in our Android native module, this will only be invoked if the user has `expo-modules-core` support, setup in their project (default in projects bootstrapped with Expo CLI, Create React Native App, Ignite CLI, and Expo prebuilding).
```kotlin expo-custom/android/src/main/java/expo/modules/custom/CustomPackage.kt
package expo.modules.custom
import android.content.Context
import expo.modules.core.BasePackage
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class CustomPackage : BasePackage() {
  override fun createReactActivityLifecycleListeners(activityContext: Context): List<ReactActivityLifecycleListener> {
    return listOf(CustomReactActivityLifecycleListener(activityContext))
  }
  // ...
}
```
Next we implement the `ReactActivity` listener, this is passed the `Context` and is capable of reading from the project **strings.xml** file.
```kotlin expo-custom/android/src/main/java/expo/modules/custom/CustomReactActivityLifecycleListener.kt
package expo.modules.custom
import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.util.Log
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class CustomReactActivityLifecycleListener(activityContext: Context) : ReactActivityLifecycleListener {
  override fun onCreate(activity: Activity, savedInstanceState: Bundle?) {
    // Execute static tasks before the JS engine starts.
    // These values are defined via config plugins.
    var value = getValue(activity)
    if (value != "") {
      // Do something to the Activity that requires the static value...
    }
  }
  // Naming is node module name (`expo-custom`) plus value name (`value`) using underscores as a delimiter
  // i.e. `expo_custom_value`
  // `@expo/vector-icons` + `iconName` -> `expo__vector_icons_icon_name`
  private fun getValue(context: Context): String = context.getString(R.string.expo_custom_value).toLowerCase()
}
```
We must define default **string.xml** values which the user will overwrite locally by using the same `name` property in their **strings.xml** file.
```xml expo-custom/android/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="expo_custom_value" translatable="false"></string>
</resources>
```
At this point, bare users can configure this value by creating a string in their local **strings.xml** file (assuming they also have `expo-modules-core` support setup):
```xml ./android/app/src/main/res/values/strings.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="expo_custom_value" translatable="false">I Love Expo</string>
</resources>
```
For managed users, we can expose this functionality (safely!) via an Expo config plugin:
```js expo-custom/app.plugin.js
const { AndroidConfig, withStringsXml } = require('expo/config-plugins');
function withCustom(config, value) {
  return withStringsXml(config, config => {
    config.modResults = setStrings(config.modResults, value);
    return config;
  });
}
function setStrings(strings, value) {
  // Helper to add string.xml JSON items or overwrite existing items with the same name.
  return AndroidConfig.Strings.setStringItem(
    [
      // XML represented as JSON
      // <string name="expo_custom_value" translatable="false">value</string>
      { $: { name: 'expo_custom_value', translatable: 'false' }, _: value },
    ],
    strings
  );
}
```
Managed Expo users can now interact with this API like so:
```json app.json
{
  "expo": {
    "plugins": [["expo-custom", "I Love Expo"]]
  }
}
```
By re-running `npx expo prebuild -p` (`eas build -p android`, or `npx expo run:ios`) the user can now see the changes, safely applied in their managed project!
As you can see from the example, we rely heavily on application code (expo-modules-core) to interact with application code (the native project). This ensures that our config plugins are safe and reliable, hopefully for a very long time!
## Debugging config plugins
You can debug config plugins by running `EXPO_DEBUG=1 expo prebuild`. If `EXPO_DEBUG` is enabled, the plugin stack logs will be printed, these are useful for viewing which mods ran, and in what order they ran in. To view all static plugin resolution errors, enable `EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS`, this should only be needed for plugin authors. By default, some automatic plugin errors are hidden because they're usually related to versioning issues and aren't very helpful (that is, legacy package doesn't have a config plugin yet).
Running `npx expo prebuild --clean` will remove the generated native directories before compiling.
You can also run `npx expo config --type prebuild` to print the results of the plugins with the mods unevaluated (no code is generated).
Expo CLI commands can be profiled using `EXPO_PROFILE=1`.
## Introspection
Introspection is an advanced technique used to read the evaluated results of modifiers without generating any code in the project.
This can be used to quickly debug the results of [static modifications](#static-modification) without needing to run prebuild.
You can interact with introspection live, by using the [preview feature](https://github.com/expo/vscode-expo#expo-preview-modifier) of `vscode-expo`.
You can try introspection by running `expo config --type introspect` in a project.
Introspection only supports a subset of modifiers:
- `android.manifest`
- `android.gradleProperties`
- `android.strings`
- `android.colors`
- `android.colorsNight`
- `android.styles`
- `ios.infoPlist`
- `ios.entitlements`
- `ios.expoPlist`
- `ios.podfileProperties`
> Introspection only works on safe modifiers (static files like JSON, XML, plist, properties), except `ios.xcodeproj` which often requires file system changes, making it non idempotent.
Introspection works by creating custom base mods that work like the default base mods, except they don't write the `modResults` to disk at the end.
Instead of persisting, they save the results to the app config under `_internal.modResults`, followed by the name of the mod
such as the `ios.infoPlist` mod saves to `_internal.modResults.ios.infoPlist: {}`.
As a real-world example, introspection is used by `eas-cli` to determine what the final iOS entitlements will be in a managed app, so it can sync them with the Apple Developer Portal before building. Introspection can also be used as a handy debugging and development tool.
## Legacy plugins
To make `eas build` work the same as the classic `expo build` service, we added support for "legacy plugins" which are applied automatically to a project when they're installed in the project.
For instance, say a project has `expo-camera` installed but doesn't have `plugins: ['expo-camera']` in their **app.json**.
Expo CLI would automatically add `expo-camera` to the plugins to ensure that the required camera and microphone permissions are added to the project.
The user can still customize the `expo-camera` plugin by adding it to the `plugins` array manually, and the manually defined plugins will take precedence over the automatic plugins.
You can debug which plugins were added by running `expo config --type prebuild` and seeing the `_internal.pluginHistory` property.
This will show an object with all plugins that were added using `withRunOnce` plugin from `expo/config-plugins`.
Notice that `expo-location` uses `version: '11.0.0'`, and `react-native-maps` uses `version: 'UNVERSIONED'`. This means the following:
- `expo-location` and `react-native-maps` are both installed in the project.
- `expo-location` is using the plugin from the project's `node_modules/expo-location/app.plugin.js`
- The version of `react-native-maps` installed in the project doesn't have a plugin, so it's falling back on the unversioned plugin that is shipped with `expo-cli` for legacy support.
```json
{
  _internal: {
    pluginHistory: {
      'expo-location': {
        name: 'expo-location',
        version: '11.0.0',
      },
      'react-native-maps': {
        name: 'react-native-maps',
        version: 'UNVERSIONED',
      },
    },
  },
};
```
For the most _stable_ experience, you should try to have no `UNVERSIONED` plugins in your project. This is because the `UNVERSIONED` plugin may not support the native code in your project.
For instance, say you have an `UNVERSIONED` Facebook plugin in your project, if the Facebook native code or plugin has a breaking change, that will break the way your project prebuilds and cause it to error on build.
## Static modification
Plugins can transform application code with regular expressions, but these modifications are dangerous if the template changes over time then the regex becomes hard to predict (similarly if the user modifies a file manually or uses a custom template). Here are some examples of files you shouldn't modify manually, and alternatives.
### Android Gradle Files
Gradle files are written in either Groovy or Kotlin. They are used to manage dependencies, versioning, and other settings in the Android app.
Instead of modifying them directly with the `withProjectBuildGradle`, `withAppBuildGradle`, or `withSettingsGradle` mods, utilize the static `gradle.properties` file.
The `gradle.properties` is a static key/value pair that groovy files can read from. For example, say you wanted to control some toggle in Groovy:
```properties gradle.properties
# @info Safely modified using the <code>withGradleProperties()</code> mod. #
expo.react.jsEngine=hermes
# @end #
```
Then later in a Gradle file:
```groovy app/build.gradle
```
- For keys in the `gradle.properties`, use camel case separated by `.`s, and usually starting with the `expo` prefix to denote that the property is managed by prebuild.
- To access the property, use one of two global methods:
  - `property`: Get a property, throw an error if the property is not defined.
  - `findProperty`: Get a property without throwing an error if the property is missing. This can often be used with the `?:` operator to provide a default value.
Generally, you should only interact with the Gradle file via Expo [Autolinking](/more/glossary-of-terms/#autolinking), this provides a programmatic interface with the project files.
### iOS AppDelegate
Some modules may need to add delegate methods to the project AppDelegate. This can be done safely by using [AppDelegate subscribers](/modules/appdelegate-subscribers/) or dangerously via the `withAppDelegate` mod (_strongly discouraged_).
Using AppDelegate subscribers allows native Expo modules to react to important events in a safe and reliable way.
Below are some examples of the AppDelegate subscribers in action. Additionally, you will find many examples in community repositories on GitHub ([one such example](https://github.com/bamlab/react-native-app-security/blob/c1a861cbd348f404ec18ffae90d1c9bdc66bc00d/ios/RNASAppLifecyleDelegate.swift)).
- `expo-linking`: [**LinkingAppDelegateSubscriber.swift**](https://github.com/expo/expo/blob/b4ca25a4319d7148258ebd5121d1df40a3b1333e/packages/expo-linking/ios/LinkingAppDelegateSubscriber.swift#L14) (openURL)
- `expo-notifications`: [**NotificationsAppDelegateSubscriber.swift**](https://github.com/expo/expo/blob/bd469e421856f348d539b1b57325890147935dbc/packages/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.m) (didRegisterForRemoteNotificationsWithDeviceToken, didFailToRegisterForRemoteNotificationsWithError, didReceiveRemoteNotification)
### iOS CocoaPods Podfile
The **Podfile** can be customized with a regular expression (this is considered dangerous because these types of changes do not compose well and multiple changes are likely to collide), but it's more reliable to instead set configuration values in JSON file called **Podfile.properties.json**. See how `podfile_properties` is used to customize the **Podfile** below:
```ruby Podfile
require 'json'
# @info Import a JSON file and parse it in Ruby #
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}
# @end #
platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'
target 'yolo27' do
  use_expo_modules!
  # ...
  # podfile_properties['your_property']
end
```
Generally, you should only interact with the Podfile via Expo [Autolinking](/more/glossary-of-terms/#autolinking), this provides a programmatic interface with the project files.
### Custom base modifiers
The Expo CLI `npx expo prebuild` command uses [`@expo/prebuild-config`](https://github.com/expo/expo/tree/main/packages/%40expo/prebuild-config) to get the default base modifiers. These defaults only manage a subset of common files, if you want to manage custom files you can do that locally by adding new base modifiers.
For example, say you wanted to add support for managing the `ios/*/AppDelegate.h` file, you could do this by adding a `ios.appDelegateHeader` modifier.
> This example uses `tsx` for simple local TypeScript support, this isn't strictly necessary. [Learn more](/guides/typescript/#appconfigjs).
```ts withAppDelegateHeaderBaseMod.ts
import { ConfigPlugin, IOSConfig, Mod, withMod, BaseMods } from 'expo/config-plugins';
import fs from 'fs';
/**
 * A plugin which adds new base modifiers to the prebuild config.
 */
export function withAppDelegateHeaderBaseMod(config) {
  return BaseMods.withGeneratedBaseMods<'appDelegateHeader'>(config, {
    platform: 'ios',
    providers: {
      // Append a custom rule to supply AppDelegate header data to mods on `mods.ios.appDelegateHeader`
      appDelegateHeader: BaseMods.provider<IOSConfig.Paths.AppDelegateProjectFile>({
        // Get the local filepath that should be passed to the `read` method.
        getFilePath({ modRequest: { projectRoot } }) {
          const filePath = IOSConfig.Paths.getAppDelegateFilePath(projectRoot);
          // Replace the .m with a .h
          if (filePath.endsWith('.m')) {
            return filePath.substr(0, filePath.lastIndexOf('.')) + '.h';
          }
          // Possibly a Swift project...
          throw new Error(`Could not locate a valid AppDelegate.h at root: "${projectRoot}"`);
        },
        // Read the input file from the filesystem.
        async read(filePath) {
          return IOSConfig.Paths.getFileInfo(filePath);
        },
        // Write the resulting output to the filesystem.
        async write(filePath: string, { modResults: { contents } }) {
          await fs.promises.writeFile(filePath, contents);
        },
      }),
    },
  });
}
/**
 * (Utility) Provides the AppDelegate header file for modification.
 */
export const withAppDelegateHeader: ConfigPlugin<Mod<IOSConfig.Paths.AppDelegateProjectFile>> = (
  config,
  action
) => {
  return withMod(config, {
    platform: 'ios',
    mod: 'appDelegateHeader',
    action,
  });
};
// (Example) Log the contents of the modifier.
export const withSimpleAppDelegateHeaderMod = config => {
  return withAppDelegateHeader(config, config => {
    console.log('modify header:', config.modResults);
    return config;
  });
};
```
To use this new base mod, add it to the plugins array. The base mod **MUST** be added last after all other plugins that use the mod, this is because it must write the results to disk at the end of the process.
```js app.config.js
// Required for external files using TS
require('tsx/cjs');
import {
  withAppDelegateHeaderBaseMod,
  withSimpleAppDelegateHeaderMod,
} from './withAppDelegateHeaderBaseMod.ts';
export default ({ config }) => {
  if (!config.plugins) config.plugins = [];
  config.plugins.push(
    withSimpleAppDelegateHeaderMod,
    // Base mods MUST be last
    withAppDelegateHeaderBaseMod
  );
  return config;
};
```
For more info, see [the PR that adds support](https://github.com/expo/expo-cli/pull/3852) for this feature.
## expo install
When a node module is installed with the `npx expo install` command, if it includes a config plugin, it will be added to the project's app config automatically. This makes setup easier and helps prevent users from forgetting to add a plugin. However, this does come with a couple of caveats:
1. `npx expo install` only adds config plugins using the root **app.config.js** file automatically to the app manifest. This rule was added to prevent popular packages like `lodash` from being mistaken for a config plugin and breaking the prebuild.
2. There is currently no mechanism for detecting if a config plugin has mandatory props. Because of this, `expo install` will only add the plugin, and not attempt to add any extra props. For example, `expo-camera` has optional extra props, so `plugins: ['expo-camera']` is valid, but if it had mandatory props, then `expo-camera` would throw an error.
3. Plugins can only be automatically added when the user's project uses a static app config (**app.json** and **app.config.json**). If the user runs `expo install expo-camera` in a project with an **app.config.js**, they'll see a warning like:
```sh
Cannot automatically write to dynamic config at: app.config.js
Please add the following to your app config
{
  "plugins": [
    "expo-camera"
  ]
}
```


## Using patch-project

Learn about how to use patch-project to create generate, apply, and preserve native changes in your Expo project.

> **important** **Note**: `patch-project` is an alpha feature.
`patch-project` is an Expo config plugin and command-line interface (CLI) tool that generates and applies patches to preserve native changes after running `npx expo prebuild`. This tool is useful for native app developers who want to preserve customizations without needing to know how to write a config plugin, effectively generating an automatic solution that works with [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/).
This guide explains how to use `patch-project`, when to use it, and its limitations.
## How patch-project works
`patch-project` uses an approach to generate and automatically apply patches, which is inspired by Git. Using this command line tool requires the following steps in your project:
### Installation
To get started, you need to install the tool in your project:
```sh
$ npx expo install patch-project
```
This command will automatically add the `patch-project` config plugin to your [app config](/workflow/configuration/):
```json app.json
{
  "expo": {
    "plugins": [
      "patch-project"
    ]
  }
}
```
### Generate patches from existing customizations
Let's assume you manually modified native directories (**android** and **ios**) in your project. To generate patches for these native directories, you can run the following command:
```sh
$ npx patch-project
```
> **info** **Note**: In scenarios where you want to generate patches for a specific platform, you can use the `--platform` option and run `npx patch-project --platform android` or `npx patch-project --platform ios`.
These patches, when generated, are saved in the **cng-patches** directory.
```
└── ./
    ├── app.json  # with patch-project plugin
    ├── cng-patches/
    │   ├── android+eee880ad7b07965271d2323f7057a2b4.patch  # patch for android directory
    │   └── ios+eee880ad7b07965271d2323f7057a2b4.patch  # patch for ios directory
    ├── package.json
    └── ...  # other project files
```
Each file will be prefixed with a platform's name followed by a checksum value. For example:
```bash
ios+eee880ad7b07965271d2323f7057a2b4.patch
```
### Apply patches during prebuild
Once you have generated patches, they are automatically applied when subsequently running the `npx expo prebuild` command. The `patch-project` config plugin detects the existing patches and applies them to restore your customizations.
## When to use patch-project
You can use `patch-project` in the following scenarios:
- **Migrating existing React Native apps** that are complex because they contain extensive native customizations and re-creating these native customizations as config plugins would be time-consuming.
- **Preserving manual changes** made to **android** and/or **ios** directories while transitioning to adopt Continuous Native Generation (CNG) in your Expo project.
- **Quick prototyping** when you need to test native changes before writing config plugins.
- **Patches are applied automatically** when running the `npx expo prebuild` command subsequently. This is an advantage over tools like `patch-package` (commonly used for generating patches for npm libraries), which do not preserve and automatically apply patches during the prebuild process.
## Limitations and considerations
Patches may become invalid during Expo SDK version upgrades because:
- **Template and/or file structure changes**: The prebuild template evolves between SDK versions with new changes and file updates in native directories. This will affect the already generated diff in the **cng-patches** directory, which may no longer apply.
- **Plugin conflicts**: CNG patches can be dangerous and may break when other plugins modify the same files. For example, if you add a new plugin that updates **MainApplication.kt** and conflicts with your existing patches, the patches may no longer apply correctly. In such cases, you may need to regenerate patches.
- **iOS .pbxproj changes**: In iOS projects, applying patches to **.pbxproj** files can be fragile since this file contains UUIDs and running a command like `npx expo prebuild --clean` can change these IDs. For example, if you're adding a widget extension or making other project configuration changes, patch-based approaches may not work reliably. You can review the generated **cng-patches/ios-\*** and keep only the necessary patch. Having the patch as minimal as possible would reduce the risk of failures when applying patches.
It is recommended to regenerate patches after each SDK upgrade.


# Debugging

## Errors and warnings

Learn about Redbox errors and stack traces in your Expo project.

When developing an application using Expo, you'll encounter a **Redbox** error or **Yellowbox** warning. These logging experiences are provided by [LogBox in React Native](https://reactnative.dev/blog/2020/07/06/version-0.63).
## Redbox error and Yellowbox warning
A Redbox error is displayed when a fatal error prevents your app from running. A Yellowbox warning is displayed to inform you that there is a possible issue and you should probably resolve it before shipping your app.
You can also create warnings and errors on your own with `console.warn("Warning message")` and `console.error("Error message")`. Another way to trigger the redbox is to throw an error and not catch it: `throw Error("Error message")`.
> This is a brief introduction to debugging a React Native app with Expo CLI. For in-depth information, see [Debugging](/debugging/runtime-issues/).
## Stack traces
When you encounter an error during development, you'll see the error message and a **stack trace**, which is a report of the recent calls your application made when it crashed. This stack trace is shown both in your terminal and the Expo Go app or if you have created a development build.
This stack trace is **extremely valuable** since it gives you the location of the error's occurrence. For example, in the following image, the error comes from the file **HomeScreen.js** and is caused on line 7 in that file.
When you look at that file, on line 7, you will see that a variable called `renderDescription` is referenced. The error message describes that the variable is not found because the variable is not declared in **HomeScreen.js**. This is a typical example of how helpful error messages and stack traces can be if you take the time to decipher them.
Debugging errors is one of the most frustrating but satisfying parts of development. Remember that you're never alone. The **Expo community** and the React and React Native communities are great resources for help when you get stuck. There's a good chance someone else has run into your exact error. Make sure to read the documentation, search the [forums](https://chat.expo.dev/), [GitHub issues](https://github.com/expo/expo/issues/), and [Stack Overflow](https://stackoverflow.com/).


## Debugging runtime issues

Learn about different techniques available to debug your Expo project.

Whether you're developing your app locally, sending it out to select beta testers, or launching your app live to the app stores, you'll always find yourself debugging issues. It's useful to split errors into two categories:
- Errors you encounter in the development
- Errors you (or your users) encounter in production
Let's go through recommended practices when dealing with each of the above situations.
## Development errors
They are common errors that you encounter while developing your app. Delving into them isn't always straightforward. Usually, debugging when running your app with [Expo CLI](/more/expo-cli/) is enough.
One way you can debug these issues is by looking at the [stack trace](/debugging/errors-and-warnings/#stack-traces). However, in some scenarios, looking at the stack trace isn't enough as the error message traced might be a little more cryptic. For such errors, follow the steps below:
- Search for the error message in Google and [Stack Overflow](https://stackoverflow.com/questions), it's likely you're not the first person to ever run into this.
- **Isolate the code that's throwing the error**. This step is _vital_ in fixing obscure errors. To do this:
  - Revert to a working version of your code. This may even be a completely blank `npx create-expo-app` project.
  - Apply your recent changes piece by piece, until it breaks.
  - If the code you're adding in each "piece" is complex, you may want to simplify what you're doing. For example, if you use a state management library such as Redux, you can try removing that from the equation completely to see if the issue lies in your state management (which is common in React apps).
  - This should narrow down the possible sources of the error, and provide you with more information to search the internet for others who have had the same problem.
- Use breakpoints (or `console.log`s) to check and make sure a certain piece of code is being run, or that a variable has a certain value. Using `console.log` for debugging isn't considered the best practice, however, it's fast, easy, and oftentimes provides some illuminating information.
Simplifying code as much as possible to track down the source of error is a great way to debug your app and it gets exponentially easier. That's why many open-source repositories require a [minimal reproducible example](https://stackoverflow.com/help/minimal-reproducible-example) when you open an issue. It ensures you have isolated the issue and identified exactly where the problem occurs. If your app is too large and complex to do that, try and extract the functionality you're trying to add in a blank `npx create-expo-app` project, and go from there.
### Native debugging
You can perform full native debugging with Android Studio and Xcode by generating source code locally and building from that source.
#### Android Studio
Step 1: 
Generate the native code for your project by running the following command:
```sh
$ npx expo prebuild -p android
```
This will add an **android** directory at the root of your project.
Step 2: 
Open the project in Android Studio by running the command:
```sh
$ open -a "/Applications/Android Studio.app" ./android
```
Step 3: 
Build the app from Android Studio and connect the debugger. See [Google's documentation](https://developer.android.com/studio/debug#startdebug) for more information.
> You can delete the **android** directory when you are done with this process. This ensures that your project remains managed by Expo CLI. Keeping the directory around and manually modifying it outside of `npx expo prebuild` means you'll need to manually upgrade and configure native libraries yourself.
#### Xcode
> This is only available for macOS users and requires Xcode to be installed.
Step 1: 
Generate the native code for your project by running the following command:
```sh
$ npx expo prebuild -p ios
```
This will add an **ios** directory at the root of your project.
Step 2: 
Open the project in Xcode by running the command which is a shortcut to open the `.xcworkspace` file from your project's **ios** directory in Xcode.
```sh
$ xed ios
```
Step 3: 
Build the app with <kbd>Cmd ⌘</kbd> + <kbd>r</kbd> or by pressing the play button in the upper left corner of Xcode.
Step 4: 
You can now utilize [**Low-level debugger (LLDB)**](https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html) and all of the other [Xcode debugging tools](https://developer.apple.com/documentation/metal/debugging_tools) to examine the native runtime.
> You can delete the **ios** directory when you are done with this process. This ensures that your project remains managed by Expo CLI. Keeping the directory around and manually modifying it outside of `npx expo prebuild` means you'll need to manually upgrade and configure native libraries yourself.
## Production errors
Errors or bugs in your production app can be much harder to solve, mainly because you have less context around the error (that is, where, how, and why did the error occur?).
**The best first step in addressing a production error is to reproduce it locally.** Once you reproduce an error locally, you can follow the [development debugging process](#development-errors) to isolate and address the root cause.
> **info** **Tip**: Sometimes, running your app in **production mode** locally will show errors that normally wouldn't be thrown. You can run the app locally in production by running `npx expo start --no-dev --minify`.
> `--no-dev` tells the server not to be run in development mode, and `--minify` is used to minify your code the same way it is for production JavaScript bundles.
### Production app is crashing
It can be a frustrating scenario when a production app crashes. There is very little information to look into when it happens. It's important to reproduce the issue, and even if you can't do that, to find any related crash reports.
Start by reproducing the crash using your production app and then **find an associated crash report**. For Android, you can use `adb logcat` and for iOS you can use the Console app in Xcode.
Video Tutorial: [How to use Logcat & macOS Console to debug](https://www.youtube.com/watch?v=LvCci4Bwmpc)
#### Crash reports using adb logcat
If your Android app is on Google Play, refer to the crashes section of the [Google Play Console](https://play.google.com/console/about/), or connect your Android device to your computer and run the following command:
```sh
$ adb logcat
```
The Android Debug Bridge (`adb`) program is part of the Android SDK and allows you to view streaming logs. An alternative to avoid installing Android SDK is to use [WebADB](https://webadb.com/) in Chrome.
#### Crash reports using Console app
If your iOS app is on TestFlight or the App Store, you can use the [Crashes Organizer](https://developer.apple.com/news/?id=nra79npr) in Xcode.
If not, you can use the **Console** app in Xcode by connecting your device to your Mac. Follow the steps below on how to access the Console app:
Step 1: 
Open Xcode app, and then open **Devices and Simulators** window by pressing <kbd>Shift</kbd> + <kbd>Cmd ⌘</kbd> + <kbd>2</kbd>.
Step 2: 
If you have connected a physical device, select it under **Devices**. Otherwise, if you are using a simulator, select it under **Simulators**.
Step 3: 
Click on **Open Console** button shown in the window to open the console app.
This will open the console app for you to view logs from your device or simulator.
For more information, see Apple's [Diagnosing Issues Using Crash Reports and Device Logs](https://developer.apple.com/documentation/xcode/diagnosing-issues-using-crash-reports-and-device-logs) guide.
### App crashes on certain (older) devices
This might indicate that there is a performance issue. You likely need to run your app through a profiler to get a better idea of what processes are killing the app, and [React Native provides some great documentation for this](https://reactnative.dev/docs/profiling). We also recommend using [React Native DevTools](/debugging/tools/#debugging-with-react-native-devtools) and the included [profiler](/debugging/tools/#profiling-javascript-performance), which makes it super easy to identify JavaScript performance sinks in your app.
### Using error reporting services
Implementing a crash and bug reporting service in your production app offers several benefits, such as:
- Real-time insights on production deployments with information to reproduce crashes and bugs.
- Setting up an alert system to get notified about fatal JavaScript errors or any other event you configure.
- Using a web dashboard to see details on exceptions such as stack traces, device information, and so on.
With Expo, you can integrate a reporting service like [Sentry](/guides/using-sentry/) or [BugSnag](/guides/using-bugsnag/) to get more insights in real-time.
## Stuck?
The Expo community and the React and React Native communities are great resources for help when you get stuck. There's a good chance someone else has run into the same error as you, so make sure to read the documentation, search the [forums](https://chat.expo.dev/), [GitHub issues](https://github.com/expo/expo/issues/), and [Stack Overflow](https://stackoverflow.com/).


## Debugging and profiling tools

Learn about different tools available to inspect your Expo project at runtime.

React Native consists of both JavaScript and native code. Making this distinction is very important when it comes to debugging. If an error is thrown from the JavaScript code, you might not find it using debugging tools for native code. This page lists a few tools to help you debug your Expo project.
## Developer menu
The **Developer menu** provides access to useful debugging functions. It is built into dev clients and Expo Go. If you are using an emulator, simulator, or have a device connected via USB, you can open this menu by pressing <kbd>m</kbd> in the terminal where Expo CLI has started the development server.
Note: Alternative options to open the Developer menu
---
- Android device (without USB): Shake the device vertically.
- Android Emulator or device (with USB):
  - Press <kbd>Cmd ⌘</kbd> + <kbd>m</kbd> or <kbd>Ctrl</kbd> + <kbd>m</kbd>.
  - Run the following command in the terminal to simulate pressing the menu button:
    ```sh
$ adb shell input keyevent 82
```
- iOS device (without USB):
  - Shake the device.
  - Touch three fingers to the screen.
- iOS Simulator or device (with USB):
  - Press <kbd>Ctrl</kbd> + <kbd>Cmd ⌘</kbd> + <kbd>z</kbd> or <kbd>Cmd ⌘</kbd> + <kbd>d</kbd>
---
Once the Developer menu is open, it will appear as below:
The Developer menu provides the following options:
- **Copy link**: To copy the dev server address in dev client or [`exp://`](/linking/into-your-app/#test-a-link-using-expo-go) link in Expo of your app.
- **Reload**: To reload you app. Usually, not necessary since Fast Refresh is enabled by default.
- **Go Home**: To leave your app and navigate back to the dev client's or Expo Go app's Home screen.
- **Toggle performance monitor**: To view the performance information about your app.
- **Toggle element inspector**: To enable or disable the element inspector overlay.
- **Open JS debugger**: To open React Native DevTools which provides access to Console, Sources, Network (**Expo only**), Memory, Components, and Profiler, tabs for apps using Hermes. For more information, see the [Debugging with React Native DevTools](#debugging-with-react-native-devtools) section.
- **Fast Refresh**: To toggle automatic refreshing of the JS bundle whenever you make changes to files in your project using a text editor.
Now, let's explore some of these options in details.
### Toggle performance monitor
Opens up a small overlay that provides the following performance information about your app:
- RAM usage of a project.
- JavaScript heap (this is an easy way to know of any memory leaks in your application).
- Two Views. The top indicates the number of views for the screen and the bottom indicates the number of views in the component.
- Frames Per Second for the UI and JS threads. The UI thread is used for native Android or iOS UI rendering. The JS thread is where most of your logic runs, including API calls, touch events, and so on.
### Toggle element inspector
Opens up the element inspector overlay:
This overlay has capabilities to:
- Inspect: Inspect elements
- Perf: Show Performance overlay
- Network: Show network details
- Touchables: Highlight touchable elements
## Debugging with React Native DevTools
> **info** **Starting from React Native 0.76**, React Native DevTools has replaced Chrome DevTools.
**React Native DevTools** is a modern debugging tool for Expo and React Native apps. It allows you to gain insights into the JavaScript code of your app by accessing the [Console](#interacting-with-the-console), [Sources](#pausing-on-breakpoints), [Network](#inspecting-network-requests-expo-only) (**Expo only**), and [Memory](#inspecting-memory) tabs. It also has **built-in support for React DevTools** such as [Components](#inspecting-components) and [Profiler](#profiling-javascript-performance) tabs. All of these inspectors can be accessed using [dev clients](/more/glossary-of-terms/#dev-clients) or Expo Go.
You can use the React Native DevTools on any app using [Hermes](/guides/using-hermes/). **To open it, start your app and press <kbd>j</kbd> in the terminal where Expo was started**. Once you have opened the React Native DevTools, it will appear as below:
### Pausing on breakpoints
You can pause your app on specific parts of your code. To do this, set the breakpoint under the Sources tab by clicking the line number or add the `debugger` statement in your code.
Once your app is executing code that has a breakpoint, it will entirely pause your app. This allows you to inspect all variables and functions in that scope. You can also execute code in the [Console](#interacting-with-the-console) tab as part of your app.
### Pausing on exceptions
If your app throws unexpected errors, it can be hard to find the source of the error. You can use React Native DevTools to pause your app and inspect the stack trace and variables the moment it throws an error.
> **info** Some errors might be caught by other components in your app, such as Expo Router. In these cases, you can turn on **Pause on caught exceptions**. It will enable you to inspect any thrown error, even when handled properly.
### Interacting with the console
The **Console** tab gives you access to an interactive terminal, connected directly to your app. You can write any JavaScript inside this terminal to execute snippets of code as if it were part of your app. The code is executed in the global scope by default. But, when using breakpoints from the [Sources](#pausing-on-breakpoints) tab, it executes in the scope of the reached breakpoint. This allows you to invoke methods and access variables throughout your app.
### Inspecting network requests (Expo only)
> **info** The Network tab in React Native DevTools is only available when you have `expo` installed in your project.
The **Network** tab gives you insights into the network requests made by your app. You can inspect each request and response by clicking on them. This includes `fetch` requests, external loaded media, and in some cases, even requests made by native modules.
> **info** See the [Inspecting network traffic](#inspecting-network-traffic) for alternative ways to inspect network requests.
### Inspecting memory
The **Memory** tab allows you to inspect the memory usage and take a heap snapshot of your app's JavaScript code.
### Inspecting components
The **Components** tab allows you to inspect the React components in your app. You can view the props, and styles of each component by hovering that component in React Native DevTools. This is a great way to debug your app's UI and understand how your components are structured.
### Profiling JavaScript performance
> **warning** Profiles are not yet symbolicated with sourcemaps, and [can only be used in debug builds](https://github.com/facebook/hermes/issues/760). These limitations will be addressed in upcoming releases.
The **Profiler** tab allows you to record and analyze the performance of your app's JavaScript. You can start recording, interact with your app, and stop recording to analyze the profile.
> **info** To profile the native runtime, use the tools included in Android Studio or Xcode.
## Debugging with VS Code
> **warning** VS Code debugger integration is in alpha. For the most stable debugging experience, [use the React Native DevTools](#debugging-with-react-native-devtools).
VS Code is a popular code editor, which has a built-in debugger. This debugger uses the same system as the React Native DevTools &mdash; the inspector protocol.
You can use this debugger with the [Expo Tools](https://github.com/expo/vscode-expo#readme) VS Code extension. This debugger allows you to set breakpoints, inspect variables, and execute code through the debug console.
To start debugging:
- Connect your app
- Open VS Code command palette (based on your computer, it's either <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>p</kbd> or <kbd>Cmd ⌘</kbd> + <kbd>Shift</kbd> + <kbd>p</kbd>)
- Run the **Expo: Debug ...** VS Code command.
This will attach VS Code to your running app.
Alternatively, if you want a fully-featured IDE setup in VS Code, you might want to check out the [Radon IDE](https://ide.swmansion.com/) extension (paid with a 30-day free trial). It turns your editor into a powerful environment designed specifically for React Native and Expo projects, with advanced debugging, a network inspector, router integration, and other built-in tools.
## React Native Debugger
> **warning** The React Native Debugger requires Remote JS debugging, which has been deprecated since [React Native 0.73](https://reactnative.dev/docs/other-debugging-methods#remote-javascript-debugging-deprecated).
The React Native Debugger is a standalone app that wraps the React DevTools, Redux DevTools, and React Native DevTools. Unfortunately, it requires the [deprecated Remote JS debugging workflow](https://github.com/jhen0409/react-native-debugger/discussions/774) and is incompatible with Hermes.
If you are using Expo **SDK 50** or **above**, you can use the [Expo dev tools plugins](/debugging/devtools-plugins) equivalents to the React Native Debugger:
- [React Native DevTools](#debugging-with-react-native-devtools)
- [Redux DevTools](/debugging/devtools-plugins/#redux)
If you are using Expo SDK 49 and earlier, you can use the React Native Debugger. This section provides quick get started instructions. For in-depth information, check its [documentation](https://github.com/jhen0409/react-native-debugger#documentation).
You can install it via the [release page](https://github.com/jhen0409/react-native-debugger/releases), or if you're on macOS you can run:
```sh
$ brew install react-native-debugger
```
### Startup
After firing up React Native Debugger, you'll need to specify the port (shortcuts: <kbd>Cmd ⌘</kbd> + <kbd>t</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>t</kbd> on Linux/Windows) to `8081`. After that, run your project with `npx expo start`, and select `Debug remote JS` from the Developer Menu. The debugger should automatically connect.
In the debugger console, you can see the Element tree, as well as the props, state, and children of whatever element you select. You also have the Chrome console on the right, and if you type `$r` in the console, you will see the breakdown of your selected element.
If you right-click anywhere in the React Native Debugger, you'll get some handy shortcuts to reload your JS, enable/disable the element inspector, network inspector, and to log and clear your `AsyncStorage` content.
### Inspecting network traffic
It's easy to use the React Native Debugger to debug your network request: right-click anywhere in the React Native Debugger and select `Enable Network Inspect`. This will enable the Network tab and allow you to inspect requests of `fetch` and `XMLHttpRequest`.
There are however [some limitations](https://github.com/jhen0409/react-native-debugger/blob/master/docs/network-inspect-of-chrome-devtools.md#limitations), so there are a few other alternatives, all of which require using a proxy:
- [Charles Proxy](https://www.charlesproxy.com/documentation/configuration/browser-and-system-configuration/) (~$50 USD, our preferred tool)
- [Proxyman](https://proxyman.io) (Free version available or $49 to $59 USD)
- [mitmproxy](https://medium.com/@rotxed/how-to-debug-http-s-traffic-on-android-7fbe5d2a34#.hnhanhyoz)
- [Fiddler](http://www.telerik.com/fiddler)
## Debugging production apps
In reality, apps often ship with bugs. Implementing a crash and bug reporting system can help you get real-time insights of your production apps. See [Using error reporting services](/debugging/runtime-issues/#using-error-reporting-services) for more details.


## Dev tools plugins

Learn about using dev tools plugins to inspect and debug your Expo project.

Dev tools plugins are available in your local development environment to help you debug your app. They consist of a small amount of code you add to a project that enables two-way communication between the app and an external Chrome window. This setup provides display tools to inspect the app, trigger certain behaviors for testing, and more.
Dev tools plugins are similar to Flipper plugins that are available in Development builds and Expo Go, and do not require adding native modules or config plugins to your project.
## Add a dev tools plugin to a project
To add a dev tool plugin to your app, install it as a package and add a small snippet to connect the code to your app. This code is invoked from the app's root component to establish a two-way communication between your app and the plugin. Then, the plugin can inspect aspects of your app for the entire time your app runs in development mode.
All [Expo dev tools plugins](#expo-dev-tools-plugins) and plugins created with [our creation tool](/debugging/create-devtools-plugins) export a hook that you can use to connect the plugin to your app. The hook and any functions returned from it will no-op when the app is not running in development mode.
Some plugin hooks require parameters that relate to how the plugin inspects your app. For instance, a plugin for inspecting the React Navigation state might require a reference to the navigation root.
To start using the plugin, use the hook in your app's root component:
```jsx App.js
import { useMyDevToolsPlugin } from 'my-devtools-plugin';
export default App() {
  useMyDevToolsPlugin();
  return (/* rest of your app */)
}
```
In some cases, you may need to interact with a plugin directly. All plugins communicate through exports from `expo/devtools`, and you can send and listen to messages through `useDevToolsPluginClient`. Be sure to pass the same plugin name to `useDevToolsPluginClient` as is used by the plugin's web user interface:
```jsx App.js
import { useDevToolsPluginClient } from 'expo/devtools';
export default App() {
  const client = useDevToolsPluginClient('my-devtools-plugin');
   useEffect(() => {
    // receive messages
    client?.addMessageListener("ping", (data) => {
      alert(`Received ping from ${data.from}`);
    });
    // send messages
    client?.sendMessage("ping", { from: "app" });
   }, []);
  return (/* rest of your app */)
}
```
### Compatibility with Expo Go and Development builds
Dev tools plugins should only include JavaScript code. They are generally compatible with Expo Go and [Development builds](/develop/development-builds/introduction/) and should not require creating a new development build to add the plugin. If a package's underlying module that the plugin inspects includes native code and is not part of Expo Go, create a new development build to use both the component and the plugin from that package.
For example, a dev tools plugin that inspects [React Native Firebase](/guides/using-firebase/#using-react-native-firebase) will not work with Expo Go. React Native Firebase includes native code that is not part of Expo Go. To use the dev tools plugin and React Native Firebase, create a development build.
## Using a dev tools plugin
After installing the dev tools plugin and adding the connecting required code to your project, you can start the dev server up with `npx expo start`. Then press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of available dev tools plugins. Select the plugin you want to use, and it will open in a new Chrome window.
> When starting the dev server with the Expo CLI, there is an option to press <kbd>?</kbd> to **show all commands**. This shows additional commands, including the shortcut to open **more tools**. Dev tools plugins can also be selected in this menu.
## Expo dev tools plugins
Expo provides some dev tools plugins for common debugging tasks. Follow the instructions below to start using them in your app.
> **Note**: Each of the following dev tools plugin hooks will only enable the plugin in development mode. It doesn't affect your production bundle.
### React Navigation
Inspired by [`@react-navigation/devtools`](https://github.com/react-navigation/react-navigation/tree/main/packages/devtools), the React Navigation dev tools plugin allows seeing the history of [React Navigation](https://reactnavigation.org/) actions and state. You can also rewind to previous points in your navigation history and send deep links to your app. Since Expo Router is built upon React Navigation, this plugin is fully compatible with [Expo Router](/router/introduction).
To use the plugin, start by installing the package:
```sh
$ npx expo install @dev-plugins/react-navigation
```
Pass the navigation root to the plugin in your app's entry point:
```jsx app/_layout.js
import { useEffect, useRef } from 'react';
import { useNavigationContainerRef, Slot } from 'expo-router';
import { useReactNavigationDevTools } from '@dev-plugins/react-navigation';
export default Layout() {
  const navigationRef = useNavigationContainerRef();
  useReactNavigationDevTools(navigationRef);
  return <Slot />;
}
```
```jsx App.js
import { NavigationContainer, useNavigationContainerRef } from '@react-navigation/native';
import { useReactNavigationDevTools } from '@dev-plugins/react-navigation';
export default function App() {
  const navigationRef = useNavigationContainerRef();
  useReactNavigationDevTools(navigationRef);
return (
    <NavigationContainer ref={navigationRef}>{/* ... */}</NavigationContainer>
  );
}
```
In the terminal, run `npx expo start`, press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of dev tools, and then select the React Navigation plugin. This will open the plugin's web interface, showing your navigation history as you navigate through your app.
### Apollo Client
Inspired by [`react-native-apollo-devtools`](https://github.com/razorpay/react-native-apollo-devtools), the Apollo Client dev tools plugin allows inspecting cache, query, and mutation for the Apollo Client.
To use the plugin, start by installing the package:
```sh
$ npx expo install @dev-plugins/apollo-client
```
Then pass your client instance to the plugin in your app's root component or where you wrap the rest of your app in the `ApolloProvider`:
```jsx App.js
import { ApolloProvider, ApolloClient, InMemoryCache } from '@apollo/client';
import { useApolloClientDevTools } from '@dev-plugins/apollo-client';
const client = new ApolloClient({
  uri: 'https://demo.test.com/',
  cache: new InMemoryCache(),
});
export default function App() {
  useApolloClientDevTools(client);
  return <ApolloProvider>{/* ... */}</ApolloProvider>;
}
```
In the terminal, run `npx expo start`, press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of dev tools, and then select the Apollo Client plugin. This will open the plugin's web interface, showing your query history, cache, and mutations as your app performs Apollo Client operations.
### React Query
Inspired by [`react-query-native-devtools`](https://github.com/bgaleotti/react-query-native-devtools), the React Query dev tools plugin lets you explore data and queries, cache status, and refetch and remove queries from the cache from [TanStack Query](https://tanstack.com/query/latest/).
To use the plugin, start by installing the package:
```sh
$ npx expo install @dev-plugins/react-query
```
Then pass your client instance to the plugin in your app's root component or where you wrap the rest of your app in the `QueryClientProvider`:
```jsx App.js
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useReactQueryDevTools } from '@dev-plugins/react-query';
const queryClient = new QueryClient({});
export default function App() {
  useReactQueryDevTools(queryClient);
  return <QueryClientProvider client={queryClient}>{/* ... */}</QueryClientProvider>;
}
```
In the terminal, run `npx expo start`, press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of dev tools, and then select the React Query plugin. This will open the plugin's web interface, displaying queries as they are used in your app.
### Redux
The `redux-devtools-expo-dev-plugin` is based on the [Redux DevTools](https://github.com/reduxjs/redux-devtools/) (from the Chrome extension). It provides a live list of actions and how they affect the state, and the ability to rewind, replay, and dispatch actions from the DevTools.
To use the plugin, start by installing the package:
```sh
$ npx expo install redux-devtools-expo-dev-plugin
```
If you're using `@reduxjs/toolkit`, modify the `configureStore` call to disable the built-in dev tools by passing in `devTools: false`. Then, add in the Expo DevTools plugin enhancer by concatenating the `devToolsEnhancer()`. The `configureStore` call is going to look like the following:
```js store.js
import devToolsEnhancer from 'redux-devtools-expo-dev-plugin';
const store = configureStore({
  reducer: rootReducer,
  devTools: false,
  enhancers: getDefaultEnhancers => getDefaultEnhancers().concat(devToolsEnhancer()),
});
```
In the terminal, run `npx expo start`, press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of dev tools, and then select `redux-devtools-expo-dev-plugin`. This will open the plugin's web interface, displaying the actions and contents of your store as actions are dispatched.
For complete installation and usage instructions, including if you're using `redux` directly rather than `@reduxjs/toolkit`, [see the project's README](https://github.com/matt-oakes/redux-devtools-expo-dev-plugin).
### TinyBase
The TinyBase dev tools plugin connects the TinyBase Store Inspector to your app, allowing you to view and update the contents of your app's store.
To use the plugin, start by installing the package:
```sh
$ npx expo install @dev-plugins/tinybase
```
Then pass your client instance to the plugin in your app's root component or where you wrap the rest of your app with the store's `Provider`:
```jsx App.js
import { createStore } from 'tinybase';
import { useValue, Provider } from 'tinybase/lib/ui-react';
import { useTinyBaseDevTools } from '@dev-plugins/tinybase';
const store = createStore().setValue('counter', 0);
export default function App() {
  useTinyBaseDevTools(store);
  return <Provider store={store}>{/* ... */}</Provider>;
}
```
In the terminal, run `npx expo start`, press <kbd>shift</kbd> + <kbd>m</kbd> to open the list of dev tools, and then select the Tinybase plugin. This will open the plugin's web interface, displaying the contents of your store as it is modified.


## Create a dev tools plugin

Learn how to create a dev tools plugin to enhance your development experience.

> **info** **Tip:** Check out the [Expo DevTools Plugins](https://github.com/expo/dev-plugins) for complete examples.
You can create a dev tools plugin, whether that's for inspecting aspects of a common framework or library or something specific to your custom code. This guide will walk you through creating a dev tools plugin.
## What is a dev tools plugin?
A dev tools plugin runs in your web browser in your local development environment and connects to your Expo app.
A plugin consists of three key elements:
- An Expo app to display the dev tools web user interface.
- An **expo-module.config.json** for Expo CLI recognition.
- Calls to `expo/devtools` API for the app to communicate back and forth with the dev tool's web interface.
Plugins can be distributed on npm or included inside your app's monorepo. They typically export a single hook that can be used in your app's root component to initiate two-way communication with the web interface when your app is running in debug mode.
Step 1: 
## Create a plugin
### Create a new plugin project
`create-dev-plugin` will set up a new plugin project for you. Run the following command to create a new plugin project:
```sh
$ npx create-dev-plugin@latest
```
`create-dev-plugin` will prompt you for the name of your plugin, a description, and the name of the hook that will be used by consumers of your plugin.
The plugin project will contain the following directories:
- **src** - this exports the hook that will be used inside the consuming app to connect it to the plugin.
- **webui** - this contains the web user interface for the plugin.
### Customize a plugin's functionality
The template includes a simple example of sending and receiving messages between the plugin and the app. `useDevToolsPluginClient`, imported from `expo/devtools`, provides functionality for sending and receiving messages between the plugin and the app.
The client object returned by `useDevToolsPluginClient` includes:
#### addMessageListener
Listens for a message matching the typed string and invokes the callback with the message data.
```jsx
const client = useDevToolsPluginClient('my-devtools-plugin');
client.addMessageListener('ping', data => {
  alert(`Received ping from ${data.from}`);
});
```
#### sendMessage
Listens for a message matching the typed string and invokes the callback with the message data.
```jsx
const client = useDevToolsPluginClient('my-devtools-plugin');
client?.sendMessage('ping', { from: 'web' });
```
Edit the Expo app inside the **webui** directory to customize the user interface that displays diagnostic information from your app or triggers test scenarios:
```tsx webui/App.tsx
import { useDevToolsPluginClient, type EventSubscription } from 'expo/devtools';
import { useEffect } from 'react';
export default function App() {
  const client = useDevToolsPluginClient('my-devtools-plugin');
  useEffect(() => {
    const subscriptions: EventSubscription[] = [];
    subscriptions.push(
      client?.addMessageListener('ping', data => {
        alert(`Received ping from ${data.from}`);
      })
    );
    return () => {
      for (const subscription of subscriptions) {
        subscription?.remove();
      }
    };
  }, [client]);
}
```
Edit the hook in the **src** directory to customize what diagnostic information is sent to the plugin or how the app should respond to any messages from the web user interface:
```tsx src/useMyDevToolsPlugin.ts
import { useDevToolsPluginClient } from 'expo/devtools';
export function useMyDevToolsPlugin() {
  const client = useDevToolsPluginClient('my-devtools-plugin');
  const sendPing = () => {
    client?.sendMessage('ping', { from: 'app' });
  };
  return {
    sendPing,
  };
}
```
If you update the hook to return functions that will be called by the app, you will also need to update **src/index.ts** so it exports no-op functions when the app is not running in debug mode:
```diff src/index.ts
if (process.env.NODE_ENV !== 'production') {
  useMyDevToolsPlugin = require('./useMyDevToolsPlugin').useMyDevToolsPlugin;
} else {
  useMyDevToolsPlugin = () => ({
+    sendPing: () => {},
  });
}
```
Step 2: 
## Test a plugin
Since the plugin web UI is an Expo app, you can test it just like you would any other Expo app, with `npx expo start`, except that you will run it in the browser only. The template includes a convenience command to run the plugin in local development mode:
```sh
$ npm run web:dev
```
Step 3: 
## Build a plugin for distribution
To prepare your plugin for distribution or use within your monorepo, you will need to build the plugin with the following command:
```sh
$ npm run build:all
```
This command will build the hook code into the **build** directory, and the web user interface into the **dist** directory.
Step 4: 
## Use the plugin
Import the plugin's hook into your app's root component and call it to connect your app to the plugin:
```jsx App.js
import { useMyDevToolsPlugin } from 'my-devtools-plugin';
import { Button } from 'react-native';
export default function App() {
  const { sendPing } = useMyDevToolsPlugin();
  return (
    <View style={styles.container}>
      <Button
        title="Ping"
        onPress={() => {
          sendPing();
        }}
      />
    </View>
  );
}
```


# Review

## Overview of distributing apps for review

Learn about how to distribute your app for review using app stores, internal distribution, and EAS Update.

This page outlines three approaches to sharing a preview version of your app with your team for QA and review: app store testing tracks, internal distribution, and development builds with EAS Update.
Note: Can I use Expo Go for reviewing releases?
---
Even though Expo Go is an open-source sandbox that can be good for previewing isolated prototypes on Android and iOS, it is not intended for production apps. It should be avoided during the preview process of your app.
---
## App store testing tracks
When distributing apps through app store testing tracks, you can only use release builds. You cannot use this method to distribute development builds. An alternative approach is to use ["Internal distribution"](#internal-distribution-with-eas-build), which works with both release and development builds.
Note: Android: Google Play Beta
---
Before a complete public release, [Google Play beta](https://support.google.com/googleplay/android-developer/answer/9845334?visit_id=638740965629093187-3840249980&rd=1) is another option to distribute your app to testers. You can set up either an internal, closed, or open test track and control who has access to the app.
Each test track has its own requirements. For the internal track, you can only invite up to 100 testers. Both closed and open tracks support larger groups of testers. In closed tracks, you need to invite testers, while in open tracks, anyone can join your program.
To use Google Play beta, you need to upload your app as an AAB (Android App Bundle) to the Google Play Console, set up a test track, and invite users via email or a shareable link. Testers can install the app through the Play Store, and you can collect feedback and crash reports directly from the Google Play Console.
---
Note: iOS: TestFlight
---
TestFlight is another option to distribute your app to iOS devices. TestFlight also requires a paid Apple Developer account. TestFlight's internal testing option allows you to create test groups that include up to 100 members of your Apple Developer account team, who then download the app through the TestFlight app. Some teams prefer TestFlight because it doesn't require a new build to add new testers, and apps stay updated automatically.
TestFlight also includes an external testing option that allows you to share your app with up to 10,000 users via an email or a public link.
Both internal and external test distribution in TestFlight require you to [upload your app](/submit/ios) to App Store Connect and wait for the automated review before you can share a build. However, external test builds will need to go through a more formal App Store review (which is distinct from the review that your app must undergo before production release) before being distributed.
---
## Internal distribution with EAS Build
[Internal distribution](/build/internal-distribution/) is a feature provided by EAS that allows developers to create builds and easily share them with a URL. The URL can be opened on a device to install the app. The app is provided as an installable APK for Android or an ad hoc provisioned app for iOS.
As soon as an internal distribution build is created, it is available for download and installation &mdash; no need to fill out any forms or wait for approval/processing. You can use internal distribution to share both release and development builds.
## Development builds and EAS Update
You can use [development builds](/develop/development-builds/introduction/) to load previews of your app during the review stage by publishing an update with [EAS Update](/eas-update/introduction/). After sharing a development build through internal distribution and installing it, you can launch any update that you published with EAS Update, as long as it is compatible with the installed build. Learn more about [Runtime versions and updates](/eas-update/runtime-versions/).
Note: You can use the EAS dashboard to launch updates and share a link to a specific update.
---
---
Note: You can explore and launch updates directly from a development build.
---
---
Note: You can configure GitHub Actions to automatically publish updates on PRs and commits.
---
---
This approach is uniquely powerful because it allows you to respond to feedback as quickly as you can run `eas update`. It can take seconds to share a new version of your app with your team, and you can do so without needing to rebuild the app or upload it to a store test track.
  }
  description={
    <>
      Learn how to use  in your project to launch different app versions
      and preview a published update inside a development build.
    </>


## Share previews with your team

Share previews of your app with your team by publishing updates on branches.

Once you've made changes on a branch, you can share them with your team by publishing an update. This allows you to get feedback on your changes during review.
The following steps will outline a basic flow for publishing a preview of your changes, and then sharing it with your team. For a more comprehensive resource, see the [Preview updates](/eas-update/preview/) guide.
## Publish a preview of your changes
You can publish a preview of your current changes by running the following [EAS CLI](/develop/tools/#eas-cli) command:
```sh
$ eas update --auto
```
This command will publish an update under the current branch name.
## Share with your team
Once the preview is published, you'll see output like this in the terminal window:
```sh
✔ Published!
...
EAS Dashboard      https://expo.dev/accounts/your-account/projects/your-project/updates/708b05d8-9bcf-4212-a052-ce40583b04fd
```
Share the **EAS dashboard** link with a reviewer. After opening the link, they can click on the **Preview** button. They will see a QR code that they can scan to open the preview on their device.
## Create previews automatically
You can automatically create previews on every commit with [EAS Workflows](/eas/workflows/get-started/). First, you'll need to [configure your project](/eas/workflows/get-started/#configure-your-project), add a file named **.eas/workflows/publish-preview-update.yml** at the root of your project, then add the following workflow configuration:
```yaml .eas/workflows/publish-preview-update.yml
name: Publish preview update
on:
  push:
    branches: ['*']
jobs:
  publish_preview_update:
    name: Publish preview update
    type: update
    params:
      branch: ${{ github.ref_name || 'test' }}
```
The workflow above will publish an update on every commit to every branch. You can also run this workflow manually with the following EAS CLI command:
```sh
$ eas workflow:run publish-preview-update.yml
```
Learn more about common patterns with the [workflows examples guide](/eas/workflows/examples).
## Learn more


## How to launch an update using Expo Orbit

Learn how to open updates with Expo Orbit as part of a review workflow.

[Expo Orbit](https://expo.dev/orbit) is a macOS and Windows app designed to speed up installing and running builds from EAS. It makes running your builds and updates as easy as pressing **Open in Orbit**.
Note: How does automatic installation and launching of updates work?
---
When you launch an update, Orbit will look for the latest development build that matches the runtime version and target platform of the update. If a compatible build is found, the update will install automatically on the target device and launch with a deep link that points to the update.
If you don't have any development builds available, either because they have all expired, you haven't created one, you don't use EAS Build, or you are [building your app locally](/guides/local-app-development/), then Orbit will prompt you on how to proceed. Click **Launch with deep link** in the prompt to open the update if you already have a compatible development build installed on your target device.
---
## Prerequisites
- **Install the Orbit app** before following the steps in this guide. You can download it directly from [GitHub releases](https://github.com/expo/orbit/releases) or see the [alternative method](/build/orbit/#installation) to install it.
- After installing the app, sign in to your Expo account from **Settings**.
## Preview an update with Expo Orbit
Previewing with Expo Orbit requires you to have an update published. If you haven't published an update, see [Publish an update](/eas-update/getting-started/#publish-an-update) before following the steps in the next section.
### Install and launch the update
> **Note**: Launching updates using Expo Orbit is not supported on physical iOS devices. It is supported on Android devices/emulators or iOS Simulators.
After the update is published, follow these steps to open it on an Android Emulator or iOS Simulator:
- Navigate your project's **Updates** tab.
- Select the update you want to preview.
- Click **Preview**. This will open the **Preview** dialog.
- Under **Open with Orbit**, select a platform to launch the update.
- Orbit will install and launch the update on the selected Android Emulator or iOS Simulator.
You can now seamlessly launch and review updates using Expo Orbit.


# Deploy

## Build your project for app stores

Learn how to create a production build for your app that is ready to be submitted to app stores from the command line using EAS Build.

Whether you have built a native app binary using [EAS](/build/setup/) or [locally](/guides/local-app-development/), the next step in your app development journey is to submit your app to the stores. To do so, you need to create a **production build**.
Production builds are submitted to app stores for release to the general public or as part of a store-facilitated testing process such as TestFlight. This guide explains how to create production builds with [EAS](#production-builds-using-eas) and [locally](#production-builds-locally). It is also possible to create production builds for Expo apps with any CI service capable of compiling Android and iOS apps.
## Production builds using EAS
Production builds must be installed through their respective app stores. You cannot install them directly on your Android Emulator, iOS Emulator, or device. The only exception to this is if you explicitly set `"buildType": "apk"` for Android on your build profile. However, it is recommended to use **aab** when submitting to stores, and this is the default configuration.
### `eas.json` configuration
A minimal configuration for building a production build in **eas.json** is already created when you create your first build:
```json eas.json
{
  "build": {
    "production": {}
  }
}
```
### Create a production build
To create a production build, run the following command for a platform:
    ```sh
$ eas build --platform android
```
    ```sh
$ eas build --platform ios
```
You can attach a message to the build by passing `--message` to the build command, for example, `eas build --platform ios --message "Some message"`. The message will appear on the EAS dashboard. It comes in handy when you want to specify the purpose of the build for your team.
Alternatively, you can use `--platform all` option to build for Android and iOS at the same time:
```sh
$ eas build --platform all
```
## Developer account
You will need to have a developer account for the app store you want to submit your app.
Note: Google Play Developer membership is required to distribute to the Google Play Store.
---
You can build and sign your app using EAS Build, but you can't upload it to the Google Play Store unless you have a membership, a one-time $25 USD fee.
---
Note: Apple Developer Program membership is required to build for the Apple App Store.
---
If you are going to use EAS Build to create production builds for the Apple App Store, you need access to an account with a $99 USD [Apple Developer Program](https://developer.apple.com/programs) membership.
---
## App signing credentials
Before the build process can start for app stores, you need a store developer account and generate or provide app signing credentials.
Whether you have experience with generating app signing credentials or not, EAS CLI can do the heavy lifting. You can opt-in for EAS CLI to handle the app signing credentials process.
### Android app signing credentials
- If you have not yet generated a keystore for your app, use EAS CLI by selecting `Generate new keystore`, and then you are done. The keystore is stored securely on EAS servers.
- If you want to manually generate your keystore, see the [manual Android credentials guide](/app-signing/local-credentials#android-credentials) for more information.
### iOS app signing credentials
- If you have not generated a provisioning profile and/or distribution certificate yet, use EAS CLI by signing in to your Apple Developer Program account and following the prompts.
- If you want to manually generate your credentials, see the [manual iOS credentials guide](/app-signing/local-credentials#ios-credentials) for more information.
## Wait for the build to complete
By default, the `eas build` command will wait for your build to complete, but you can interrupt it if you prefer not to wait. Instead, use the builds details page link prompted by EAS CLI to monitor the build progress and read the build logs. You can also find this page by visiting [your build dashboard](https://expo.dev/builds) or running the following command:
```sh
$ eas build:list
```
If you are a member of an organization and your build is on its behalf, you will find the build details on [the build dashboard for that account](https://expo.dev/accounts/[account]/builds).
## Create builds automatically
You can automatically create builds on commits to specific branches with [EAS Workflows](/eas/workflows/get-started/). First, you'll need to [configure your project](/eas/workflows/get-started/#configure-your-project), add a file named **.eas/workflows/create-builds.yml** at the root of your project, then add the following workflow configuration:
```yaml .eas/workflows/create-builds.yml
name: Create builds
on:
  push:
    branches: ['main']
jobs:
  build_android:
    name: Build Android app
    type: build
    params:
      platform: android
      profile: production
  build_ios:
    name: Build iOS app
    type: build
    params:
      platform: ios
      profile: production
```
The workflow above will create Android and iOS builds on every commit to your project's `main` branch. You can also run this workflow manually with the following EAS CLI command:
```sh
$ eas workflow:run create-builds.yml
```
Learn more about common patterns with the [workflows examples guide](/eas/workflows/examples).
## Release builds locally
To create a release (also known as production) build locally, see the following React Native guides for more information on the necessary steps for Android and iOS.
These guides assume your project has **android** and/or **ios** directories containing the respective native projects. If you use [Continuous Native Generation](/workflow/continuous-native-generation) then you will need to run [prebuild](/workflow/prebuild) to generate the directories before following the guides.
> **Note**: Following the guide below, in step four, when you build the release **.aab** for Android, run `./gradlew app:bundleRelease` from the **android** directory instead of `npx react-native build-android --mode=release`.
## Next step


## Submit to app stores

Learn how to submit your app to Google Play Store and Apple App Store from the command line with EAS Submit.

**EAS Submit** is a hosted service that allows uploading and submitting app binaries to the app stores using EAS CLI. This guide describes how to submit your app to the Google Play Store and Apple App Store using EAS Submit.
Video Tutorial: [How to quickly publish to the App Store & Play Store with EAS Submit](https://www.youtube.com/watch?v=-KZjr576tuE)
## Apple App Store
<Prerequisites numberOfRequirements={4}>
  <Requirement number={1} title="Sign up for an Apple Developer account">
    An Apple Developer account is required to submit your app to the Apple App Store. You can sign up for an Apple Developer account on the [Apple Developer Portal](https://developer.apple.com/account/).
  </Requirement>
  <Requirement number={2} title="Include a bundle identifier in app.json">
    Include your app's bundle identifier in **app.json**:
    ```json app.json
    {
      "ios": {
        "bundleIdentifier": "com.yourcompany.yourapp"
      }
    }
    ```
  </Requirement>
  <Requirement number={3} title="Install EAS CLI and authenticate with your Expo account">
    Install EAS CLI and login with your Expo account:
    ```sh
$ npm install -g eas-cli && eas login
```
  </Requirement>
  <Requirement number={4} title="Build a production app">
    You'll need a production build ready for store submission. You can create one using [EAS Build](/build/introduction/):
    ```sh
$ eas build --platform ios --profile production
```
    Alternatively, you can build the app on your own computer with `eas build --platform ios --profile production --local` or with Xcode.
  </Requirement>
</Prerequisites>
Once you have completed all the prerequisites, you can start the submission process.
Run the following command to submit a build to the Apple App Store:
```sh
$ eas submit --platform ios
```
The command will lead you step by step through the process of submitting the app.
## Google Play Store
<Prerequisites numberOfRequirements={7}>
  <Requirement number={1} title="Sign up for a Google Play Developer account">
    A Google Play Developer account is required to submit your app to the Google Play Store. You can sign up for a Google Play Developer account on the [Google Play Console sign-up page](https://play.google.com/apps/publish/signup/).
  </Requirement>
  <Requirement number={2} title="Create a Google Service Account">
    EAS requires you to upload and configure a Google Service Account Key to submit your Android app to the Google Play Store. You can create one with the [uploading a Google Service Account Key for Play Store submissions with EAS](https://github.com/expo/fyi/blob/main/creating-google-service-account.md) guide.
  </Requirement>
  <Requirement number={3} title="Create an app on Google Play Console">
    Create an app by clicking **Create app** in the [Google Play Console](https://play.google.com/apps/publish/).
  </Requirement>
  <Requirement number={4} title="Install EAS CLI and authenticate with your Expo account">
    Install EAS CLI and login with your Expo account:
    ```sh
$ npm install -g eas-cli && eas login
```
  </Requirement>
  <Requirement number={5} title="Include a package name in app.json">
    Include your app's package name in **app.json**:
    ```json app.json
    {
      "android": {
        "package": "com.yourcompany.yourapp"
      }
    }
    ```
  </Requirement>
  <Requirement number={6} title="Build a production app">
    You'll need a production build ready for store submission. You can create one using [EAS Build](/build/introduction/):
    ```sh
$ eas build --platform android --profile production
```
    Alternatively, you can build the app on your own computer with `eas build --platform android --profile production --local` or with Android Studio.
  </Requirement>
  <Requirement number={7} title="Upload your app manually at least once">
    You have to upload your app manually at least once. This is a limitation of the Google Play Store API.
    Learn how with the [first submission of an Android app](https://expo.fyi/first-android-submission) guide.
  </Requirement>
</Prerequisites>
Once you have completed all the prerequisites, you can start the submission process.
Run the following command to submit a build to the Google Play Store:
```sh
$ eas submit --platform android
```
The command will lead you step by step through the process of submitting the app.
## Build and submit automatically
You can automatically create builds and submit them to the app stores with [EAS Workflows](/eas/workflows/get-started/). First, you'll need to [configure your project](/eas/workflows/get-started/#configure-your-project), add a file named **.eas/workflows/build-and-submit.yml** at the root of your project, then add the following workflow configuration:
```yaml .eas/workflows/build-and-submit.yml
name: Build and submit
on:
  push:
    branches: ['main']
jobs:
  build_android:
    name: Build Android app
    type: build
    params:
      platform: android
      profile: production
  build_ios:
    name: Build iOS app
    type: build
    params:
      platform: ios
      profile: production
  submit_android:
    name: Submit Android
    type: submit
    needs: [build_android]
    params:
      build_id: ${{ needs.build_android.outputs.build_id }}
  submit_ios:
    name: Submit iOS
    type: submit
    needs: [build_ios]
    params:
      build_id: ${{ needs.build_ios.outputs.build_id }}
```
The workflow above will create Android and iOS builds on every commit to your project's `main` branch, then submit them to the Google Play and Apple App Store respectively. You can also run this workflow manually with the following EAS CLI command:
```sh
$ eas workflow:run build-and-submit.yml
```
Learn more about common patterns with the [workflows examples guide](/eas/workflows/examples).
## Manual submission to app stores
You can also submit your app manually to the Google Play Store and Apple App Store.
## Next step


## App stores metadata

A brief overview of how to use EAS Metadata to automate and maintain your app store presence.

> **important** **EAS Metadata** is in preview and subject to breaking changes.
When submitting your app to app stores, you need to provide metadata. This process is lengthy and is often about complex topics that don't apply to your app. After the information you provide gets reviewed and if there is any issue with it, you need to restart this process.
[**EAS Metadata**](/eas/metadata/) enables you to automate and maintain this information from the command line instead of going through multiple forms in the app store dashboards. It can also instantly identify well-known app store restrictions that could trigger a rejection after a lengthy review queue. This guide shows how to use EAS Metadata to automate and maintain your app store presence.
## Prerequisites
EAS Metadata currently **only supports the Apple App Store**.
> Using VS Code? Install the [Expo Tools extension](https://github.com/expo/vscode-expo#readme) for auto-complete, suggestions, and warnings in your **store.config.json** files.
## Create a store config
EAS Metadata uses [store.config.json](/eas/metadata/config/) file to hold all the information you want to upload to the app stores. This file is located at the root of your Expo project.
Create a new **store.config.json** file at the root of your project directory as shown in the example below:
```json store.config.json
{
  "configVersion": 0,
  "apple": {
    "info": {
      "en-US": {
        "title": "Awesome App",
        "subtitle": "Your self-made awesome app",
        "description": "The most awesome app you have ever seen",
        "keywords": ["awesome", "app"],
        "marketingUrl": "https://example.com/en/promo",
        "supportUrl": "https://example.com/en/support",
        "privacyPolicyUrl": "https://example.com/en/privacy"
      }
    }
  }
}
```
The above example file contains JSON schema. Replace the example values with your own. It is usually contains your app's `title`, `subtitle` , `description`, `keywords`, and `marketingUrl` and so on.
**An important thing to remember from the above example is the `configVersion` property.** It helps with versioning changes that are not backward compatible.
> For more information on properties that can be defined in **store.config.json**, see [Schema for EAS Metadata](/eas/metadata/schema/#config-schema).
## Upload the store config
> Before pushing the **store.config.json** to the app stores, you must upload a new binary of your app. See [App Store submissions](/deploy/submit-to-app-stores/) for more information. After the binary is submitted and processed, you can continue with the step below.
After you have created the **store.config.json** file and added the necessary information related to your app, you can push the store config to the app stores by running the command:
```sh
$ eas metadata:push
```
If EAS Metadata runs into any issues with your store config, it will warn you when running this command. When there are no errors, or you confirm to push it with possible issues, it will try to upload as much as possible.
You can also re-use this command when you modify the **store.config.json** file and want to push the latest changes to the app stores.
## Next steps


## Send over-the-air updates

Learn how to send over-the-air updates to push critical bug fixes and improvements to your users.

You can send over-the-air updates containing critical bug fixes and improvements to your users.
## Get started
> If you've published [previews](/review/share-previews-with-your-team/) or created a [build](/deploy/build-project/) before, you may have already set up updates and can skip this section.
To set up updates, run the following [EAS CLI](/develop/tools/#eas-cli) command:
```sh
$ eas update:configure
```
After the command completes, you'll need to make new builds before continuing to the next section.
## Send an update
To send an update, run the following [EAS CLI](/develop/tools/#eas-cli) command:
```sh
$ eas update --channel production
```
This command will create an update and make it available to builds of your app that are configured to receive updates on the `production` channel. This channel is defined in [**eas.json**](/eas/json/#channel).
You can verify the update works by force closing the app and reopening it two times. The update should be applied on the second launch.
## Send updates automatically
You can automatically send updates with [EAS Workflows](/eas/workflows/get-started/). First, you'll need to [configure your project](/eas/workflows/get-started/#configure-your-project), add a file named **.eas/workflows/send-updates.yml** at the root of your project, then add the following workflow configuration:
```yaml .eas/workflows/send-updates.yml
name: Send updates
on:
  push:
    branches: ['main']
jobs:
  send_updates:
    name: Send updates
    type: update
    params:
      channel: production
```
The workflow above will send an over-the-air update for the `production` update channel on every commit to your project's `main` branch. You can also run this workflow manually with the following EAS CLI command:
```sh
$ eas workflow:run send-updates.yml
```
Learn more about common patterns with the [workflows examples guide](/eas/workflows/examples).
## Learn more
You can learn how to [rollout an update](/eas-update/rollouts/), [optimize assets](/eas-update/optimize-assets/), and more with our [update guides](/eas-update/introduction/).


## Publish your web app

Learn how to deploy your web app using EAS Hosting.

> **important** **EAS Hosting** is in preview and subject to changes.
If you are building a universal app, you can quickly deploy your web app using [EAS Hosting](/eas/hosting/introduction/). It is a service for deploying web apps built with Expo Router and React.
## Prerequisites
Before you begin, in your project's **app.json** file, ensure that the [`expo.web.output`](/versions/latest/config/app/#output) property is either `static` or `server`.
## Export your web project
To deploy your web app, you need to create a static build of your web project. Export your web project into a **dist** directory by running the following command:
```sh
$ npx expo export --platform web
```
> Remember to re-run this command every time before deploying when you make changes to your web app.
## Initial deployment
To publish your web app, run the following [EAS CLI](/develop/tools/#eas-cli) command:
```sh
$ eas deploy
```
After running this command for the first time, you'll be prompted to select a preview subdomain for your project. This subdomain is a prefix used to create a preview URL and is used for production deployments. For example, in `https://test-app--1234.expo.app`, `test-app` is the preview subdomain.
Once your deployment is complete, the EAS CLI will output a preview URL to access your deployed app.
## Production deployment
To create a production deployment, run the following [EAS CLI](/develop/tools/#eas-cli) command:
```sh
$ eas deploy --prod
```
Once your deployment is complete, the EAS CLI will output a production URL to access your deployed app.
## Deploy automatically
You can automatically deploy your app to the web with [EAS Workflows](/eas/workflows/get-started/). First, you'll need to [configure your project](/eas/workflows/get-started/#configure-your-project), add a file named **.eas/workflows/deploy-web.yml** at the root of your project, then add the following workflow configuration:
```yaml .eas/workflows/deploy-web.yml
name: Deploy web
on:
  push:
    branches: ['main']
jobs:
  deploy_web:
    name: Deploy web
    type: deploy
    params:
      prod: true
```
The workflow above will create a web deployment on every commit to your project's `main` branch. You can also run this workflow manually with the following EAS CLI command:
```sh
$ eas workflow:run deploy-web.yml
```
Learn more about common patterns with the [workflows examples guide](/eas/workflows/examples).
## Learn more
You can learn more about setting up [deployment aliases](/eas/hosting/deployments-and-aliases/), using a [custom domain](/eas/hosting/custom-domain/), or [deploying an API Route](/router/web/api-routes/#deployment).


# Monitor

## Monitoring services

Learn how to monitor the usage of your Expo and React Native app after its release.

Once your app is released, you can track anonymized usage data to give you insights on how users use your app. This data includes which updates are in use, when users experience bugs, and more.
## EAS Insights
Expo provides the [`expo-insights`](/eas-insights/introduction/) library, which tracks information related to [EAS Update](/deploy/send-over-the-air-updates/). This data includes the app version, platform, OS version, and update adoption. After you install it and release production builds on the app stores, you'll be able to see additional data on your project dashboard:
Get started with the following guide:
## LogRocket
You can get more insights with [LogRocket](https://logrocket.com). LogRocket records user sessions and identifies bugs as your users use your app. You can filter sessions by update IDs and also connect to your LogRocket account on the EAS dashboard to get quick access to your app's session data.
Get started with the following guide:
## Sentry
[Sentry](http://getsentry.com/) is a crash reporting platform that provides real-time insight into production deployments with information to reproduce and fix crashes.
It notifies you of exceptions or errors that your users run into while using your app and organizes them for you on a web dashboard. Reported exceptions include stacktraces, device info, version, and other relevant context automatically. You can also provide additional context that is specific to your app, such as the current route and user ID.
Get started with the following guide:
## Vexo
[Vexo](https://www.vexo.co/) helps you understand how users interact with your Expo app, identify friction points, and improve engagement. It provides real-time user analytics with a simple two-line integration and offers a complete dashboard with insights into user activity, app performance, and adoption trends, along with features like heatmaps, session replays, and more.
Get started with the following guide:
## BugSnag
[BugSnag](https://www.bugsnag.com/) is a stability monitoring solution that provides rich, end-to-end error reporting and analytics to reproduce and fix errors with speed and precision. BugSnag supports the full stack with open-source libraries for more than 50 platforms, including React Native.
Get started with the following guide:


# More

## Core concepts

An overview of Expo tools, features and services.

Expo is an [open-source framework](https://github.com/expo/expo/) for apps that run natively on Android, iOS, and the web. Expo brings together the best of mobile and the web and enables many important features for building and scaling an app.
The `expo` npm package enables a suite of incredible features for React Native apps. The `expo` package can be installed in nearly **any React Native project**.
## Tools and features
> **info** All features are free, optional, and can be used independently of each other. Unused features add no additional bloat to your app.
| Feature                                                                             | With `expo` | Without `expo` (bare React Native) |
| ----------------------------------------------------------------------------------- | ----------- | ---------------------------------- |
| Develop complex apps **entirely** in JavaScript.                                    | <YesIcon /> | <NoIcon />                         |
| Write JSI native modules with Swift and Kotlin.                                     | <YesIcon /> | <NoIcon />                         |
| Develop apps without Xcode or Android Studio.                                       | <YesIcon /> | <NoIcon />                         |
| Create and share example apps in the browser with [Snack](https://snack.expo.dev/). | <YesIcon /> | <NoIcon />                         |
| Major upgrades without native changes.                                              | <YesIcon /> | <NoIcon />                         |
| First-class TypeScript support.                                                     | <YesIcon /> | <NoIcon />                         |
| Install natively compatible libraries from the command line.                        | <YesIcon /> | <NoIcon />                         |
| Develop performant websites with the same codebase.                                 | <YesIcon /> | <NoIcon />                         |
| [Tunnel](/more/expo-cli/#tunneling) your dev server to any device.                  | <YesIcon /> | <NoIcon />                         |
## Services
The team behind Expo also provides **Expo Application Services (EAS)**, deeply integrated cloud services for building, submitting, and updating your React Native app. EAS can be used with **any React Native app**, regardless of whether it uses `expo` or not.


## FAQ

A list of common questions and limitations about Expo and related services.

This page lists some of the common questions and answers about Expo and related services. If you have a question that is not answered here, see [Forums](https://chat.expo.dev/) for more common questions.
## What is Expo used for?
Expo is an [open-source framework](https://github.com/expo/expo) for apps that run natively on Android, iOS, and the web. Expo brings together the best of mobile and the web and enables many important features for building and scaling an app such as live updates, instantly sharing your app, and web support. The `expo` npm package enables a suite of incredible features for React Native apps. The `expo` package can be installed in nearly any React Native project. See [what Expo offers](/core-concepts) for more information.
## Do companies use Expo?
Yes, Expo is used by top companies worldwide, serving hundreds of millions of end users. See our [showcase](https://expo.dev/customers).
## Why does Expo have its own SDK?
When Expo was first created, React Native had yet to be publicly released. This means there were no third-party packages. To make React Native's developer experience reasonable, we created [several libraries to achieve common functionalities](/versions/latest). Many of these libraries have since been forked and modified to meet various needs. We welcome users to mix and match whichever [custom native code](/workflow/customizing) they need to make their app great.
The Expo SDK is well-tested, written in TypeScript, documented, and built for Android, iOS, and the web. Every module in the Expo SDK works together to ensure versioning always matches. This creates a nice upgrading experience.
The Expo SDK is also written with the [Expo Modules API](/modules) to make contributing, maintaining, and understanding easier.
## What is the difference between Expo and React Native?
The `expo` package provides a suite of features that make it easier to develop, and scale complex React Native applications. You can install `expo` in nearly any React Native app. The `expo` package is not required to use [Expo Application Services (EAS)](/eas) or React Native, however, it is highly recommended. See [what Expo offers](/core-concepts) for more information.
## Do I need to switch from React Native to use Expo?
No, the `expo` npm package and CLI work with any React Native app. [Expo Application Services (EAS)](/eas) also works with all React Native apps with first-class support for builds, updates, app store submissions, and more.
## How much does Expo cost?
The Expo platform is [free and open source](https://blog.expo.dev/exponent-is-free-as-in-and-as-in-1d6d948a60dc). This includes the libraries that make up the [Expo SDK](/versions/latest) and the [Expo CLI](/more/expo-cli/) used for development. The Expo Go app, the easiest way to get started, is also free from the app stores.
[Expo Application Services (EAS)](/eas) is an optional suite of cloud services for React Native apps, from the Expo team. EAS makes it easier to build your app, submit it to the stores, keep it updated, send push notifications, and more. You can use EAS for free if the [Free plan](https://expo.dev/pricing) quotas are sufficient for your app. More information is available on the [pricing page](https://expo.dev/pricing).
## How do I add custom native code to my Expo project?
Expo supports adding custom native code and customizing that native code (Android/Xcode projects). To use any custom native code, you can create a [development build](/develop/development-builds/introduction/) and [config plugins](/config-plugins/introduction). We do recommend using the modules in the [Expo SDK](/versions/latest) when possible for easier upgrades and improved developer experience.
## Can I use Expo in the app that is created with React Native CLI?
Yes! All Expo tools and services work great in any React Native app. For example, you can use any part of the [Expo SDK](/versions/latest), [`expo-dev-client`](/develop/development-builds/installation/) and EAS Build, Submit, and Update &mdash; they work great! Learn more about [installing `expo` in your project](/bare/installing-expo-modules), [adopting prebuild](/guides/adopting-prebuild), and [setting up EAS Build](/build/introduction).
## How do I share my Expo project? Can I submit it to the app stores?
The fastest way to share your project is to publish with [EAS Update](/eas-update/introduction) and launch in a [development build](/develop/development-builds/introduction/). This gives your app a URL; you can share this URL with anybody who has the [development build](/develop/development-builds/introduction/) for Android or iOS. URLs can also be opened in Expo Go for Android.
When ready, you can create a production build (**.aab** and **.ipa**) to submit to the app stores. You can build your app in a single command with [EAS Build](/build/introduction) and submit it to the stores with [EAS Submit](/submit/introduction).
You can also use [internal distribution](/build/internal-distribution) to share your app with an APK on Android and ad-hoc or enterprise provisioning on iOS.
## Can I develop iOS apps on a Windows computer?
Traditionally you needed a macOS to develop iOS apps, however, you can use [EAS Build](/build/introduction) to build your app in the cloud. You can also use [EAS Submit](/submit/introduction) to submit your app to the stores. Testing can be done on a physical iOS device using [Expo Go](https://expo.dev/go) or a [development build](/develop/development-builds/introduction/).
## What versions of Android and iOS are supported by the Expo SDK?
Currently, Expo SDK supports Android {latestSdkVersionValues.android} and iOS {latestSdkVersionValues.ios}. For more information, see [Support for Android and iOS versions](/versions/latest/#support-for-android-and-ios-versions).
## What is the minimal size of a "hello world" expo app?
A bare minimum production app created using pure Expo is less than 3 MB. For iOS, Expo targets a newer minimum iOS version which enables app store optimizations.
If the `expo` package is included in your app, it only adds 1 MB one time to the final size of apps on app stores. The `expo` package has a marginal size cost (for example, 150 Kib on Android). The rest of the size comes from the language runtime (such as Kotlin on Android).
## Can I use Expo with my native library?
You can use native Android and iOS libraries with Expo by creating a [custom native module](/modules) with Swift and Kotlin. Many popular libraries already have custom native modules. Check out our [React Native directory](https://reactnative.directory) to find popular libraries for your use case.
## Can I use Expo with this web library?
Many popular web packages such as three.js work with Expo and React Native. See [Expo examples](https://github.com/expo/examples) for more information.
## Is Expo similar to React for web development?
Expo is an [open-source framework](https://github.com/expo/expo) for apps that run natively on Android, iOS, and the web. React Native is similar to `react-dom` from web development, enabling you to run React on a particular platform, however, it has a few key differences:
- React Native does not support HTML or CSS.
- Instead of using the DOM, React Native uses native components. For example, `<View />` instead of `<div />`. Native components are more performant than the DOM and provide a much nicer user experience.
- Unlike React.js which has access to browser APIs, React Native uses custom native APIs. For example, instead of `navigator.geolocation`, you use `expo-location` to access the user's location. Custom native APIs are similar to browser APIs except you have full control over them. This means you can access new features before they are available in the browser.
In the same way React.js frameworks help users create larger websites with ease, Expo helps users create larger apps with ease. Expo provides a suite of well-tested React Native modules that run on Android, iOS, and the web. Expo also provides a [suite of tools](/eas) for building, deploying, and updating your app.
## What are the store policies regarding interpreted code?
React Native uses a JavaScript interpreter (JSC, V8, or Hermes) to run your application code. Refer to the [Google Play Policy Center](https://play.google/developer-content-policy/) and [Apple Developer Program License Agreement](https://developer.apple.com/support/terms/apple-developer-program-license-agreement) directly for the most up-to-date policy information.
_The following are excerpts of related policies, as of April 25, 2024._
### Google Play Store
```text
...an app may not download executable code (such as dex, JAR, .so files) from a
source other than Google Play. This restriction does not apply to code that runs
in a virtual machine or an interpreter where either provides indirect access to
Android APIs (such as JavaScript in a webview or browser).
Apps or third-party code, like SDKs, with interpreted languages (JavaScript,
Python, Lua, etc.) loaded at run time (for example, not packaged with the app)
must not allow potential violations of Google Play policies.
```
Source: [Google Play Policy Center](https://support.google.com/googleplay/android-developer/answer/9888379?hl=en).
### Apple App Store
```text
...Interpreted code may be downloaded to an Application but only so long as such code:
(a) does not change the primary purpose of the Application by providing features
    or functionality that are inconsistent with the intended and advertised purpose
    of the Application as submitted to the App Store,
(b) does not create a store or storefront for other code or applications, and
(c) does not bypass signing, sandbox, or other security features of the OS.
```
Source: [3.3.1 APIs and Functionality - B. Executable Code](https://developer.apple.com/support/terms/apple-developer-program-license-agreement#b331).
## Should I use Expo CLI or React Native Community CLI?
Expo CLI offers the same core functionality as React Native Community CLI (also known as "React Native CLI") with additional features such as automatic [TypeScript setup](/guides/typescript), [web support](/workflow/web), [auto installing compatible libraries](/more/expo-cli/#install), [improved native build commands](/more/expo-cli#compiling), [tunneling](/more/expo-cli#tunneling), [Prebuild](/workflow/prebuild), and [more](/more/expo-cli).
It can be used simultaneously with React Native Community. Regardless of which CLI you use, you can use any part of the [Expo SDK](/versions/latest/) and [Expo Application Services](/eas) with your project. For more information, see:
- Learn how you can migrate to use Expo CLI in an [existing React Native project](/bare/using-expo-cli/).
- Learn about the benefits of [using a framework to build React Native apps](https://reactnative.dev/blog/2024/06/25/use-a-framework-to-build-react-native-apps).
- Learn about the benefits of migrating to Expo CLI such as improved app performance, expedites release, and fostering stronger collaboration across you team in [this blog post](https://expo.dev/blog/from-rnc-cli-to-expo).
> **Note:** EAS Build is compatible with existing React Native projects (where native directories are checked into version control). When these directories are present, EAS Build does not run the prebuild step, as that could overwrite any manual customizations you have made to the native project files. You'll have to configure the native directories on your own with native tools such as Android Studio or Xcode.
## Is Expo Go open source?
Yes, the source for Expo Go can be found in the [expo/expo GitHub repository](https://github.com/expo/expo) in the **apps/expo-go** directory. The Expo Go app is also built with Expo and React Native.
## What can I do or cannot do with Expo Go?
[Expo Go](/get-started/set-up-your-environment/?redirected=#how-would-you-like-to-develop) is a sandbox that can help you get started quickly with React Native development in order to learn, prototype, or experiment. It allows you to use libraries included in the Expo SDK and libraries that don't require custom native code.
Expo Go cannot use third-party libraries that require custom native code and you cannot edit native code directly in Expo Go. It cannot be used for production apps.
**We strongly recommend any projects that require additional libraries with native code to migrate to [development builds](/develop/development-builds/introduction/). It's like creating a version of Expo Go that is specifically customized to your app's needs.**
## Is ejecting deprecated?
Yes, eject is a deprecated term and is no longer necessary. When Expo was first released, apps had larger native binary sizes and didn't support custom native code without "ejecting". This changed in December 2020 with the release of [EAS Build](/build/introduction) which supports any React Native app. The concept of "ejecting" was replaced by the [`npx expo prebuild`](/workflow/prebuild) command in SDK 41 (April 2021), which continuously generates native projects based on the libraries in your project and the app config (**app.json**). The `expo eject` command was fully deprecated in SDK 46 (August 2022).
Unlike the previous eject workflow, authors can configure their libraries to work with Expo Prebuild by creating a [config plugin](/config-plugins/introduction/). This means you can use any library with Expo Prebuild. You can also use any custom native code with Expo Prebuild by creating a [development build](/develop/development-builds/introduction/). Learn more in the [Expo Prebuild documentation](/workflow/prebuild).


## Documentation for LLMs

A list of Expo and EAS documentation files available for large language models (LLMs) and apps that use them.

At Expo, we support the [llms.txt](https://llmstxt.org/) initiative to provide documentation for large language models (LLMs) and apps that use them. Below is a list of documentation files available:
- [/llms.txt](/llms.txt): A list of all available documentation files
- [/llms-full.txt](/llms-full.txt): Complete documentation for Expo, including Expo Router, Expo Modules API, development process, and more
- [/llms-eas.txt](/llms-eas.txt): Complete documentation for the Expo Application Services (EAS)
- [/llms-sdk.txt](/llms-sdk.txt): Complete documentation for the latest Expo SDK
Note: Looking for deprecated Expo SDK versions?
---
- [/llms-sdk-v53.0.0.txt](/llms-sdk-v53.0.0.txt): Documentation for the Expo SDK v53.0.0
- [/llms-sdk-v52.0.0.txt](/llms-sdk-v52.0.0.txt): Documentation for the Expo SDK v52.0.0
- [/llms-sdk-v51.0.0.txt](/llms-sdk-v51.0.0.txt): Documentation for the Expo SDK v51.0.0
---


## Overview of tutorials and UI guides

The **Learn** section is a collection of tutorials and other guides that help you learn about Expo and EAS. It covers the following:


# Expo tutorial

## Tutorial: Using React Native and Expo

An introduction to a React Native tutorial on how to build a universal app that runs on Android, iOS and the web using Expo.

We're about to embark on a journey of building universal apps. In this tutorial, we'll create an Expo app that runs on Android, iOS, and web; all with a single codebase. Let's get started!
## About React Native and Expo tutorial
The objective of this tutorial is to get started with Expo and become familiar with the Expo SDK. It'll cover the following topics:
- Create an app using the default template with TypeScript enabled
- Implement a two-screen bottom tabs layout with Expo Router
- Break down the app layout and implement it with flexbox
- Use each platform's system UI to select an image from the media library
- Create a sticker modal using the `<Modal>` and `<FlatList>` components from React Native
- Add touch gestures to interact with a sticker
- Use third-party libraries to capture a screenshot and save it to the disk
- Handle platform differences between Android, iOS, and web
- Finally, go through the process of configuring a status bar, a splash screen, and an icon to complete the app
These topics provide a foundation to learn the fundamentals of building an Expo app. The tutorial is self-paced and can take up to two hours to complete.
To keep it beginner friendly, we divided the tutorial into nine chapters so that you can follow along or put it down and come back to it later. Each chapter contains the necessary code snippets to complete the steps, so you can follow along by creating an app from scratch or copy and paste it.
Before we get started, take a look at what we'll build. It's an app named **StickerSmash** that runs on Android, iOS, and the web:
> **info** The complete source code for this tutorial is available on [GitHub](https://github.com/expo/examples/tree/master/stickersmash).
## How to use this tutorial
We believe in [learning by doing](https://en.wikipedia.org/wiki/Learning-by-doing), so this tutorial emphasizes doing over explaining. You can follow along the journey of building an app by creating the app from scratch.
Throughout the tutorial, any important code or code that has changed between examples will be <span className="tutorial-code-annotation">highlighted in green</span>. You can hover over the highlights (on desktop) or tap them (on mobile) to learn more about the change. For example, the code highlighted in the snippet below explains what it does:
```tsx Hello World|collapseHeight=300
import { StyleSheet, Text, View } from 'react-native';
export default function Index() {
  return (
    <View style={styles.container}>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
## Next step
We're ready to start building our app.


## Create your first app

In this chapter, learn how to create a new Expo project.

In this chapter, let's learn how to create a new Expo project and how to get it running.
Video Tutorial: [Watch: Creating your first universal Expo app](https://www.youtube.com/watch?v=m1-bc53EGh8)
---
## Prerequisites
We'll need the following to get started:
- [Expo Go](https://expo.dev/go) installed on a physical device
- [Node.js (LTS version)](https://nodejs.org/en) installed
- [VS Code](https://code.visualstudio.com/) or any other preferred code editor or IDE installed
- A macOS, Linux, or Windows (PowerShell and [WSL2](https://expo.fyi/wsl)) with a terminal window open
The tutorial assumes that you are familiar with TypeScript and React. If you are not familiar with them, check out the [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html) and [React's official tutorial](https://react.dev/learn).
Step 1: 
## Initialize a new Expo app
We'll use [`create-expo-app`](/more/create-expo/) to initialize a new Expo app. It is a command line tool to create a new React Native project. Run the following command in your terminal:
```sh
$ npx create-expo-app@latest StickerSmash
$ cd StickerSmash
```
This command will create a new project directory named StickerSmash, using the [default](/more/create-expo/#--template) template. This template has essential boilerplate code and libraries needed to build our app, including Expo Router. We'll continue to add more libraries throughout this tutorial as needed.
Note: Benefits of using the default template
---
- Creates a new React Native project with `expo` package installed
- Includes recommended tools such as Expo CLI
- Includes a tab navigator from Expo Router to provide a basic navigation system
- Automatically configured to run a project on multiple platforms: Android, iOS, and web
- TypeScript configured by default
---
Step 2: 
## Download assets
After downloading the archive:
1. Unzip the archive and replace the default assets in the **your-project-name/assets/images** directory.
2. Open the project directory in a code editor or IDE.
Step 3: 
## Run reset-project script
In this tutorial, we'll build our app from scratch and understand the fundamentals of adding a file-based navigation. Let's run the `reset-project` script to remove the boilerplate code:
```sh
$ npm run reset-project
```
After running the above command, there are two files (**index.tsx** and **\_layout.tsx**) left inside the **app** directory. The previous files from **app** and other directories (**components**, **constants**, and **hooks** &mdash; containing boilerplate code) are moved inside the **app-example** directory by the script. We'll create our own directories and component files as we go along.
Note: What does the  script do?
---
`reset-project` script resets the **app** directory structure in a project and copies the previous boilerplate files from the project's root directory to another sub-directory called **app-example**. We can delete it since it is not part of our main app's structure.
---
Step 4: 
## Run the app on mobile and web
In the project directory, run the following command to start the [development server](/more/glossary-of-terms/#development-server) from the terminal:
```sh
$ npx expo start
```
After running the above command:
1. The development server will start, and you'll see a QR code inside the terminal window.
2. Scan that QR code to open the app on the device. On Android, use the Expo Go > **Scan QR code** option. On iOS, use the default camera app.
3. To run the web app, press <kbd>w</kbd> in the terminal. It will open the web app in the default web browser.
Once it is running on all platforms, the app should look like this:
Step 5: 
## Edit the index screen
The **app/index.tsx** file defines the text displayed on the app's screen. It is the entry point of our app and executes when the development server starts. It uses core React Native components such as `<View>` and `<Text>` to display background and text.
Styles applied to these components use JavaScript objects rather than CSS, which is used on web. However, a lot of the properties will look familiar if you've previously used CSS on web. Most React Native components accept a `style` prop that accepts a JavaScript object as its value. For more details, see [Styling in React Native](https://reactnative.dev/docs/style).
Let's modify **app/index.tsx** screen:
1. Import `StyleSheet` from `react-native` and create a `styles` object to define our custom styles.
2. Add a `styles.container.backgroundColor` property to `<View>` with the value of `#25292e`. This changes the background color.
3. Replace the default value of `<Text>` with "Home screen".
4. Add a `styles.text.color` property to `<Text>` with the value of `#fff` (white) to change the text color.
```tsx app/index.tsx|collapseHeight=340
export default function Index() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home screen</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    color: '#fff',
  },
});
```
> React Native uses the same color format as the web. It supports hex triplets (this is what `#fff` is), `rgba`, `hsl`, and named colors, such as `red`, `green`, `blue`, `peru`, and `papayawhip`. For more information, see [Colors in React Native](https://reactnative.dev/docs/colors).
Once you save your changes, they're sent and applied to the running apps connected to the development server:
## Summary
<ProgressTracker
  currentChapterIndex={0}
  name="GET_STARTED"
  summary="We've successfully created a new Expo project, used React Native core components, and are ready to develop our StickerSmash app."
  nextChapterDescription="In the next chapter, we will learn how to add a stack and a tab navigator to our app."
  nextChapterTitle="Add navigation"
  nextChapterLink="/tutorial/add-navigation/"
/>


## Add navigation

In this chapter, learn how to add navigation to the Expo app.

In this chapter, we'll learn Expo Router's fundamentals to create stack navigation and a bottom tab bar with two tabs.
Video Tutorial: [Watch: Adding navigation in your universal Expo app](https://www.youtube.com/watch?v=8336fcFV_T4)
## Expo Router basics
Expo Router is a file-based routing framework for React Native and web apps. It manages navigation between screens and uses the same components across multiple platforms. To get started, we need to know about the following conventions:
- **app directory**: A special directory containing only routes and their layouts. Any files added to this directory become a screen inside our native app and a page on the web.
- **Root layout**: The **app/\_layout.tsx** file. It defines shared UI elements such as headers and tab bars so they are consistent between different routes.
- **File name conventions**: _Index_ file names, such as **index.tsx**, match their parent directory and do not add a path segment. For example, the **index.tsx** file in the **app** directory matches `/` route.
- A **route** file exports a React component as its default value. It can use either `.js`, `.jsx`, `.ts`, or `.tsx` extension.
- Android, iOS, and web share a unified navigation structure.
> The above list is enough for us to get started. For a complete list of features, see [Introduction to Expo Router](/router/introduction/).
Step 1: 
## Add a new screen to the stack
Let's create a new file named **about.tsx** inside the **app** directory. It displays the screen name when the user navigates to the `/about` route.
```tsx app/about.tsx|collapseHeight=300
import { Text, View, StyleSheet } from 'react-native';
export default function AboutScreen() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>About screen</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: '#fff',
  },
});
```
Inside **app/\_layout.tsx**:
1. Add a `<Stack.Screen />` component and an `options` prop to update the title of the `/about` route.
2. Update the `/index` route's title to `Home` by adding `options` prop.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function RootLayout() {
  return (
    <Stack>
      <Stack.Screen name="index" options={{ title: 'Home' }} />
      <Stack.Screen name="about" options={{ title: 'About' }} />
    </Stack>
  );
}
```
Note: What is a ?
---
A stack navigator is the foundation for navigating between different screens in an app. On Android, a stacked route animates on top of the current screen. On iOS, a stacked route animates from the right. Expo Router provides a `Stack` component to create a navigation stack to add new routes.
---
Step 2: 
## Navigate between screens
We'll use Expo Router's `Link` component to navigate from the `/index` route to the `/about` route. It is a React component that renders a `<Text>` with a given `href` prop.
1. Import the `Link` component from `expo-router` inside **index.tsx**.
2. Add a `Link` component after `<Text>` component and pass `href` prop with the `/about` route.
3. Add a style of `fontSize`, `textDecorationLine`, and `color` to `Link` component. It takes the same props as the `<Text>` component.
```tsx app/index.tsx|collapseHeight=300
import { Text, View, StyleSheet } from 'react-native';
export default function Index() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Home screen</Text>
      <Link href="/about" style={styles.button}>
        Go to About screen
      </Link>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
    justifyContent: 'center',
  },
  text: {
    color: '#fff',
  },
  button: {
    fontSize: 20,
    textDecorationLine: 'underline',
    color: '#fff',
  },
});
```
Let's take a look at the changes in our app. Click on `Link` to navigate to the `/about` route:
Step 3: 
## Add a not-found route
When a route doesn't exist, we can use a `+not-found` route to display a fallback screen. This is useful when we want to display a custom screen when navigating to an invalid route on mobile instead of crashing the app or display a _404_ error on web. Expo Router uses a special **+not-found.tsx** file to handle this case.
1. Create a new file named **+not-found.tsx** inside the app directory to add the `NotFoundScreen` component.
2. Add `options` prop from the `Stack.Screen` to display a custom screen title for this route.
3. Add a `Link` component to navigate to the `/` route, which is our fallback route.
```tsx app/+not-found.tsx
import { View, StyleSheet } from 'react-native';
import { Link, Stack } from 'expo-router';
export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops! Not Found' }} />
      <View style={styles.container}>
        <Link href="/" style={styles.button}>
          Go back to Home screen!
        </Link>
      </View>
    </>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    justifyContent: 'center',
    alignItems: 'center',
  },
  button: {
    fontSize: 20,
    textDecorationLine: 'underline',
    color: '#fff',
  },
});
```
To test this, navigate to `http:localhost:8081/123` URL in the web browser since it is easy to change the URL path there. The app should display the `NotFoundScreen` component:
Step 4: 
## Add a bottom tab navigator
At this point, the file structure of our **app** directory looks like the following:
```
└── app/
    ├── _layout.tsx  # Root layout
    ├── index.tsx  # matches route '/'
    ├── about.tsx  # matches route '/about'
    └── +not-found.tsx  # matches route any 404 route
```
We'll add a bottom tab navigator to our app and reuse the existing Home and About screens to create a tab layout (a common navigation pattern in many social media apps like X or BlueSky). We'll also use the stack navigator in the Root layout so the `+not-found` route displays over any other nested navigators.
1. Inside the **app** directory, add a **(tabs)** subdirectory. This special directory is used to group routes together and display them in a bottom tab bar.
2. Create a **(tabs)/\_layout.tsx** file inside the directory. It will be used to define the tab layout, which is separate from Root layout.
3. Move the existing **index.tsx** and **about.tsx** files inside the **(tabs)** directory. The structure of **app** directory will look like this:
```
└── app/
    ├── _layout.tsx  # Root layout
    ├── +not-found.tsx  # matches route any 404 route
    └── (tabs)/
        ├── _layout.tsx  # Tab layout
        ├── index.tsx  # matches route '/'
        └── about.tsx  # matches route '/about'
```
Update the Root layout file to add a `(tabs)` route:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function RootLayout() {
  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
    </Stack>
  );
}
```
Inside **(tabs)/\_layout.tsx**, add a `Tabs` component to define the bottom tab layout:
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen name="index" options={{ title: 'Home' }} />
      <Tabs.Screen name="about" options={{ title: 'About' }} />
    </Tabs>
  );
}
```
Let's take a look at our app now to see the new bottom tabs:
Step 5: 
## Update bottom tab navigator appearance
Right now, the bottom tab navigator looks the same on all platforms but doesn't match the style of our app. For example, the tab bar or header doesn't display a custom icon, and the bottom tab background color doesn't match the app's background color.
Modify the **(tabs)/\_layout.tsx** file to add tab bar icons:
1. Import `Ionicons` icons set from [`@expo/vector-icons`](/guides/icons/#expovector-icons) &mdash; a library that includes popular icon sets.
2. Add the `tabBarIcon` to both the `index` and `about` routes. This function takes `focused` and `color` as params and renders the icon component. From the icon set, we can provide custom icon names.
3. Add `screenOptions.tabBarActiveTintColor` to the `Tabs` component and set its value to `#ffd33d`. This will change the color of the tab bar icon and label when active.
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
import Ionicons from '@expo/vector-icons/Ionicons';
export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: '#ffd33d',
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, focused }) => (
            <Ionicons name={focused ? 'home-sharp' : 'home-outline'} color={color} size={24} />
          ),
        }}
      />
      <Tabs.Screen
        name="about"
        options={{
          title: 'About',
          tabBarIcon: ({ color, focused }) => (
            <Ionicons name={focused ? 'information-circle' : 'information-circle-outline'} color={color} size={24}/>
          ),
        }}
      />
    </Tabs>
  );
}
```
Let's also change the background color of the tab bar and header using `screenOptions` prop:
```tsx app/(tabs)/_layout.tsx
<Tabs
  screenOptions={{
    tabBarActiveTintColor: '#ffd33d',
    headerStyle: {
      backgroundColor: '#25292e',
    },
    headerShadowVisible: false,
    headerTintColor: '#fff',
    tabBarStyle: {
      backgroundColor: '#25292e',
    },
  }}
>
```
In the above code:
- The header's background is set to `#25292e` using the `headerStyle` property. We have also disabled the header's shadow using `headerShadowVisible`.
- `headerTintColor` applies `#fff` to the header label
- `tabBarStyle.backgroundColor` applies `#25292e` to the tab bar
Our app now has a custom bottom tabs navigator:
## Summary
<ProgressTracker
  currentChapterIndex={1}
  name="GET_STARTED"
  summary="We've successfully added a stack and a tab navigator to our app."
  nextChapterDescription="In the next chapter, we'll learn how to build the app's first screen."
  nextChapterTitle="Build your app's first screen"
  nextChapterLink="/tutorial/build-a-screen"
/>


## Build a screen

In this tutorial, learn how to use components such as React Native's Pressable and Expo Image to build a screen.

In this chapter, we'll create the first screen of the StickerSmash app.
The screen above displays an image and two buttons. The app user can select an image using one of the two buttons. The first button allows the user to select an image from their device. The second button allows the user to continue with a default image provided by the app.
Once the user selects an image, they can add a sticker to it. So, let's start creating this screen.
Video Tutorial: [Watch: Building a screen in your universal Expo app](https://www.youtube.com/watch?v=3rcOP8xDwTQ)
---
Step 1: 
## Break down the screen
Before we build this screen by writing code, let's break it down into some essential elements.
There are two essential elements:
- There is a large image displayed at the center of the screen
- There are two buttons in the bottom half of the screen
The first button contains multiple components. The parent element provides a yellow border, and contains an icon and text components inside a row.
Now that we've broken down the UI into smaller chunks, we're ready to start coding.
Step 2: 
## Display the image
We'll use `expo-image` library to display the image in the app. It provides a cross-platform `<Image>` component to load and render an image.
Stop the development server by pressing <kbd>Ctrl</kbd> + <kbd>c</kbd> in the terminal. Then, install the `expo-image` library:
```sh
$ npx expo install expo-image
```
The [`npx expo install`](/more/expo-cli/#installation) command will install the library and add it to the project's dependencies in **package.json**.
> **info** **Tip:** Any time we install a new library in our project, stop the development server by pressing <kbd>Ctrl</kbd> + <kbd>c</kbd> in the terminal and then run the installation command. After the installation completes, we can start the development server again by running `npx expo start` from the same terminal window.
The Image component takes the source of an image as its value. The source can be either a [static asset](https://reactnative.dev/docs/images#static-image-resources) or a URL. For example, the source required from **assets/images** directory is static. It can also come from [Network](https://reactnative.dev/docs/images#network-images) as a `uri` property.
To use the Image component in **app/(tabs)/index.tsx** file:
1. Import `Image` from the `expo-image` library.
2. Create a `PlaceholderImage` variable to use **assets/images/background-image.png** file as the `source` prop on the `Image` component.
```tsx app/(tabs)/index.tsx|collapseHeight=380
import { View, StyleSheet } from 'react-native';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <Image source={PlaceholderImage} style={styles.image} />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  image: {
    width: 320,
    height: 440,
    borderRadius: 18,
  },
});
```
Step 3: 
## Divide components into files
Let's divide the code into multiple files as we add more components to this screen. Throughout this tutorial, we'll use the components directory to create custom components.
1. Create a top-level **components** directory, and inside it, create the **ImageViewer.tsx** file.
2. Move the code to display the image in this file along with the `image` styles.
```tsx components/ImageViewer.tsx|collapseHeight=280
import { ImageSourcePropType, StyleSheet } from 'react-native';
import { Image } from 'expo-image';
type Props = {
  imgSource: ImageSourcePropType;
};
export default function ImageViewer({ imgSource }: Props) {
  return <Image source={imgSource} style={styles.image} />;
}
const styles = StyleSheet.create({
  image: {
    width: 320,
    height: 440,
    borderRadius: 18,
  },
});
```
> **info** Since **ImageViewer** is a custom component, we are placing it in a separate directory instead of the **app** directory. Every file inside **app** directory is either a layout file or a route file. For more information, see [Non-navigation components live outside of app directory](/router/basics/core-concepts/#5-non-navigation-components-live-outside-of-app-directory).
Import `ImageViewer` and use it in the **app/(tabs)/index.tsx**:
```tsx app/(tabs)/index.tsx|collapseHeight=320
import { StyleSheet, View } from 'react-native';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
});
```
Note: What is the  in import statement?
---
The `@` symbol is a custom [path alias](/guides/typescript/#path-aliases-optional) for importing custom components and other modules instead of relative paths. Expo CLI automatically configures it in **tsconfig.json**.
---
Step 4: 
## Create buttons using Pressable
React Native includes a few different components for handling touch events, but [`<Pressable>`](https://reactnative.dev/docs/pressable) is recommended for its flexibility. It can detect single taps, long presses, trigger separate events when the button is pushed in and released, and more.
In the design, there are two buttons we need to create. Each has a different style and label. Let's start by creating a reusable component for these buttons. Create a **Button.tsx** file inside the **components** directory with the following code:
```tsx components/Button.tsx|collapseHeight=280
import { StyleSheet, View, Pressable, Text } from 'react-native';
type Props = {
  label: string;
};
export default function Button({ label }: Props) {
  return (
    <View style={styles.buttonContainer}>
      <Pressable style={styles.button} onPress={() => alert('You pressed a button.')}>
        <Text style={styles.buttonLabel}>{label}</Text>
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  buttonContainer: {
    width: 320,
    height: 68,
    marginHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 3,
  },
  button: {
    borderRadius: 10,
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  buttonLabel: {
    color: '#fff',
    fontSize: 16,
  },
});
```
The app displays an alert when the user taps any of the buttons on the screen. It happens because `<Pressable>` calls `alert()` on its `onPress` prop. Let's import this component into **app/(tabs)/index.tsx** file and add styles for the `<View>` that encapsulates these buttons:
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import ImageViewer from '@/components/ImageViewer';
const PlaceholderImage = require("@/assets/images/background-image.png");
export default function Index() {
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} />
      </View>
      <View style={styles.footerContainer}>
        <Button label="Choose a photo" />
        <Button label="Use this photo" />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
    paddingTop: 28,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
});
```
Let's take a look at our app on Android, iOS and the web:
The second button with the label "Use this photo" resembles the actual button from the design. However, the first button needs more styling to match the design.
Step 5: 
## Enhance the reusable button component
The "Choose a photo" button requires different styling than the "Use this photo" button, so we will add a new button theme prop that will allow us to apply a `primary` theme. This button also has an icon before the label. We will use an icon from the `@expo/vector-icons` library.
To load and display the icon on the button, let's use `FontAwesome` from the library. Modify **components/Button.tsx** to add the following code snippet:
```tsx components/Button.tsx
import { StyleSheet, View, Pressable, Text } from 'react-native';
type Props = {
  label: string;
};
  if (theme === 'primary') {
    return (
      <View
        style={[
          styles.buttonContainer,
          { borderWidth: 4, borderColor: '#ffd33d', borderRadius: 18 },
        ]}>
        <Pressable
          style={[styles.button, { backgroundColor: '#fff' }]}
          onPress={() => alert('You pressed a button.')}>
          <FontAwesome name="picture-o" size={18} color="#25292e" style={styles.buttonIcon} />
          <Text style={[styles.buttonLabel, { color: '#25292e' }]}>{label}</Text>
        </Pressable>
      </View>
    );
  }
  return (
    <View style={styles.buttonContainer}>
      <Pressable style={styles.button} onPress={() => alert('You pressed a button.')}>
        <Text style={styles.buttonLabel}>{label}</Text>
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  buttonContainer: {
    width: 320,
    height: 68,
    marginHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 3,
  },
  button: {
    borderRadius: 10,
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  buttonIcon: {
    paddingRight: 8,
  },
  buttonLabel: {
    color: '#fff',
    fontSize: 16,
  },
});
```
Let's learn what the above code does:
- The primary theme button uses **inline styles**, which overrides the styles defined in `StyleSheet.create()` with an object directly passed in the `style` prop.
- The `<Pressable>` component in the primary theme uses a `backgroundColor` property with a value `#fff` to set the button's background to white. If we add this property to the `styles.button`, the background color value will be set for both the primary theme and the unstyled one.
- Inline styles use JavaScript and override the default styles for a specific value.
Now, modify the **app/(tabs)/index.tsx** file to use the `theme="primary"` prop on the first button.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} />
      </View>
      <View style={styles.footerContainer}>
        <Button theme="primary" label="Choose a photo" />
        <Button label="Use this photo" />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
});
```
Let's take a look at our app on Android, iOS and the web:
## Summary
<ProgressTracker
  currentChapterIndex={2}
  name="GET_STARTED"
  summary="We've successfully implemented the initial design to start building our app's first screen."
  nextChapterDescription="In the next chapter, we'll add the functionality to pick an image from the device's media library."
  nextChapterTitle="Use an image picker"
  nextChapterLink="/tutorial/image-picker"
/>


## Use an image picker

In this tutorial, learn how to use Expo Image Picker.

React Native provides built-in components as standard building blocks, such as `<View>`, `<Text>`, and `<Pressable>`. We are building a feature to select an image from the device's media gallery. This isn't possible with the core components and we'll need a library to add this feature in our app.
We'll use [`expo-image-picker`](/versions/latest/sdk/imagepicker), a library from Expo SDK.
> `expo-image-picker` provides access to the system's UI to select images and videos from the phone's library.
Video Tutorial: [Watch: Using an image picker in your universal Expo app](https://www.youtube.com/watch?v=iEQZU58naS8)
---
Step 1: 
## Install expo-image-picker
To install the library, run the following command:
```sh
$ npx expo install expo-image-picker
```
Step 2: 
## Pick an image from the device's media library
`expo-image-picker` provides `launchImageLibraryAsync()` method to display the system UI by choosing an image or a video from the device's media library. We'll use the primary themed button created in the previous chapter to select an image from the device's media library and create a function to launch the device's image library to implement this functionality.
In **app/(tabs)/index.tsx**, import `expo-image-picker` library and create a `pickImageAsync()` function inside the `Index` component:
```tsx app/(tabs)/index.tsx|collapseHeight=440
// ...rest of the import statements remain unchanged
export default function Index() {
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      console.log(result);
    } else {
      alert('You did not select any image.');
    }
  };
  // ...rest of the code remains same
}
```
Let's learn what the above code does:
- The `launchImageLibraryAsync()` receives an object to specify different options. This object is the [`ImagePickerOptions`](/versions/latest/sdk/imagepicker/#imagepickeroptions) object, which we are passing when invoking the method.
- When `allowsEditing` is set to `true`, the user can crop the image during the selection process on Android and iOS.
Step 3: 
## Update the button component
On pressing the primary button, we'll call the `pickImageAsync()` function on the `Button` component. Update the `onPress` prop of the `Button` component in **components/Button.tsx**:
```tsx components/Button.tsx
import { StyleSheet, View, Pressable, Text } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';
type Props = {
  label: string;
  theme?: 'primary';
  onPress?: () => void;
};
  if (theme === 'primary') {
    return (
      <View
        style={[
          styles.buttonContainer,
          { borderWidth: 4, borderColor: '#ffd33d', borderRadius: 18 },
        ]}>
          <FontAwesome name="picture-o" size={18} color="#25292e" style={styles.buttonIcon} />
          <Text style={[styles.buttonLabel, { color: '#25292e' }]}>{label}</Text>
        </Pressable>
      </View>
    );
  }
  return (
    <View style={styles.buttonContainer}>
      <Pressable style={styles.button} onPress={() => alert('You pressed a button.')}>
        <Text style={styles.buttonLabel}>{label}</Text>
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  buttonContainer: {
    width: 320,
    height: 68,
    marginHorizontal: 20,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 3,
  },
  button: {
    borderRadius: 10,
    width: '100%',
    height: '100%',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
  },
  buttonIcon: {
    paddingRight: 8,
  },
  buttonLabel: {
    color: '#fff',
    fontSize: 16,
  },
});
```
In **app/(tabs)/index.tsx**, add the `pickImageAsync()` function to the `onPress` prop on the first `<Button>`.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      console.log(result);
    } else {
      alert('You did not select any image.');
    }
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} />
      </View>
      <View style={styles.footerContainer}>
        <Button label="Use this photo" />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
});
```
The `pickImageAsync()` function invokes `ImagePicker.launchImageLibraryAsync()` and then handles the result. The `launchImageLibraryAsync()` method returns an object containing information about the selected image.
Here is an example of the `result` object and the properties it contains:
For Android: 
```json collapseHeight=280
{
  "assets": [
    {
      "assetId": null,
      "base64": null,
      "duration": null,
      "exif": null,
      "fileName": "ea574eaa-f332-44a7-85b7-99704c22b402.jpeg",
      "fileSize": 4513577,
      "height": 4570,
      "mimeType": "image/jpeg",
      "rotation": null,
      "type": "image",
      "uri": "file:///data/user/0/host.exp.exponent/cache/ExperienceData/%2540anonymous%252FStickerSmash-13f21121-fc9d-4ec6-bf89-bf7d6165eb69/ImagePicker/ea574eaa-f332-44a7-85b7-99704c22b402.jpeg",
      "width": 2854
    }
  ],
  "canceled": false
}
```
For iOS: 
```json collapseHeight=280
{
  "assets": [
    {
      "assetId": "99D53A1F-FEEF-40E1-8BB3-7DD55A43C8B7/L0/001",
      "base64": null,
      "duration": null,
      "exif": null,
      "fileName": "IMG_0004.JPG",
      "fileSize": 2548364,
      "height": 1669,
      "mimeType": "image/jpeg",
      "type": "image",
      "uri": "file:///data/user/0/host.exp.exponent/cache/ExperienceData/%2540anonymous%252FStickerSmash-13f21121-fc9d-4ec6-bf89-bf7d6165eb69/ImagePicker/ea574eaa-f332-44a7-85b7-99704c22b402.jpeg",
      "width": 1668
    }
  ],
  "canceled": false
}
```
For web: 
```json
{
  "assets": [
    {
      "fileName": "some-image.png",
      "height": 720,
      "mimeType": "image/png",
      "uri": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAA"
    }
  ],
  "canceled": false
}
```
Step 4: 
## Use the selected image
The `result` object provides the `assets` array, which contains the `uri` of the selected image. Let's take this value from the image picker and use it to show the selected image in the app.
Modify the **app/(tabs)/index.tsx** file:
1. Declare a state variable called `selectedImage` using the [`useState`](https://react.dev/learn/state-a-components-memory#adding-a-state-variable) hook from React. We'll use this state variable to hold the URI of the selected image.
2. Update the `pickImageAsync()` function to save the image URI in the `selectedImage` state variable.
3. Pass the `selectedImage` as a prop to the `ImageViewer` component.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
    } else {
      alert('You did not select any image.');
    }
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
      </View>
      <View style={styles.footerContainer}>
        <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
        <Button label="Use this photo" />
      </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
});
```
Pass the `selectedImage` prop to the `ImageViewer` component to display the selected image instead of a placeholder image.
1. Modify the **components/ImageViewer.tsx** file to accept the `selectedImage` prop.
2. The source of the image is getting long, so let's also move it to a separate variable called `imageSource`.
3. Pass `imageSource` as the value of the `source` prop on the `Image` component.
```tsx components/ImageViewer.tsx
import { ImageSourcePropType, StyleSheet } from 'react-native';
import { Image } from 'expo-image';
type Props = {
  imgSource: ImageSourcePropType;
  selectedImage?: string;
};
  const imageSource = selectedImage ? { uri: selectedImage } : imgSource;
  return <Image source={imageSource} style={styles.image} />;
}
const styles = StyleSheet.create({
  image: {
    width: 320,
    height: 440,
    borderRadius: 18,
  },
});
```
In the above snippet, the Image component uses a conditional operator to load the image's source. The picked image is a [`uri` string](https://reactnative.dev/docs/images#network-images), not a local asset like the placeholder image.
Let's take a look at our app now:
> The images used for the example app in this tutorial were picked from [Unsplash](https://unsplash.com).
## Summary
<ProgressTracker
  currentChapterIndex={3}
  name="GET_STARTED"
  summary="We've successfully added the functionality to pick an image from the device's media library."
  nextChapterDescription="In the next chapter, we'll learn how to create an emoji picker modal component."
  nextChapterTitle="Create an emoji picker modal"
  nextChapterLink="/tutorial/create-a-modal"
/>


## Create a modal

In this tutorial, learn how to create a React Native modal to select an image.

React Native provides a [`<Modal>` component](https://reactnative.dev/docs/modal) that presents content above the rest of your app. In general, modals are used to draw a user's attention toward critical information or guide them to take action. For example, in the [third chapter](/tutorial/build-a-screen/#step-7-enhance-the-reusable-button-component), after pressing the button, we used `alert()` to display some placeholder text. That's how a modal component displays an overlay.
In this chapter, we'll create a modal that shows an emoji picker list.
Video Tutorial: [Watch: Creating a modal in your universal Expo app](https://www.youtube.com/watch?v=HRAMzrBwVeo)
---
Step 1: 
## Declare a state variable to show buttons
Before implementing the modal, we are going to add three new buttons. These buttons are visible after the user picks an image from the media library or uses the placeholder image. One of these buttons will trigger the emoji picker modal.
In **app/(tabs)/index.tsx**:
1. Declare a boolean state variable, `showAppOptions`, to show or hide the buttons that open the modal, alongside a few other options. When the app screen loads, we'll set it to `false` so the options are not shown before picking an image. When the user picks an image or uses the placeholder image, we'll set it to `true`.
2. Update the `pickImageAsync()` function to set the value of `showAppOptions` to `true` after the user picks an image.
3. Update the button with no theme by adding an `onPress` prop with the following value.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
      </View>
      {showAppOptions ? (
        <View />
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
});
```
In the above snippet, we're rendering the `Button` component based on the value of `showAppOptions` and moving the buttons in the ternary operator block. When the value of `showAppOptions` is `true`, render an empty `<View>` component. We'll address this state in the next step.
Now, we can remove the `alert` on the `Button` component and update the `onPress` prop when rendering the second button in the **components/Button.tsx**:
```tsx components/Button.tsx
```
Step 2: 
## Add buttons
Let's break down the layout of the option buttons we'll implement in this chapter. The design looks like this:
It contains a parent `<View>` with three buttons aligned in a row. The button in the middle with the plus icon (+) will open the modal and is styled differently than the other two buttons.
Inside the **components** directory, create a new **CircleButton.tsx** file with the following code:
```tsx components/CircleButton.tsx
import { View, Pressable, StyleSheet } from 'react-native';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
type Props = {
  onPress: () => void;
};
export default function CircleButton({ onPress }: Props) {
  return (
    <View style={styles.circleButtonContainer}>
      <Pressable style={styles.circleButton} onPress={onPress}>
        <MaterialIcons name="add" size={38} color="#25292e" />
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  circleButtonContainer: {
    width: 84,
    height: 84,
    marginHorizontal: 60,
    borderWidth: 4,
    borderColor: '#ffd33d',
    borderRadius: 42,
    padding: 3,
  },
  circleButton: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 42,
    backgroundColor: '#fff',
  },
});
```
To render the plus icon, this button uses the `<MaterialIcons>` icon set from the `@expo/vector-icons` library.
The other two buttons also use `<MaterialIcons>` to display vertically aligned text labels and icons. Create a file named **IconButton.tsx** inside the **components** directory. This component accepts three props:
- `icon`: the name corresponding to the `MaterialIcons` library icon.
- `label`: the text label displayed on the button.
- `onPress`: this function invokes when the user presses the button.
```tsx components/IconButton.tsx
import { Pressable, StyleSheet, Text } from 'react-native';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
type Props = {
  icon: keyof typeof MaterialIcons.glyphMap;
  label: string;
  onPress: () => void;
};
export default function IconButton({ icon, label, onPress }: Props) {
  return (
    <Pressable style={styles.iconButton} onPress={onPress}>
      <MaterialIcons name={icon} size={24} color="#fff" />
      <Text style={styles.iconButtonLabel}>{label}</Text>
    </Pressable>
  );
}
const styles = StyleSheet.create({
  iconButton: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  iconButtonLabel: {
    color: '#fff',
    marginTop: 12,
  },
});
```
Inside **app/(tabs)/index.tsx**:
1. Import the `CircleButton` and `IconButton` components to display them.
2. Add three placeholder functions for these buttons. The `onReset()` function invokes when the user presses the reset button, causing the image picker button to appear again. We'll add the functionality for the other two functions later.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
import IconButton from '@/components/IconButton';
import CircleButton from '@/components/CircleButton';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    // we will implement this later
  };
  const onSaveImageAsync = async () => {
    // we will implement this later
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
Let's take a look at our app on Android, iOS and the web:
Step 3: 
## Create an emoji picker modal
The modal allows the user to choose an emoji from a list of available emoji. Create an **EmojiPicker.tsx** file inside the **components** directory. This component accepts three props:
- `isVisible`: a boolean to determine the state of the modal's visibility.
- `onClose`: a function to close the modal.
- `children`: used later to display a list of emoji.
```tsx components/EmojiPicker.tsx|collapseHeight=430
import { Modal, View, Text, Pressable, StyleSheet } from 'react-native';
import { PropsWithChildren } from 'react';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
type Props = PropsWithChildren<{
  isVisible: boolean;
  onClose: () => void;
}>;
export default function EmojiPicker({ isVisible, children, onClose }: Props) {
  return (
    <View>
    <Modal animationType="slide" transparent={true} visible={isVisible}>
      <View style={styles.modalContent}>
        <View style={styles.titleContainer}>
          <Text style={styles.title}>Choose a sticker</Text>
          <Pressable onPress={onClose}>
            <MaterialIcons name="close" color="#fff" size={22} />
          </Pressable>
        </View>
        {children}
      </View>
    </Modal>
    </View>
  );
}
const styles = StyleSheet.create({
  modalContent: {
    height: '25%',
    width: '100%',
    backgroundColor: '#25292e',
    borderTopRightRadius: 18,
    borderTopLeftRadius: 18,
    position: 'absolute',
    bottom: 0,
  },
  titleContainer: {
    height: '16%',
    backgroundColor: '#464C55',
    borderTopRightRadius: 10,
    borderTopLeftRadius: 10,
    paddingHorizontal: 20,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  title: {
    color: '#fff',
    fontSize: 16,
  },
});
```
Let's learn what the above code does:
- The `<Modal>` component displays a title and a close button.
- Its `visible` prop takes the value of `isVisible` and controls whether the modal is open or closed.
- Its `transparent` prop is a boolean value, which determines whether the modal fills the entire view.
- Its `animationType` prop determines how it enters and leaves the screen. In this case, it is sliding from the bottom of the screen.
- Lastly, the `<EmojiPicker>` invokes the `onClose` prop when the user presses the close `<Pressable>`.
Now, let's modify the **app/(tabs)/index.tsx**:
1. Import the `<EmojiPicker>` component.
2. Create an `isModalVisible` state variable with the `useState` hook. Its default value is `false`, which hides the modal until the user presses the button to open it.
3. Replace the comment in the `onAddSticker()` function to update the `isModalVisible` variable to `true` when the user presses the button. This will open the emoji picker.
4. Create the `onModalClose()` function to update the `isModalVisible` state variable.
5. Place the `<EmojiPicker>` component at the bottom of the `Index` component.
```tsx app/(tabs)/index.tsx
import { View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
import IconButton from '@/components/IconButton';
import CircleButton from '@/components/CircleButton';
import EmojiPicker from '@/components/EmojiPicker';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const [isModalVisible, setIsModalVisible] = useState<boolean>(false);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    setIsModalVisible(true);
  };
  const onModalClose = () => {
    setIsModalVisible(false);
  };
  const onSaveImageAsync = async () => {
    // we will implement this later
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
      <EmojiPicker isVisible={isModalVisible} onClose={onModalClose}>
        {/* Emoji list component will go here */}
      </EmojiPicker>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
Here is the result after this step:
Step 4: 
## Display a list of emoji
Let's add a horizontal list of emoji in the modal's content. We'll use the [`<FlatList>`](https://reactnative.dev/docs/flatlist) component from React Native for it.
Create a **EmojiList.tsx** file inside the **components** directory and add the following code:
```tsx components/EmojiList.tsx
import { useState } from 'react';
import { ImageSourcePropType, StyleSheet, FlatList, Platform, Pressable } from 'react-native';
import { Image } from 'expo-image';
type Props = {
  onSelect: (image: ImageSourcePropType) => void;
  onCloseModal: () => void;
};
export default function EmojiList({ onSelect, onCloseModal }: Props) {
  const [emoji] = useState<ImageSourcePropType[]>([
    require("../assets/images/emoji1.png"),
    require("../assets/images/emoji2.png"),
    require("../assets/images/emoji3.png"),
    require("../assets/images/emoji4.png"),
    require("../assets/images/emoji5.png"),
    require("../assets/images/emoji6.png"),
  ]);
  return (
    <FlatList
      horizontal
      showsHorizontalScrollIndicator={Platform.OS === 'web'}
      data={emoji}
      contentContainerStyle={styles.listContainer}
      renderItem={({ item, index }) => (
        <Pressable
          onPress={() => {
            onSelect(item);
            onCloseModal();
          }}>
          <Image source={item} key={index} style={styles.image} />
        </Pressable>
      )}
    />
  );
}
const styles = StyleSheet.create({
  listContainer: {
    borderTopRightRadius: 10,
    borderTopLeftRadius: 10,
    paddingHorizontal: 20,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  image: {
    width: 100,
    height: 100,
    marginRight: 20,
  },
});
```
Let's learn what the above code does:
- The `<FlatList>` component above renders all the emoji images using the `Image` component, wrapped by a `<Pressable>`. Later, we will improve it so that the user can tap an emoji on the screen to make it appear as a sticker on the image.
- It also takes an array of items provided by the `emoji` array variable as the value of the `data` prop. The `renderItem` prop takes the item from the `data` and returns the item in the list. Finally, we added `Image` and the `<Pressable>` components to display this item.
- The `horizontal` prop renders the list horizontally instead of vertically. The `showsHorizontalScrollIndicator` uses React Native's `Platform` module to check the value and display the horizontal scroll bar on web.
Now, update the **app/(tabs)/index.tsx** to import the `<EmojiList>` component and replace the comments inside the `<EmojiPicker>` component with the following code snippet:
```tsx app/(tabs)/index.tsx|collapseHeight=440
import { ImageSourcePropType, View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
import IconButton from '@/components/IconButton';
import CircleButton from '@/components/CircleButton';
import EmojiPicker from '@/components/EmojiPicker';
import EmojiList from '@/components/EmojiList';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const [isModalVisible, setIsModalVisible] = useState<boolean>(false);
  const [pickedEmoji, setPickedEmoji] = useState<ImageSourcePropType | undefined>(undefined);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    setIsModalVisible(true);
  };
  const onModalClose = () => {
    setIsModalVisible(false);
  };
  const onSaveImageAsync = async () => {
    // we will implement this later
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
      <EmojiPicker isVisible={isModalVisible} onClose={onModalClose}>
        <EmojiList onSelect={setPickedEmoji} onCloseModal={onModalClose} />
      </EmojiPicker>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
In the `EmojiList` component, the `onSelect` prop selects the emoji and after selecting it, the `onCloseModal` closes the modal.
Let's take a look at our app on Android, iOS and the web:
Step 5: 
## Display the selected emoji
Now, we'll put the emoji sticker on the image. Create a new file in the **components** directory and call it **EmojiSticker.tsx**. Then, add the following code:
```tsx components/EmojiSticker.tsx|collapseHeight=300
import { ImageSourcePropType, View } from 'react-native';
import { Image } from 'expo-image';
type Props = {
  imageSize: number;
  stickerSource: ImageSourcePropType;
};
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  return (
    <View style={{ top: -350 }}>
      <Image source={stickerSource} style={{ width: imageSize, height: imageSize }} />
    </View>
  );
}
```
This component receives two props:
- `imageSize`: a value defined inside the `Index` component. We will use this value in the next chapter to scale the image's size when tapped.
- `stickerSource`: the source of the selected emoji image.
Import this component in the **app/(tabs)/index.tsx** file and update the `Index` component to display the emoji sticker on the image. We'll check if the `pickedEmoji` state is not `undefined`:
```tsx app/(tabs)/index.tsx
import { ImageSourcePropType, View, StyleSheet } from 'react-native';
import * as ImagePicker from 'expo-image-picker';
import { useState } from 'react';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
import IconButton from '@/components/IconButton';
import CircleButton from '@/components/CircleButton';
import EmojiPicker from '@/components/EmojiPicker';
import EmojiList from '@/components/EmojiList';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const [isModalVisible, setIsModalVisible] = useState<boolean>(false);
  const [pickedEmoji, setPickedEmoji] = useState<ImageSourcePropType | undefined>(undefined);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    setIsModalVisible(true);
  };
  const onModalClose = () => {
    setIsModalVisible(false);
  };
  const onSaveImageAsync = async () => {
    // we will implement this later
  };
  return (
    <View style={styles.container}>
      <View style={styles.imageContainer}>
        <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
        {pickedEmoji && <EmojiSticker imageSize={40} stickerSource={pickedEmoji} />}
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
      <EmojiPicker isVisible={isModalVisible} onClose={onModalClose}>
        <EmojiList onSelect={setPickedEmoji} onCloseModal={onModalClose} />
      </EmojiPicker>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
Let's take a look at our app on Android, iOS and the web:
## Summary
<ProgressTracker
  currentChapterIndex={4}
  name="GET_STARTED"
  summary="We've successfully created the emoji picker modal and implemented the logic to select an emoji and display it over the image."
  nextChapterDescription="In the next chapter, let's add user interactions with gestures to drag the emoji and scale the size by tapping it."
  nextChapterTitle="Add gestures"
  nextChapterLink="/tutorial/gestures"
/>


## Add gestures

In this tutorial, learn how to implement gestures from React Native Gesture Handler and Reanimated libraries.

Gestures are a great way to provide an intuitive user experience in an app. The [React Native Gesture Handler](https://docs.swmansion.com/react-native-gesture-handler/docs/) library provides built-in native components that can handle gestures. It recognizes pan, tap, rotation, and other gestures using the platform's native touch handling system. In this chapter, we'll add two different gestures using this library:
- Double tap to scale the size of the emoji sticker and reduce the scale when double tapped again.
- Pan to move the emoji sticker around the screen so that the user can place the sticker anywhere on the image.
We'll also use the [Reanimated](https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/handling-gestures/) library to animate between gesture states.
Video Tutorial: [Watch: Adding gestures to your universal Expo app](https://www.youtube.com/watch?v=0q48LLvTGDU)
---
Step 1: 
## Add GestureHandlerRootView
To get gesture interactions to work in the app, we'll render `<GestureHandlerRootView>` from `react-native-gesture-handler` at the top of `Index` component. Replace the root level `<View>` component in the **app/(tabs)/index.tsx** with `<GestureHandlerRootView>`.
```tsx app/(tabs)/index.tsx
// ... rest of the import statements remain same
export default function Index() {
  return (
    <GestureHandlerRootView style={styles.container}>
      {/* ...rest of the code remains */}
    </GestureHandlerRootView>
  )
}
```
Step 2: 
## Use animated components
An `Animated` component looks at the `style` prop of the component and determines which values to animate and apply updates to create an animation. Reanimated exports animated components such as `<Animated.View>`, `<Animated.Text>`, or `<Animated.ScrollView>`. We will apply animations to the `<Animated.Image>` component to make a double tap gesture work.
1. Open the **EmojiSticker.tsx** file in the **components** directory. Inside it, import `Animated` from the `react-native-reanimated` library to use animated components.
2. Replace the `Image` component with `<Animated.Image>`.
```tsx components/EmojiSticker.tsx
import { ImageSourcePropType, View } from 'react-native';
type Props = {
  imageSize: number;
  stickerSource: ImageSourcePropType;
};
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  return (
    <View style={{ top: -350 }}>
      <Animated.Image
        source={stickerSource}
        resizeMode="contain"
        style={{ width: imageSize, height: imageSize }}
      />
    </View>
  );
}
```
> For a complete reference of the animated component API, see [React Native Reanimated](https://docs.swmansion.com/react-native-reanimated/docs/core/createAnimatedComponent) documentation.
Step 3: 
## Add a tap gesture
React Native Gesture Handler allows us to add behavior when it detects touch input, like a double tap event.
In the **EmojiSticker.tsx** file:
1. Import `Gesture` and `GestureDetector` from `react-native-gesture-handler`.
2. To recognize the tap on the sticker, import `useAnimatedStyle`, `useSharedValue`, and `withSpring` from `react-native-reanimated` to animate the style of the `<Animated.Image>`.
3. Inside the `EmojiSticker` component, create a reference called `scaleImage` using the `useSharedValue()` hook. It will take the value of `imageSize` as its initial value.
```tsx components/EmojiSticker.tsx
// ...rest of the import statements remain same
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  const scaleImage = useSharedValue(imageSize);
  return (
    // ...rest of the code remains same
  )
}
```
Creating a shared value using the `useSharedValue()` hook has many advantages. It helps to mutate data and runs animations based on the current value. We can access and modify the shared value using the `.value` property. We'll create a `doubleTap` object to scale the initial value and use `Gesture.Tap()` to animate the transition while scaling the sticker image. To determine the number of taps required, we'll add `numberOfTaps()`.
Create the following object in the `EmojiSticker` component:
```tsx components/EmojiSticker.tsx
const doubleTap = Gesture.Tap()
  .numberOfTaps(2)
  .onStart(() => {
    if (scaleImage.value !== imageSize * 2) {
      scaleImage.value = scaleImage.value * 2;
    } else {
      scaleImage.value = Math.round(scaleImage.value / 2);
    }
  });
```
To animate the transition, let's use a spring-based animation. This will make it feel alive because it's based on the real-world physics of a spring. We will use the `withSpring()` function provided by `react-native-reanimated`.
On the sticker image, we'll use the `useAnimatedStyle()` hook to create a style object. This will help us to update styles using shared values when the animation happens. We'll also scale the size of the image by manipulating the `width` and `height` properties. The initial values of these properties are set to `imageSize`.
Create an `imageStyle` variable and add it to the `EmojiSticker` component:
```tsx components/EmojiSticker.tsx
const imageStyle = useAnimatedStyle(() => {
  return {
    width: withSpring(scaleImage.value),
    height: withSpring(scaleImage.value),
  };
});
```
Next, wrap the `<Animated.Image>` component with the `<GestureDetector>` and modify the `style` prop on the `<Animated.Image>` to pass the `imageStyle`.
```tsx components/EmojiSticker.tsx
import { ImageSourcePropType, View } from 'react-native';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';
type Props = {
  imageSize: number;
  stickerSource: ImageSourcePropType;
};
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  const scaleImage = useSharedValue(imageSize);
  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onStart(() => {
      if (scaleImage.value !== imageSize * 2) {
        scaleImage.value = scaleImage.value * 2;
      } else {
        scaleImage.value = Math.round(scaleImage.value / 2);
      }
    });
  const imageStyle = useAnimatedStyle(() => {
    return {
      width: withSpring(scaleImage.value),
      height: withSpring(scaleImage.value),
    };
  });
  return (
    <View style={{ top: -350 }}>
        <Animated.Image
          source={stickerSource}
          resizeMode="contain"
        />
      </GestureDetector>
    </View>
  );
}
```
In the above snippet, the `gesture` prop takes the value of the `doubleTap` to trigger a gesture when a user double-taps the sticker image.
Let's take a look at our app on Android, iOS and the web:
> For a complete reference of the tap gesture API, see the [React Native Gesture Handler](https://docs.swmansion.com/react-native-gesture-handler/docs/gestures/tap-gesture) documentation.
Step 4: 
## Add a pan gesture
To recognize a dragging gesture on the sticker and to track its movement, we'll use a pan gesture. In the **components/EmojiSticker.tsx**:
1. Create two new shared values: `translateX` and `translateY`.
2. Replace the `<View>` with the `<Animated.View>` component.
```tsx components/EmojiSticker.tsx
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  const scaleImage = useSharedValue(imageSize);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  // ...rest of the code remains same
  return (
      <GestureDetector gesture={doubleTap}>
        {/* ...rest of the code remains same */}
      </GestureDetector>
  );
}
```
Let's learn what the above code does:
- The translation values defined will move the sticker around the screen. Since the sticker moves along both axes, we need to track the X and Y values.
- In the `useSharedValue()` hooks, we have set both translation variables to have an initial position of `0`. This is the sticker's initial position and a starting point. This value sets the sticker's initial position when the gesture starts.
In the previous step, we triggered the `onStart()` callback for the tap gesture chained to the `Gesture.Tap()` method. For the pan gesture, specify an `onChange()` callback, which runs when the gesture is active and moving.
1. Create a `drag` object to handle the pan gesture. The `onChange()` callback accepts `event` as a parameter. `changeX` and `changeY` properties hold the change in position since the last event. and update the values stored in `translateX` and `translateY`.
2. Define the `containerStyle` object using the `useAnimatedStyle()` hook. It will return an array of transforms. For the `<Animated.View>` component, we need to set the `transform` property to the `translateX` and `translateY` values. This will change the sticker's position when the gesture is active.
```tsx components/EmojiSticker.tsx
const drag = Gesture.Pan().onChange(event => {
  translateX.value += event.changeX;
  translateY.value += event.changeY;
});
const containerStyle = useAnimatedStyle(() => {
  return {
    transform: [
      {
        translateX: translateX.value,
      },
      {
        translateY: translateY.value,
      },
    ],
  };
});
```
Next, inside the JSX code:
1. Update the `<EmojiSticker>` component so that the `<GestureDetector>` component becomes the top-level component.
2. Add the `containerStyle` on the `<Animated.View>` component to apply the transform styles.
```tsx components/EmojiSticker.tsx
import { Gesture, GestureDetector } from 'react-native-gesture-handler';
import Animated, { useAnimatedStyle, useSharedValue, withSpring } from 'react-native-reanimated';
import { ImageSourcePropType } from 'react-native';
type Props = {
  imageSize: number;
  stickerSource: ImageSourcePropType;
};
export default function EmojiSticker({ imageSize, stickerSource }: Props) {
  const scaleImage = useSharedValue(imageSize);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const doubleTap = Gesture.Tap()
    .numberOfTaps(2)
    .onStart(() => {
      if (scaleImage.value !== imageSize * 2) {
        scaleImage.value = scaleImage.value * 2;
      } else {
        scaleImage.value = Math.round(scaleImage.value / 2);
      }
    });
  const imageStyle = useAnimatedStyle(() => {
    return {
      width: withSpring(scaleImage.value),
      height: withSpring(scaleImage.value),
    };
  });
  const drag = Gesture.Pan().onChange(event => {
    translateX.value += event.changeX;
    translateY.value += event.changeY;
  });
  const containerStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: translateX.value,
        },
        {
          translateY: translateY.value,
        },
      ],
    };
  });
  return (
        <GestureDetector gesture={doubleTap}>
          <Animated.Image
            source={stickerSource}
            resizeMode="contain"
            style={[imageStyle, { width: imageSize, height: imageSize }]}
          />
        </GestureDetector>
      </Animated.View>
  );
}
````
Let's take a look at our app on Android, iOS and the web:
## Summary
<ProgressTracker
  currentChapterIndex={5}
  name="GET_STARTED"
  summary="We've successfully implemented pan and tap gestures."
  nextChapterDescription="In the next chapter, we'll learn how to take a screenshot of the image and the sticker, and save it on the device's library."
  nextChapterTitle="Take a screenshot"
  nextChapterLink="/tutorial/screenshot"
/>


## Take a screenshot

In this tutorial, learn how to capture a screenshot using a third-party library and Expo Media Library.

In this chapter, we'll learn how to take a screenshot using a third-party library and save it on the device's media library. We'll use [`react-native-view-shot`](https://github.com/gre/react-native-view-shot) to take a screenshot and [`expo-media-library`](/versions/latest/sdk/media-library/) to save an image on device's media library.
> **info** So far, we have used third-party libraries, such as `react-native-gesture-handler`, `react-native-reanimated`. We can find hundreds of other third-party libraries on [React Native Directory](https://reactnative.directory/) depending on a use case.
Video Tutorial: [Watch: Taking screenshots in your universal Expo app](https://www.youtube.com/watch?v=Jft3_Yfr-p4)
---
Step 1: 
## Install libraries
To install `react-native-view-shot` and `expo-media-library`, run the following commands:
```sh
$ npx expo install react-native-view-shot expo-media-library
```
Step 2: 
## Prompt for permissions
An app that requires sensitive information, such as accessing a device's media library, has to prompt permission to allow or deny access. Using `usePermissions()` hook from `expo-media-library`, we can use the permission `permissionResponse` and `requestPermission()` method to ask for access.
When the app loads for the first time and the permission status is neither granted nor denied, the value of the `permissionResponse` is `null`. When asked for permission, a user can either grant the permission or deny it. We can add a condition to check if it is not granted. If it is not granted, trigger the `requestPermission()` method. After getting the access, the value of the `permissionResponse` changes to `granted`.
Add the following code snippet inside the **app/(tabs)/index.tsx**:
```tsx app/(tabs)/index.tsx
// ...rest of the code remains same
export default function Index() {
  // ...rest of the code remains same
  useEffect(() => {
    if (!permissionResponse?.granted) {
      requestPermission();
    }
  }, []);
  // ...rest of the code remains same
}
```
Step 3: 
## Create a ref to save the current view
We'll use `react-native-view-shot` to allow the user to take a screenshot within the app. This library captures the screenshot of a `<View>` as an image using the `captureRef()` method. It returns the URI of the captured screenshot image file.
1. Import `captureRef` from `react-native-view-shot` and `useRef` from React.
2. Create an `imageRef` reference variable to store the reference of the screenshot image captured.
3. Wrap the `<ImageViewer>` and `<EmojiSticker>` components inside a `<View>` and then pass the reference variable to it.
```tsx app/(tabs)/index.tsx|collapseHeight=440
export default function Index() {
  // ...rest of the code remains same
  return (
    <GestureHandlerRootView style={styles.container}>
      <View style={styles.imageContainer}>
          <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
          {pickedEmoji && <EmojiSticker imageSize={40} stickerSource={pickedEmoji} />}
      </View>
      {/* ...rest of the code remains same */}
    </GestureHandlerRootView>
  );
}
```
In the above snippet, the `collapsable` prop is set to `false`. This allows the `<View>` component to screenshot only of the background image and emoji sticker.
Step 4: 
## Capture a screenshot and save it
We can capture a screenshot of the view by calling the `captureRef()` method from `react-native-view-shot` inside the `onSaveImageAsync()` function. It accepts an optional argument where we can pass the `width` and `height` of the screenshot capturing area. We can read more about available options in [the library's documentation](https://github.com/gre/react-native-view-shot#capturerefview-options-lower-level-imperative-api).
The `captureRef()` method also returns a promise that fulfills with the screenshot's URI. We will pass this URI as a parameter to [`MediaLibrary.saveToLibraryAsync()`](/versions/latest/sdk/media-library/#medialibrarysavetolibraryasynclocaluri) and save the screenshot to the device's media library.
Inside **app/(tabs)/index.tsx**, update the `onSaveImageAsync()` function with the following code:
```tsx app/(tabs)/index.tsx|collapseHeight=440
import * as ImagePicker from 'expo-image-picker';
import * as MediaLibrary from 'expo-media-library';
import { useEffect, useRef, useState } from 'react';
import { ImageSourcePropType, StyleSheet, View } from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { captureRef } from 'react-native-view-shot';
import Button from '@/components/Button';
import CircleButton from '@/components/CircleButton';
import EmojiList from '@/components/EmojiList';
import EmojiPicker from '@/components/EmojiPicker';
import IconButton from '@/components/IconButton';
import ImageViewer from '@/components/ImageViewer';
import EmojiSticker from '@/components/EmojiSticker';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(
    undefined
  );
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const [isModalVisible, setIsModalVisible] = useState<boolean>(false);
  const [pickedEmoji, setPickedEmoji] = useState<
    ImageSourcePropType | undefined
  >(undefined);
  const [permissionResponse, requestPermission] = MediaLibrary.usePermissions();
  const imageRef = useRef<View>(null);
  useEffect(() => {
    if (!permissionResponse?.granted) {
      requestPermission();
    }
  }, []);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    setIsModalVisible(true);
  };
  const onModalClose = () => {
    setIsModalVisible(false);
  };
  const onSaveImageAsync = async () => {
    try {
      const localUri = await captureRef(imageRef, {
        height: 440,
        quality: 1,
      });
      await MediaLibrary.saveToLibraryAsync(localUri);
      if (localUri) {
        alert('Saved!');
      }
    } catch (e) {
      console.log(e);
    }
  };
  return (
    <GestureHandlerRootView style={styles.container}>
      <View style={styles.imageContainer}>
        <View ref={imageRef} collapsable={false}>
          <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
          {pickedEmoji && <EmojiSticker imageSize={40} stickerSource={pickedEmoji} />}
        </View>
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
      <EmojiPicker isVisible={isModalVisible} onClose={onModalClose}>
        <EmojiList onSelect={setPickedEmoji} onCloseModal={onModalClose} />
      </EmojiPicker>
    </GestureHandlerRootView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
Now, choose a photo and add a sticker in the app. Then tap the "Save" button. We should see the following result on Android and iOS:
## Summary
<ProgressTracker
  currentChapterIndex={6}
  name="GET_STARTED"
  summary={
    <>
        We've successfully used  and  to capture a
        screenshot and save it on the device's library.
    </>
}
nextChapterDescription="In the next chapter, let's learn how to handle the differences between mobile and web
platforms to implement the same functionality on web."
nextChapterTitle="Handle platform differences"
nextChapterLink="/tutorial/platform-differences"
/>


## Handle platform differences

In this tutorial, learn how to handle platform differences between native and web when creating a universal app.

Android, iOS, and the web have different capabilities. In our case, both Android and iOS can capture a screenshot with the `react-native-view-shot` library. However, web browsers cannot.
In this chapter, we'll learn how to handle capturing screenshots for web browsers so our app has the same functionality on all platforms.
Video Tutorial: [Watch: Handling platform differences in your universal Expo app](https://www.youtube.com/watch?v=mEKQvF4irBM)
---
Step 1: 
## Install and import dom-to-image
To capture a screenshot on the web and save it as an image, we'll use a third-party library called [`dom-to-image`](https://github.com/tsayen/dom-to-image#readme). It takes a screenshot of any DOM node and turns it into a vector (SVG) or raster (PNG or JPEG) image.
Stop the development server and run the following command to install the library:
```sh
$ npm install dom-to-image
```
> **Note:** The `dom-to-image` library is used here for illustrative purposes. For production apps, you may want to explore other solutions or APIs that better suit your specific use case.
After installing it, make sure to restart the development server and press <kbd>w</kbd> in the terminal.
Step 2: 
## Add platform-specific code
Using `Platform` module from React Native, we can implement platform-specific behavior. Inside **app/(tabs)/index.tsx**:
1. Import the `Platform` module from `react-native`.
2. Import the `domtoimage` library from `dom-to-image`.
3. Update the `onSaveImageAsync()` function to check whether the current platform is `'web'` with the `Platform.OS` property. If it is `'web'`, we'll use the `domtoimage.toJpeg()` method to convert and capture the current `<View>` as a JPEG image. Otherwise, we'll keep using the same logic added for native platforms.
```tsx app/(tabs)/index.tsx
import * as ImagePicker from 'expo-image-picker';
import * as MediaLibrary from 'expo-media-library';
import { useEffect, useRef, useState } from 'react';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { captureRef } from 'react-native-view-shot';
import Button from '@/components/Button';
import ImageViewer from '@/components/ImageViewer';
import IconButton from '@/components/IconButton';
import CircleButton from '@/components/CircleButton';
import EmojiPicker from '@/components/EmojiPicker';
import EmojiList from '@/components/EmojiList';
import EmojiSticker from '@/components/EmojiSticker';
const PlaceholderImage = require('@/assets/images/background-image.png');
export default function Index() {
  const [selectedImage, setSelectedImage] = useState<string | undefined>(undefined);
  const [showAppOptions, setShowAppOptions] = useState<boolean>(false);
  const [isModalVisible, setIsModalVisible] = useState<boolean>(false);
  const [pickedEmoji, setPickedEmoji] = useState<ImageSourcePropType | undefined>(undefined);
  const [permissionResponse, requestPermission] = MediaLibrary.usePermissions();
  const imageRef = useRef<View>(null);
  useEffect(() => {
    if (!permissionResponse?.granted) {
      requestPermission();
    }
  }, []);
  const pickImageAsync = async () => {
    let result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ['images'],
      allowsEditing: true,
      quality: 1,
    });
    if (!result.canceled) {
      setSelectedImage(result.assets[0].uri);
      setShowAppOptions(true);
    } else {
      alert('You did not select any image.');
    }
  };
  const onReset = () => {
    setShowAppOptions(false);
  };
  const onAddSticker = () => {
    setIsModalVisible(true);
  };
  const onModalClose = () => {
    setIsModalVisible(false);
  };
  const onSaveImageAsync = async () => {
    if (Platform.OS !== 'web') {
      try {
        const localUri = await captureRef(imageRef, {
          height: 440,
          quality: 1,
        });
        await MediaLibrary.saveToLibraryAsync(localUri);
        if (localUri) {
          alert('Saved!');
        }
      } catch (e) {
        console.log(e);
      }
    } else {
      try {
        const dataUrl = await domtoimage.toJpeg(imageRef.current, {
          quality: 0.95,
          width: 320,
          height: 440,
        });
        let link = document.createElement('a');
        link.download = 'sticker-smash.jpeg';
        link.href = dataUrl;
        link.click();
      } catch (e) {
        console.log(e);
      }
    }
  };
  return (
    <GestureHandlerRootView style={styles.container}>
      <View style={styles.imageContainer}>
        <View ref={imageRef} collapsable={false}>
          <ImageViewer imgSource={PlaceholderImage} selectedImage={selectedImage} />
          {pickedEmoji && <EmojiSticker imageSize={40} stickerSource={pickedEmoji} />}
        </View>
      </View>
      {showAppOptions ? (
        <View style={styles.optionsContainer}>
          <View style={styles.optionsRow}>
            <IconButton icon="refresh" label="Reset" onPress={onReset} />
            <CircleButton onPress={onAddSticker} />
            <IconButton icon="save-alt" label="Save" onPress={onSaveImageAsync} />
          </View>
        </View>
      ) : (
        <View style={styles.footerContainer}>
          <Button theme="primary" label="Choose a photo" onPress={pickImageAsync} />
          <Button label="Use this photo" onPress={() => setShowAppOptions(true)} />
        </View>
      )}
      <EmojiPicker isVisible={isModalVisible} onClose={onModalClose}>
        <EmojiList onSelect={setPickedEmoji} onCloseModal={onModalClose} />
      </EmojiPicker>
    </GestureHandlerRootView>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#25292e',
    alignItems: 'center',
  },
  imageContainer: {
    flex: 1,
  },
  footerContainer: {
    flex: 1 / 3,
    alignItems: 'center',
  },
  optionsContainer: {
    position: 'absolute',
    bottom: 80,
  },
  optionsRow: {
    alignItems: 'center',
    flexDirection: 'row',
  },
});
```
Note: Fix  TypeScript module error
---
We need to add a type definition after importing the `domtoimage` library since we're using TypeScript. We can do this by creating a file **types.d.ts** in the root of our project directory and adding the declaration statement:
```tsx types.d.ts
declare module 'dom-to-image';
```
---
On running the app in a web browser, we can now save a screenshot:
## Summary
<ProgressTracker
  currentChapterIndex={7}
  name="GET_STARTED"
  summary="The app does everything we set out for it to do, so it's time to shift our focus toward the purely aesthetic.."
  nextChapterDescription="In the next chapter, we will customize the app's status bar, splash screen, and app icon."
  nextChapterTitle="Configure status bar, splash screen and app icon"
  nextChapterLink="/tutorial/configuration"
/>


## Configure status bar, splash screen and app icon

In this tutorial, learn the basics of how to configure a status bar, app icon, and splash screen.

In this chapter, we'll address some app details before deploying our app to an app store, such as theming the status bar, customizing the app icon, and splash screen.
Video Tutorial: [Watch: Adding the finishing touches to your universal Expo app](https://www.youtube.com/watch?v=OgGCYdElcZo)
---
Step 1: 
## Configure the status bar
[`expo-status-bar`](/versions/latest/sdk/status-bar/) library comes pre-installed in every project created using `create-expo-app`. This library provides a `StatusBar` component to configure the app's status bar style.
Inside **app/\_layout.tsx**:
1. Import `StatusBar` from `expo-status-bar`.
2. Group the `StatusBar` and existing `Stack` components with [React's Fragment component](https://react.dev/reference/react/Fragment).
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
export default function RootLayout() {
  return (
    <>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
      </Stack>
    </>
  );
}
```
Let's take a look at our app now on Android, and iOS:
Step 2: 
## App icon
Inside the project, there's an **icon.png** file inside the **assets/images** directory. This is our app icon. It's a 1024px by 1024px image and looks as shown below:
Like the splash screen image, the `"icon"` property in the **app.json** file configures the app icon's path. By default, a new Expo project defines the correct path to `"./assets/images/icon.png"`. We don't have to change anything.
> Eventually, when you'll build your app for the app stores, [Expo Application Services (EAS)](/eas/) will take this image and create optimized icon for every device.
You can see the icon in various places in Expo Go. Here is an example of the app icon displayed in the developer menu of Expo Go:
Step 3: 
## Splash screen
A splash screen is visible before the app's content is loaded. It uses a smaller image, such as an app's icon, which is centered. It hides once the app's content is ready to be displayed.
The [`expo-splash-screen`](/versions/latest/sdk/splash-screen/) plugin already comes pre-installed in every project created using `create-expo-app`. This library provides a config plugin to configure the splash screen.
In **app.json**, the `expo-splash-screen` plugin is already configured to use the app's icon as the splash screen image (provided in the [downloadable assets](/tutorial/create-your-first-app/#download-assets)) with the following snippet so we don't have to change anything:
```json app.json
{
  "plugins": [
    [
      "expo-splash-screen",
      {
        "image": "./assets/images/splash-icon.png"
      }
    ]
  ]
}
```
However, **to test the splash screen, we cannot use Expo Go or a [development build](/develop/development-builds/introduction/)**. To test it, we need to create a preview or a production build of our app. We recommend going through the following resources to learn more about the splash screen configuration and how to test it:
- [Create a splash screen icon](/develop/user-interface/splash-screen-and-app-icon/#splash-screen) guide to learn how splash screen icon is configured.
- To learn how to create a preview build, see [Internal distribution](/tutorial/eas/internal-distribution-builds/) guide in EAS Tutorial, or to create production builds see guides for [Android](/tutorial/eas/android-production-build/) and [iOS](/tutorial/eas/ios-production-build/).
## Summary
<ProgressTracker
  currentChapterIndex={8}
  name="GET_STARTED"
  summary="Well done! We built an app that runs on Android, iOS, and the web from the same codebase."
  nextChapterDescription="The next section of the tutorial will guide you toward resources to learn more about concepts we've covered here and others we have mentioned briefly."
  nextChapterTitle="Learning resources"
  nextChapterLink="/tutorial/follow-up"
/>


## Learning resources

Explore a curated list of resources to learn about Expo and React Native.

Now that the example app is done, let's learn more about the technologies we used to build it.
## Build your project into an app
To start creating a new app on your machine you can use `npx create-expo-app@latest` and [set up your development environment](/get-started/set-up-your-environment/) sequentially.
### Recommended resources
Once you've created your new project, you can learn more about different tools and concepts that will help you on your app development journey:
- [Development tools](/develop/tools/): A reference of Expo tools that will help you during various aspects of your app-building journey.
- [Development builds](/develop/development-builds/introduction/): Using a development build allows you to gain full control over your app's build process, and to test your app on a device or simulator.
- [Development overview](/workflow/overview/): This is a high-level overview that provides details on key concepts for developing an app with Expo and the flow of core development loop.
- [Expo Router](/router/introduction/): We went through basics of Expo Router and implemented a tab navigator. See its documentation to learn more about the library.
- [App icon](/develop/user-interface/splash-screen-and-app-icon/#app-icon) and [splash screen](/develop/user-interface/splash-screen-and-app-icon/#splash-screen): You can learn more about customizing your app icon and splash screen guides. Also, look through the [app config reference](/workflow/configuration) for properties you can configure in the **app.json** file.
- [App distribution](/deploy/build-project/) and [submission](/deploy/submit-to-app-stores/) to app stores: Read these resources to learn more about how to release and submit your app to app stores once it's ready to ship.
- [Debugging](/debugging/runtime-issues/): Sometimes things go wrong, and when they do, you can use debugging tools to find and fix errors.
## Learning
### React
We used React components and APIs. Having a solid understanding of React is essential to using Expo to build your app. We recommend reading the React documentation's [Quick Start section](https://react.dev/learn) and the [Hooks section](https://react.dev/reference/react/hooks).
### React Native
While developing the tutorial app, we used React Native extensively. You can start from the [React Native basics guide](https://reactnative.dev/docs/getting-started) to learn more. Also, check out the following docs:
- [View API reference](https://reactnative.dev/docs/view)
- [Text API reference](https://reactnative.dev/docs/text)
- [Platform specific code](https://reactnative.dev/docs/platform-specific-code)
- [Presenting data in a list](https://reactnative.dev/docs/using-a-listview)
We used Flexbox to layout our components. Check out the following recommendations to learn more about it:
- [Height and Width](https://reactnative.dev/docs/height-and-width)
- [Layout with Flexbox](https://reactnative.dev/docs/flexbox)
### Gestures and animations
To learn more about implementing different types of gestures and animations, we recommend the following documentation:
- [React Native Gesture Handler](https://docs.swmansion.com/react-native-gesture-handler/docs/)
- [React Native Reanimated](https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/getting-started)
## Join the community
Join our community on <A href="https://chat.expo.dev/" shouldLeakReferrer>Discord</A> to chat with other Expo users or to ask questions.


# EAS tutorial

## EAS Tutorial: Introduction

An introduction to the tutorial for building apps for Android and iOS using Expo Application Services (EAS) that covers the Build, Update, and Submit workflows.

## About this tutorial
This tutorial will give you proficiency with [Expo Application Services (EAS)](https://expo.dev/eas) core services: [Build](/build/introduction/), [Submit](/submit/introduction/), and [Update](/eas-update/introduction/). When you complete the tutorial, you will know how to set up a professional mobile Continuous Integration (CI)/Continuous Development (CD) pipeline for your individual and team projects.
This tutorial covers the following topics:
- Use EAS Build to create and install a development build, then run it on a device, emulator, or simulator.
- Experience the benefits of using a development build instead of Expo Go.
- Implement workflows for sharing development builds with a team or external stakeholders.
- Automatically increment app build versions.
- Simultaneously install different app variants, like development and preview, on one device.
- Utilize EAS Update to create and deploy updates swiftly during the development phase.
- Automate build processes by integrating with a GitHub repository.
These topics will give us the foundation needed to use EAS effectively and to approach more advanced topics when needed.
## Prerequisites
This tutorial is hands-on and designed to be completed in about two hours. You will need an existing Expo project to follow along and set it up locally on your machine. Options include:
- Continuing with the Sticker Smash app from our previous tutorial. If new, download it from [GitHub](https://github.com/expo/examples/tree/master/stickersmash).
- Starting a new project with [`npx create-expo-app`](/get-started/create-a-project/).
- Using a bare React Native project. Ensure the `expo` package is installed, which you can do [automatically](/bare/installing-expo-modules/) or [manually](/bare/installing-expo-modules/#manual-installation).
## Tools
[Expo Orbit](https://expo.dev/orbit) to manage and launch builds with one click on macOS and Windows.
If you want to install and run the build locally on your machine simultaneously, you can use Android Emulator or iOS Simulator. To set them up, see the following:
- [Android Emulator](/workflow/android-studio-emulator/)
- [iOS Simulator](/workflow/ios-simulator/) (available only on macOS)
## Next step
We're ready for this journey after setting up an Expo project locally. In the next chapter, let's learn how to create your first build with EAS Build.


## Configure a development build in cloud

Learn how to configure a development build for a project using EAS Build.

In this chapter, we'll set up and configure a development build with EAS for our example app.
Video Tutorial: [Watch: How to configure a development build](https://www.youtube.com/watch?v=uQCE9zl3dXU)
---
## Understanding development builds
Let's start by learning about what are development builds and why we need them.
A [development build](/develop/development-builds/introduction/) is a debug version of our project. It is optimized for quick iterations when creating an app. It contains the [`expo-dev-client`](/versions/latest/sdk/dev-client/) library, which offers a robust and complete development environment. This setup allows us to integrate any native library or change code inside the [native directories](/workflow/overview/#android-and-ios-native-projects) as required.
### Key highlights
> **Note:** If you are familiar with [Expo Go](/get-started/expo-go/), think of a development build as a customizable version of Expo Go that is unique to the requirements of a project.
| Feature                           | Development Builds                                                                                                                             | Expo Go                                                                                              |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| **Development phase**             | Offers web-like iteration speed for mobile app development.                                                                                    | Allows for quick iteration and testing of Expo SDK projects using the client app.                    |
| **Collaboration**                 | Facilitates team testing with shared native runtime.                                                                                           | Easy project sharing via QR codes on a device.                                                       |
| **Third-party libraries support** | Full support for any [third-party library](/workflow/using-libraries/#third-party-libraries), including those that require custom native code. | Limited to libraries within the Expo SDK, not suitable for custom native dependencies.               |
| **Customization**                 | Extensive customization with [config plugins](/config-plugins/introduction/) and direct access to native code.                                 | Limited customization with a focus on Expo SDK capabilities without direct native code modification. |
| **Intended use**                  | Ideal for full-fledged app development aimed at store deployment, offering a complete development environment and tools.                       | Ideal for learning, prototyping, and experimenting. Not recommended for production apps.             |
Step 1: 
## Install expo-dev-client library
To initialize our project for a development build, let's [`cd`](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Command_line#basic_built-in_terminal_commands) inside our project directory and run the following command to install the library:
```sh
$ npx expo install expo-dev-client
```
### Start the development server
Run the `npx expo start` to start the [development server](/get-started/start-developing/#start-a-development-server):
```sh
$ npx expo start
```
This command starts the metro bundler. In the terminal window, we see the QR code followed by the `Metro waiting on...` and a manifest URL:
Let's notice the changes installing the `expo-dev-client` library:
- The manifest URL contains `expo-development-client` along with the app scheme
- The development server now operates for a development build (instead of Expo Go).
Since we do not have a development build installed on one of our devices or an emulator/simulator, we can't run our project yet.
Step 2: 
## Initialize a development build
### Install EAS CLI
We need to install the EAS Command Line Interface (CLI) tool as a global dependency on our local machine. Run the following command:
```sh
$ npm install -g eas-cli
```
### Log in or sign up for an Expo account
> If you have an Expo account and are signed in using Expo CLI, skip this step. If you don't have an Expo account, [sign up here](https://expo.dev/signup) and proceed with the login command described below.
To log in, run the following command:
```sh
$ eas login
```
This command asks for our Expo account email or username and password to complete the login.
### Initialize and link the project to EAS
For any new project, the first step is to initialize and link it to the EAS servers. Run the following command:
```sh
$ eas init
```
On running, this command:
- Requests verification of the account owner by entering our Expo account credentials and asks if we want to create a new EAS project:
```sh
✔ Which account should own this project? > your-username
✔ Would you like to create a project for @your-username/sticker-smash? … yes
✔ Created @your-username/sticker-smash
✔ Project successfully linked (ID: XXXX-XX-XX-XXXX) (modified app.json)
```
- Creates EAS project and provides a link to that project which we can open in the EAS dashboard:
- Generates a unique `projectId` and links this EAS project to the example app on our development machine.
- Modifies **app.json** to include [`extra.eas.projectId`](/versions/latest/sdk/constants/#easconfig) and updates its value with the unique ID created.
Note: What is  in app.json?
---
When `eas init` runs, it associates a unique identifier for our project in **app.json** under `extra.eas.projectId`. The value of this property is used to identify our project on EAS servers.
```json
{
  "extra": {
    "eas": {
      "projectId": "0cd3da2d-xxx-xxx-xxx-xxxxxxxxxx"
    }
  }
}
```
---
Step 3: 
## Configure project for EAS Build
To set up our project for EAS Build, run the following command:
```sh
$ eas build:configure
```
On running, this command:
- Prompts to select a platform: **Android**, **iOS**, or **All**. Since we are creating Android and iOS apps, let's select **All**.
- Creates **eas.json** in the root of our project's directory with the following configuration:
```json eas.json
{
  "cli": {
    "version": ">= 16.18.0",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```
This is the default configuration for **eas.json** in a new project. It does two things:
- Defines the current EAS CLI version.
- Adds three [build profiles](/build/eas-json/#build-profiles): `development`, `preview`, and `production`.
Note: Explore development profile further
---
**eas.json** is a collection of different build profiles. Each profile is tailored with distinct configurations to produce specific build types. These profiles can also include platform-specific settings for Android or iOS.
Currently, our focus is on the `development` profile, which includes the following configuration:
- [`developmentClient`](/eas/json/#developmentclient): Enabled (`true`) for creating a debug build. It loads the app using the `expo-dev-client` library, which provides development tools and generates a build artifact for device or emulator/simulator installation and allows using the app for local development as it supports updating the JavaScript on the fly.
- [`distribution`](/eas/json/#distribution): Configured as `internal` to indicate that we want to share the build internally (instead of uploading it on app stores).
> **Note**: Builds offer extensive customization options, including platform-specific settings and the ability to extend configurations across different build profiles. Learn more about [customizing build profiles](/build/eas-json/#build-profiles).
---
## Summary
<ProgressTracker
  currentChapterIndex={0}
  name="EAS_TUTORIAL"
  summary="
We successfully used the EAS CLI to initialize, and configure our project, link it to EAS servers, and prepare a development build."
  nextChapterDescription="In the next chapter, let's create a development build for Android, install it on a device and an emulator, and get it running with the development server."
  nextChapterTitle="Create and run a cloud build for Android"
  nextChapterLink="/tutorial/eas/android-development-build/"
/>


## Create and run a cloud build for Android

Learn how to configure a development build for Android devices and emulators using EAS Build.

In this chapter, we'll create a development build that can run on Android with EAS Build.
The process for creating and running a build on Android devices or emulators is identical, with differences only in the installation of the development build.
Video Tutorial: [Watch: How to create and run a cloud build for Android](https://www.youtube.com/watch?v=D612BUtvvl8)
---
## Create a build for the development profile
For Android, the development build must be in the **.apk**. While the default Android format is **.aab**, which is ideal for Google Play Store distribution, it cannot be installed on devices or emulators.
To create a **.apk**:
- In **eas.json**, make sure that `developmentClient` is set to `true` under `build.development` profile.
- Then, run the `eas build` command with `android` as the platform and `development` as the build profile:
  ```sh
$ eas build --platform android --profile development
```
  > **info** **Tip**: Next time you run `eas build` command, you can also use `-p` to specify the platform. It is short for `--platform`.
This command prompts us with the following questions:
- **What would you like your Android application id to be?** Press <kbd>return</kbd> to select the default value provided for this prompt. This will add [`android.package`](/versions/latest/config/app/#package) in **app.json**.
- **Generate a new Android Keystore**? Press <kbd>Y</kbd>.
After responding, the build will queue up, and we can track its progress via a provided link by the EAS CLI in the EAS dashboard:
Note: What information does a build details page contain?
---
The build details page displays the build type, profile, Expo SDK version, app version, version code, last commit hash, and the identity of the developer or account owner who initiated the build.
In the above image, the current status of the **Build artifact** shows that the build is in progress. Upon completion, this section will offer an option to download the build. The **Logs** outlines every step taken during the Android build process on EAS Build. For the sake of brevity, we won't explore each step in detail here. To learn more, see [Android build process](/build-reference/android-builds/).
---
Note: What is an Android application ID?
---
Also known as the package name of our Android app, it stores the value in DNS reverse notation format (`com.owner.appname`). Each component of this notation should start with a lowercase letter.
For example, our example app has `com.owner.stickersmash` where `com.owner` is the domain and `stickersmash` is our app name.
---
## Android device
Step 1: 
### Install development build
Once the build finishes, the **Build artifact** section gets updated, indicating that the build is complete:
This section provides the methods available for running the development build on an Android device: Expo Orbit and Install button.
[Expo Orbit](https://expo.dev/orbit) allows for seamless installation of the development build on an Android device. To use this method:
- Connect our Android device to our local machine using USB.
- Open the Orbit menu bar app.
- Select the **Device** in the Orbit app.
- On the EAS dashboard, under **Build artifact**, click the **Open with Orbit**.
After the build is installed, the Orbit app launches the development build on the device.
Note: Alternate: Use the Install button and QR code
---
The **Install** button in the **Build artifact** generates a QR code for installation:
- Click **Install** to display a popup with the QR code.
- Scan the QR code with our Android device's camera to open the build link in the default web browser.
- Tap the **Install** button on the webpage to download the **.apk** file.
- Once downloaded, open the **.apk** to start the installation process.
- If an **Unsafe app blocked message** appears, select **Install anyway**. This warning can safely be ignored as the source of the **.apk** (which we generated) is trusted.
---
Step 2: 
### Run development build
Start the development server by running `npx expo start` from the project directory. Once the server is running, press <kbd>a</kbd> in the terminal window to open the project:
```sh
$ npx expo start
```
## Android Emulator
Step 1: 
### Install the development build
In the terminal, once the build finishes, EAS CLI prompts us by asking whether we want to run the build on an Android Emulator. Press <kbd>Y</kbd>.
Note: Alternate: Use Expo Orbit
---
Alternatively, [Expo Orbit](/build/orbit/) can be used for installation. From **Build artifact** on the EAS dashboard, click **Open with Expo Orbit** to install the development build on the Android Emulator.
---
Step 2: 
### Run the development build
Start the development server by running `npx expo start` from the project directory. Once the server is running, press <kbd>a</kbd> in the terminal window to open the project:
```sh
$ npx expo start
```
## Summary
<ProgressTracker
  currentChapterIndex={1}
  name="EAS_TUTORIAL"
  summary={
    <>
      We successfully used EAS Build to create and run development builds on Android devices and
      emulators, and learned about <strong>.apk</strong> and <strong>.aab</strong> file formats.
    </>
  }
  nextChapterDescription="In the next chapter, learn how to configure a development build for iOS Simulators using EAS Build and get it running."
  nextChapterTitle="Create and run a cloud build for iOS Simulator"
  nextChapterLink="/tutorial/eas/ios-development-build-for-simulators/"
/>


## Create and run a cloud build for iOS Simulator

Learn how to configure a development build for iOS Simulators using EAS Build.

In this chapter, we'll create a development build that can run on an iOS Simulator with EAS Build.
Development builds for iOS Simulators are generated in the **.app** format which is different from iOS devices.
Video Tutorial: [Watch: Creating a development build for iOS Simulator](https://www.youtube.com/watch?v=SgL97PFZctg)
---
## Create a simulator build profile in eas.json
In **eas.json**, add a new build profile called `ios-simulator` with the property [`ios.simulator`](/eas/json/#simulator) property. Set its value `true`:
```json eas.json
{
  "build": {
    "development": {
    },
    "ios-simulator": {
      "ios": {
        "simulator": true
      }
    }
  }
}
```
For a development build, it's necessary to have the `developmentClient` and `distribution` properties defined in the profile. To avoid redundancy, we can extend the `development` profile properties:
```json eas.json
{
  "ios-simulator": {
    "extends": "development",
    "ios": {
      "simulator": true
    }
  }
}
```
## Development build for iOS Simulator
Step 1: 
### Create
Run the `eas build` command with `ios` as a platform and `ios-simulator` as the build profile:
```sh
$ eas build --platform ios --profile ios-simulator
```
This command prompts us with the following questions when we create the build for the first time:
- **What would you like your iOS bundle identifier to be?** Press <kbd>return</kbd> to select the default value provided for this prompt. This will add [`ios.bundleIdentifier`](/versions/latest/config/app/#package) in **app.json**.
- **iOS app only uses standard/exempt encryption?** Press <kbd>Y</kbd> to select the default value provided for this prompt. Since our app doesn't use encryption, it sets `ITSAppUsesNonExemptEncryption` in the **Info.plist** file to `NO` and manages the compliance check for the same when you are releasing your app to TestFlight/Apple App Store. When you are releasing your own app, and it uses encryption, you can select `N` to skip this prompt next time.
After responding to the prompts, our EAS Build is queued, and the EAS CLI provides a link to view build details and track progress on the EAS dashboard:
Note: What does a build details page contain?
---
The build details page displays the build type, profile, Expo SDK version, app version, build number, last commit hash, and the identity of the developer or account owner who initiated the build.
In the above image, the current status of the **Build artifact** shows that the build is in progress. Upon completion, this section will offer an option to download the build. The **Logs** outlines every step taken during the iOS build process on EAS Build. For the sake of brevity, we won't explore each step in detail here. To learn more, see [iOS build process](/build-reference/ios-builds/).
---
Note: What is iOS bundle identifier?
---
The `ios.bundleIdentifier` is a unique name of our app. If we publish our app right now, the Apple App Store will use this property and its value to identify our app on the store.
This notation is defined as `host.owner.app-name`. For example, our example app has `com.owner.stickersmash` where `com.owner` is the domain and `stickersmash` is our app name.
---
Step 2: 
### Install
In the terminal, once the build finishes, EAS CLI prompts us by asking whether we want to run the build on an iOS Simulator. Press <kbd>Y</kbd>.
Note: Alternate: Use Expo Orbit
---
You can use [Expo Orbit](https://expo.dev/orbit) to install the development build. From **Build artifact** on the EAS dashboard, click **Open with Expo Orbit** to install the development build on the iOS Simulator.
---
Step 3: 
### Run
Start the development server by running the `npx expo start` command from the project directory:
```sh
$ npx expo start
```
Press <kbd>i</kbd> in the terminal window to open the project on the iOS Simulator.
## Summary
<ProgressTracker
  currentChapterIndex={2}
  name="EAS_TUTORIAL"
  summary="We successfully used EAS Build to create and run development builds on iOS Simulators."
  nextChapterDescription="In the next chapter, let's create a development build for iOS, install it on a device, and get it running."
  nextChapterTitle="Create and run a cloud build for iOS device"
  nextChapterLink="/tutorial/eas/ios-development-build-for-devices/"
/>


## Create and run a cloud build for iOS device

Learn how to configure a development build for iOS devices using EAS Build.

In this chapter, we'll create a development build that can run on an iOS device with EAS Build.
Development builds for iOS devices are generated in the **.ipa** format, which is standard for iOS app installations.
Video Tutorial: [Watch: Creating a development build for iOS physical device](https://www.youtube.com/watch?v=HbfWU7_o4cU)
---
## Prerequisites
Before we begin, ensure you have:
- **Apple Developer Account:** This is required to access [necessary credentials](/app-signing/app-credentials/#ios) for signing our app, as each build needs to be signed to verify that the app comes from a trusted source. EAS Build helps manage these credentials.
- **Developer Mode activated on iOS 16 and higher:** Installing development builds on your device requires Developer Mode to be enabled. If this is your first time or if it's currently disabled, see these instructions to [activate Developer Mode](/guides/ios-developer-mode/).
## Provisioning profile
To initiate development on an iOS device, we have to:
- Register the device by creating a new [provisioning profile](/app-signing/app-credentials/#provisioning-profiles).
- Download and install this profile onto the device.
Step 1: 
### Register an iOS device
With EAS CLI, run the command to register a new Apple device:
```sh
$ eas device:create
```
This command prompts us with the following questions:
- **You're inside the project directory. Would you like to use the** **your-account-name** **account?** Press <kbd>Y</kbd>.
- **Apple ID.** For this step, enter your Apple ID. It will then log in to our Apple Developer account. Follow the steps in the terminal window.
- **How would you like to register your devices?** Select **Website** that generates a registration URL that can be opened on the iOS device.
> **info** **Tip**: If you or your team have multiple devices, you can share the provisioning profile link with those devices for downloading and installing the profile.
Step 2: 
### Download and install profile
On a device's web browser, open the link provided in the previous step and tap the **Download Profile button**.
Open the **Settings** app, which prompts us to register our device.
Tap **Install** to register the iOS device.
After the provisioning profile is installed, our device redirects us back to the web browser, displaying a success message indicating the completion of the process.
## Development build for iOS device
Step 1: 
### Create
To create a development build on an iOS device, make sure that under the `build.development` profile:
- The `developmentClient` is set to `true` in **eas.json**, which is done by the default configuration.
- Then, run the `eas build` command with `ios` as the platform and `development` as the build profile:
```sh
$ eas build --platform ios --profile development
```
> **info** **Tip**: Next time you run `eas build` command, you can also use `-p` to specify the platform. It is short for `--platform`.
This command prompts us with the following questions when we create the build for the first time:
- **What would you like your iOS bundle identifier to be?** Press <kbd>return</kbd> to select the default value provided for this prompt. This will add [`ios.bundleIdentifier`](/versions/latest/config/app/#package) in **app.json** if it isn't already defined.
- **Do you want to log in to your Apple account?**. Since we are creating a development build for the first time, it will ask us to **Generate a new Apple Distribution Certificate**. Press <kbd>Y</kbd> both times.
- **Select a device for ad hoc build**. This is the key part, which is why we had to register a provisioning profile before. We can select one or all of our registered devices here and then press return to install that build on those devices later.
> **info** **Only if you have skipped [iOS Simulator chapter](/tutorial/eas/ios-development-build-for-simulators/):** You'll be prompted **iOS app only uses standard/exempt encryption?** Press <kbd>Y</kbd> to select the default value provided for this prompt. Since our app doesn't use encryption, it sets `ITSAppUsesNonExemptEncryption` in the **Info.plist** file to `NO` and manages the compliance check for the same when you are releasing your app to TestFlight/Apple App Store. When you are releasing your own app, and it uses encryption, you can select `N` to skip this prompt next time.
After responding, the build will queue up, and we can track its progress via a provided link by the EAS CLI in the EAS dashboard:
Note: What does a build details page contain?
---
The build details page displays the build type, profile, Expo SDK version, app version, build number, last commit hash, and the identity of the developer or account owner who initiated the build.
In the above image, the current status of the **Build artifact** shows that the build is in progress. Upon completion, this section will offer an option to download the build. The **Logs** outlines every step taken during the iOS build process on EAS Build. For the sake of brevity, we won't explore each step in detail here. To learn more, see [iOS build process](/build-reference/ios-builds/).
---
Note: What is iOS bundle identifier?
---
The `ios.bundleIdentifier` is a unique name of our app. If we publish our app right now, the Apple App Store will use this property and its value to identify our app on the store.
This notation is defined as `host.owner.app-name`. For example, our example app has `com.owner.stickersmash` where `com.owner` is the domain and `stickersmash` is our app name.
---
Step 2: 
### Install
Once the build finishes, the Build artifact section gets updated, indicating that the build is complete:
This section provides the methods available for running the development build on an iOS device: Expo Orbit and Install button.
[Expo Orbit](https://expo.dev/orbit) allows for seamless installation of the development build on an iOS device. To use this method:
- Connect our iOS device to our developer machine using USB.
- Open the Orbit menu bar app.
- Select the **Device** in the Orbit app.
- On the EAS dashboard, under **Build artifact**, click the **Open with Orbit**.
After the build is installed, the Orbit app launches the development build on the device.
Note: Alternate: Use the Install button and QR code
---
The **Install** button in the **Build artifact** section generates a QR code for easy installation:
- Click **Install** to display a popup with the QR code.
- Scan the QR code with our iOS device's camera to open and tap the link to download the development build on the device.
---
Step 3: 
### Run
Start the development server by running the `npx expo start` command from the project directory:
```sh
$ npx expo start
```
- On the device, tap the app icon to open the development build.
- Use the account syncing feature by ensuring we're logged into both the EAS CLI and development build. As we're already logged into the EAS CLI, the next step is to log in through the UI of your development build.
- Tap **Fetch development servers** and select the server running from the list under Development servers.
## Summary
<ProgressTracker
  currentChapterIndex={3}
  name="EAS_TUTORIAL"
  summary="We successfully used EAS Build to create and run development builds on iOS devices."
  nextChapterDescription="In the next chapter, learn how to configure our app config to install multiple app variants on a single device."
  nextChapterTitle="Configure multiple app variants"
  nextChapterLink="/tutorial/eas/multiple-app-variants/"
/>


## Configure multiple app variants

Learn how to configure dynamic app config to install multiple app variants on a single device.

In this chapter, we'll configure our project to run multiple build types (development, preview, production) on a single device simultaneously. This setup will allow us to test various stages of our app development without the need to uninstall and reinstall different versions.
Video Tutorial: [Watch: How to configure multiple app variants](https://www.youtube.com/watch?v=UtJJCAfrjIg)
---
Each variant requires a unique Android Application ID and iOS Bundle Identifier to enable simultaneous installations on one device. Here's how the IDs are set up in our **app.json** file:
```json app.json
{
  "ios": {
    "bundleIdentifier": "com.yourname.stickersmash"
  },
  "android": {
    "package": "com.yourname.stickersmash"
  }
}
```
Step 1: 
## Add app.config.js for dynamic configuration
**app.json** contains app-related configuration in a JSON file. It's static and isn't ideal if we want to use [dynamic values for certain properties](/workflow/configuration/#dynamic-configuration). We're going to add different Android Application IDs and iOS Bundle Identifiers for all build profiles based on [environment variables](/workflow/configuration/#switching-configuration-based-on-the-environment).
- In the root of your project, create a new file called **app.config.js**.
- In **app.config.js**, export a default function that takes `config` as its argument. We'll then destructure the `config` to copy all existing properties from **app.json**.
```js app.config.js
export default ({ config }) => ({
  ...config,
});
```
Step 2: 
## Update dynamic values based on environment
To identify the build type, let's add two environment variables called `IS_DEV` and`IS_PREVIEW` for `development` and `preview` build profiles in **app.config.js**:
```js app.config.js
const IS_DEV = process.env.APP_VARIANT === 'development';
const IS_PREVIEW = process.env.APP_VARIANT === 'preview';
```
Then, add two functions that dynamically change the app name, Android Application ID and iOS Bundle Identifier:
```js app.config.js
const getUniqueIdentifier = () => {
  if (IS_DEV) {
    return 'com.yourname.stickersmash.dev';
  }
  if (IS_PREVIEW) {
    return 'com.yourname.stickersmash.preview';
  }
  return 'com.yourname.stickersmash';
};
const getAppName = () => {
  if (IS_DEV) {
    return 'StickerSmash (Dev)';
  }
  if (IS_PREVIEW) {
    return 'StickerSmash (Preview)';
  }
  return 'StickerSmash: Emoji Stickers';
};
```
We'll use `getAppName()` to assign dynamic `name` values for the app and `getUniqueIdentifier()` to differentiate `android.package` and `ios.bundleIdentifier` for development and preview builds:
```js app.config.js
export default ({ config }) => ({
  ...config,
  name: getAppName(),
  ios: {
    ...config.ios,
    bundleIdentifier: getUniqueIdentifier(),
  },
  android: {
    ...config.android,
    package: getUniqueIdentifier(),
  },
});
```
Step 3: 
## Configure eas.json
In **eas.json**, add the `APP_VARIANT` environment variable:
```json eas.json|collapseHeight=440
{
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "env": {
        "APP_VARIANT": "development"
      }
    },
    "preview": {
      "distribution": "internal",
      "env": {
        "APP_VARIANT": "preview"
      }
    }
  }
}
```
Running `eas build --profile development` will now set `APP_VARIANT` to `development`.
> **Note**: Since we changed the Android Application ID and iOS Bundle Identifier, the EAS CLI will prompt us to generate a new Keystore for Android and a new provisioning profile for iOS. To learn more about what these steps include, see the previous chapter for more information.
Since our `ios-simulator` build profile extends `development`, this configuration is automatically applied for iOS Simulators.
Step 4: 
## Run development server
> After builds are complete, follow the same procedure from previous chapters to install them on a device or emulator/simulator.
Since we're identifying our development build with the `APP_VARIANT` environment variable, we need to pass it to the command when starting the development server. To do this, add a `dev` script in the [`"scripts"`](https://docs.npmjs.com/cli/v10/using-npm/scripts) field of our project's **package.json**:
```json package.json
{
  "scripts": {
    "dev": "APP_VARIANT=development npx expo start"
  }
}
```
Run the `npm run dev` command to start the development server:
```sh
$ npm run dev
```
This script will evaluate **app.config.js** locally and load the environment variable for the `development` profile.
Now, our development build will run on both Android and iOS, displaying the modified app name from **app.config.js**. For example, the below development build is running on an iOS Simulator. See that the app name is **StickerSmash (Dev)**:
You can now continue using **app.json** for static values and use **app.config.js** for dynamic values.
## Summary
<ProgressTracker
  currentChapterIndex={4}
  name="EAS_TUTORIAL"
  summary={
    <>
      We successfully created <strong>app.config.js</strong> just for our dynamic configuration
      while leaving static configuration in <strong>app.json</strong> unchanged, added environment
      variables in <strong>eas.json</strong> to configure specific build profile, and learned how to
      start the development server with a custom <strong>package.json</strong> script.
    </>
  }
  nextChapterDescription="In the next chapter, learn about what are internal distribution builds, why we need them, and how to create them."
  nextChapterTitle="Create and share internal distribution build"
  nextChapterLink="/tutorial/eas/internal-distribution-builds/"
/>


## Create and share internal distribution build

Learn about internal distribution builds, why we need them, and how to create them.

In this chapter, we'll learn how to set up [internal distribution builds](/build/internal-distribution/#internal-distribution).
Video Tutorial: [Watch: How to create and share an internal distribution build](https://www.youtube.com/watch?v=1fQuGLHxWks)
---
## Internal distribution build
Internal distribution builds are ideal for sharing updates with team members, allowing both technical and non-technical stakeholders to provide feedback directly. Unlike development builds, these do not require running a development server, simplifying the testing process.
### Ways to distribute an app internally
Both Google and Apple provide built-in mechanisms for sharing apps internally:
- **Android**: Using Google Play beta
- **iOS**: Using TestFlight
However, both of these traditional methods have their limitations. For example, TestFlight limits to one active build at a time.
### EAS Build for faster distribution
EAS Build speeds up the process. It creates shareable links for our builds and provides instructions on using them. It has a default configuration designed to facilitate internal distribution, offering a more efficient alternative to traditional methods.
## Create an internal distribution build
To create and distribute a build with EAS Build, we need to follow these steps:
Step 1: 
### Configure preview build profile
From our initial setup in **eas.json**, we already have a default configuration that includes a `preview` build profile designed for internal distribution:
```json eas.json
{
  "build": {
    "preview": {
      "distribution": "internal"
    }
  }
}
```
This is all we need to create our first internal distribution build. The `preview` build profile from the above snippet has a `distribution` property whose value is set to `internal`. This value allows us to share our build URLs with anyone so they can install it on their device and do not require a development server to run the app.
As discussed in the previous chapters, for non-app store builds, Android requires **.apk** and iOS needs **.ipa** formats. This applies to internal distribution builds as well. The `distribution` when set to `internal`, automatically creates the app binary in these file formats for devices.
Step 2: 
### Create
Creating an internal distribution build requires [app signing credentials](/app-signing/app-credentials/).
Android app signing is non-restrictive and allows installing any compatible **.apk** file. When a development build was created, a new Android Keystore was generated for it. Hence, there is no need to generate a new keystore for preview builds.
On the other hand, Apple has stricter rules for app distribution on iOS devices. We need an ad hoc provisioning profile that explicitly lists the devices allowed to run the app. Some organizations whose apps meet specific requirements may be able to use the [Apple Developer Enterprise Program](https://developer.apple.com/programs/enterprise/) to distribute apps internally to a larger audience.
For Android: 
- Use the `preview` profile to initiate an Android build:
```sh
$ eas build --platform android --profile preview
```
- This command triggers the EAS Build, and on the EAS dashboard, we can see the build's progress:
For iOS: 
Apps signed with an ad hoc provisioning profile can be installed by an iOS device whose UDID is registered with the provisioning profile.
- To register more devices, use `eas device:create`. This command registers an iOS device and gives us a URL or QR code to share for device registration:
```sh
$ eas device:create
```
- This command registers an iOS device for app installation, generating a shareable URL (or QR code) for device registration.
  > **info** **Tip**: This command enables device registration at any time. However, only builds created post-registration will work on the newly added device.
- To create the preview build, we need to use the `preview` profile with the `eas build` command:
```sh
$ eas build --platform ios --profile preview
```
- This command triggers the EAS Build, and on the EAS dashboard, we can see the build's progress:
Note: Alternative method to register devices using 
---
[`eas build:resign`](/app-signing/app-credentials/#re-signing-new-credentials) command can be used to re-sign an existing iOS **.ipa** with a new ad hoc provisioning profile, eliminating the need for a full rebuild.
---
Note: Are you setting up enterprise provisioning?
---
Apple Enterprise Program membership costs $299 USD per year and [not all organizations will be eligible](https://developer.apple.com/programs/enterprise/), so you will likely be using ad hoc provisioning, which works with any normal paid Apple Developer account.
If you have an [Apple Developer Enterprise Program membership](https://developer.apple.com/programs/enterprise/) users can install your app to their device without pre-registering their UDID. They just need to install the profile to their device and they can then access existing builds. You will need to sign in using your Apple Developer Enterprise account during the `eas build` process to set up the correct provisioning.
If you distribute your app both through enterprise provisioning and the App Store, you will need to have a distinct bundle identifier for each context. We recommend either:
- In projects generated with Expo CLI, use [**app.config.js** to dynamically switch identifiers](/tutorial/eas/multiple-app-variants/).
- In [existing React Native projects](/bare/overview/), create a separate `scheme` for each bundle identifier and specify the scheme name in separate build profiles.
---
Note: Are you using manual local credentials?
---
If so, make sure to point your **credentials.json** to an ad hoc or enterprise provisioning profile that you generate through the Apple Developer Portal (either update an existing **credentials.json** used for another type of distribution or replace it with a new one that points to the appropriate provisioning profile). Beware that EAS CLI does only a limited validation of your local credentials, and you will have to handle device UDID registration manually. Read more about [using local credentials](/app-signing/local-credentials).
---
Step 3: 
### Install
Once the build finishes, the Build artifact section gets updated, indicating that the build is complete. This section provides the methods available for running the development build on an iOS device: Expo Orbit and Install button.
- Open the build's detail page. If you are sharing the build with someone else, you can send them the link to the build. They'll be able to open the build's detail page or build artifact details which include Expo Orbit.
- Connect the Android or iOS device to your machine using USB.
- Open the Orbit menu bar app.
- Select the **Device** in the Orbit app.
- Under **Build artifact**, click the **Open with Orbit**.
Note: Alternate: Use Install and QR code
---
- Open the build's detail page. If you are sharing the build with someone else, you can send them the link to the build page. They'll be able to open it and see build artifact details which includes Expo Orbit.
- Click **Install** under the Build artifact section to display the **Install on a test device** popup.
- Copy the link from **Send a link to a device** section and send it to the test device.
---
Step 4: 
### Run
Tap the app icon on your device to start the preview build. There is no need for a development server.
Since we have already set up multiple app variants, we can see both the development and preview variants installed separately on our devices. For example:
- On Android:
- On iOS:
## Summary
<ProgressTracker
  currentChapterIndex={5}
  name="EAS_TUTORIAL"
  summary="We successfully created internal distribution builds for Android and iOS, used ad hoc provisioning for iOS, and installed multiple app variants on the same device."
  nextChapterDescription="In the next chapter, learn about developer-facing and user-facing app versions and how to manage them automatically."
  nextChapterTitle="Manage different app versions"
  nextChapterLink="/tutorial/eas/manage-app-versions/"
/>


## Manage different app versions

Learn about developer-facing and user-facing app versions and how EAS Build automatically manages developer-facing versions.

In this chapter, we'll learn how EAS Build automatically manages the developer-facing app version for Android and iOS. Learning about it will be useful before we dive into production build in the next two chapters.
Video Tutorial: [Watch: Automating app version code](https://www.youtube.com/watch?v=C8x4N9UmzS8)
---
## Understanding developer-facing and user-facing app versions
An app version is composed of two values:
- Developer-facing value: Represented by [`versionCode`](/versions/latest/config/app/#versioncode) for Android and [`buildNumber`](/versions/latest/config/app/#buildnumber) for iOS.
- User-facing value: Represented by [`version`](/versions/latest/config/app/#version) **app.config.js**.
Both Google Play Store and Apple App Store rely on developer-facing values to identify each unique build. For example, if we upload an app with the app version `1.0.0 (1)` (which is a combination of user-facing and developer-facing values), we cannot submit another build to the app stores with the same app version. Submitting builds with duplicate app version numbers results in a failed submission.
An example demonstration of manually managing developer-facing values is shown below by `android.versionCode` and `ios.buildNumber` in **app.config.js**. **We don't have to add or manage these values manually since EAS Build automates this for us**.
```js app.config.js
{
  ios: {
    buildNumber: 1
  },
  android: {
    versionCode: 1
  }
}
```
> **Note**: The [user-facing version number](/build-reference/app-versions/#user-facing-version) is not handled by EAS. Instead, we define that in the app store developer portals before submitting our production app for review.
## Automatic app version management with EAS Build
By default, EAS Build assists in automating developer-facing values. It utilizes the [remote version source](/build-reference/app-versions/#remote-version-source) to automatically increment developer-facing values whenever a new production release is made.
When we initialized the project with `eas init` command, the EAS CLI automatically added the following properties in **eas.json**:
- `cli.appVersionSource` which is set to `remote`
- [`build.production.autoIncrement`](/eas/json/#autoincrement-1) which is set to `true`
You can view them in your project's **eas.json**:
```json eas.json
{
  "cli": {
    "appVersionSource": "remote"
  },
  "build": {
    "production": {
      "autoIncrement": true
    }
  }
}
```
When we create a new production build in the next two chapters, the `versionCode` for Android and `buildNumber` for iOS will increment automatically.
Note: Syncing developer-facing app versions for already published apps to EAS
---
If your app is already published in the app stores, the developer-facing app versions are already set. When migrating this app to use EAS Build, follow the steps below to sync those app versions:
- In the terminal window, run the `eas build:version:set` command:
```sh
$ eas build:version:set
```
- Select the platform (Android or iOS) when prompted.
- When prompted **Do you want to set app version source to remote now?**, select **yes**. This will set the `cli.appVersionSource` to `remote` in **eas.json**.
- When prompted **What version would you like to initialize it with?**, enter the last version number that you have set in the app stores.
After these steps, the app versions will be synced to EAS Build remotely. You can set `build.production.autoIncrement` to `true` in **eas.json**. When you create a new production build, the `versionCode` and `buildNumber` will be automatically incremented from now on.
---
## Summary
<ProgressTracker
  currentChapterIndex={6}
  name="EAS_TUTORIAL"
  summary={
    <>
      We successfully explored app versioning differences, addressed the importance of unique app
      versions to prevent store rejections, and enabled automated version updates in{' '}
      <strong>eas.json</strong> for production builds.
    </>
  }
  nextChapterDescription="In the next chapter, learn about the process of creating a production build for Android."
  nextChapterTitle="Create a production build for Android"
  nextChapterLink="/tutorial/eas/android-production-build/"
/>


## Create a production build for Android

Learn about the process of creating a production build for Android and automating the release process.

In this chapter, we'll create our example app's production version and submit it to the Google Play Store. We'll also explore how to automate the creation and release of new app versions.
Video Tutorial: [Watch: Creating and releasing a production build for Android](https://www.youtube.com/watch?v=nxlt8uwqhpE)
---
## Prerequisites
To publish and distribute an app on the Google Play Store, we need:
- **Google Play Developer Account:** Must have a paid developer account. For details on setting one up, visit the [Google Play sign-up page](https://play.google.com/apps/publish/signup/).
- **Google Service Account key:** We'll need a Google Service Account email and JSON key to automate the app submission process. **Follow the detailed instructions in our guide on [creating a Google Service Account key or downloading it from an existing account ](https://expo.fyi/creating-google-service-account), then return to this guide.** This is optional but required for [automating the release process](#automated-release).
- **Production build profile:** Ensure that a `production` build profile is present in your **eas.json**, which is added by default.
## Production build for Android
A [production Android build](/build/eas-json/#production-builds) has a **.aab** format which is optimized for distribution on the Google Play Store. Unlike **.apk** builds, **.aab** files can only be distributed and installed through the Google Play Store.
Step 1: 
## Create a production build
To create an Android production build using the default `production` profile, open your terminal and execute the following command. Since `production` is set as the default profile in the EAS configuration, there is no need to specify it explicitly with the `--profile` flag.
```sh
$ eas build --platform android
```
The above command will queue the build. Notice in the EAS dashboard that the **Version Code** is auto-incremented.
Step 2: 
## Create an app on the Google Play Console
To upload the app to the Google Play Store for the first time, we need to:
- Go to the Google Play dashboard.
- On the **Home** page, click **Create app** to make a new app.
- Fill out our app details and click the **Create app** button.
Step 3: 
## Release an internal testing version
After the app is created on Google Play Console, it redirects us to the app's Dashboard screen. We need to prepare an internal test version of our app.
- Click **Start testing now** on the **Dashboard**.
- Create an email list of users under **Internal Testing** > **Testers for the internal testing release**.
- Google Play Console prompts us to create an internal testing release.
- To create a new release, go to **Dashboard** and click **Create new release**. The first thing you will notice that the signing key is automatically generated under **App integrity** by Google Play Console.
Step 4: 
## Upload the app binary
After EAS has created a production build:
- Open the EAS dashboard and click on **Download** to get the **.aab** file.
- Return to Google Play Console and go to **Test and release** > **Testing** > **Internal testing**.
- Under **App bundles**, click on **Upload** to add the **.aab** file. Then, provide the release details for our app and click on **Next**.
- On the following screen, click on **Save and publish**.
Step 5: 
## Share the internal release version
Under **Track Summary**, we see that the latest release shows a temporary app name. This is because our app is not reviewed yet.
Under **Releases**, we see that the app is available to internal testers. To share the app with a team of testers:
- Switch to the **Testers** tab next to **Releases**.
- Click on **copy link** under **How testers join your test**. You can use this link to share with your team of testers by sending them an email or a message.
- On the device, open the test email and follow the steps to download the app.
- The testing email holder needs to accept the invite, and once accepted, the app can be installed on the device.
> **info** **Tip**: To publish an app on the Play Store, in the Google Dashboard, finish the steps under **Set up your app**. These steps are required before releasing the app on the Play Store for the first time. You'll have to provide details like a link to a privacy policy, a target audience, data safety and so on.
> **Complete app store listing**: To prepare the app for store listing, see [Create app store assets](/guides/store-assets/) on how to create screenshots and previews.
Note: Promoting a testing release
---
To promote our internal test release version to **alpha**, in Google Play Store Console:
- Under **Test and release**, go to **Testing** > **Closed testing**.
- Click **Manage track** next to **Closed testing - Alpha**.
---
Step 6: 
## Add Google Service Account permissions key
> **info** **Tip**: Before following the steps in this section, see the instructions on [creating a Google Service Account key or downloading it from an existing account ](https://expo.fyi/creating-google-service-account) guide.
From now on, we can use [EAS Submit](/submit/introduction/) to automate releases and avoid the manual process. To do that, we need to add the service account key to our project's credentials.
After following the Google Service Account guide steps, we can upload the downloaded JSON key to EAS dashboard:
- Go to your project's EAS dashboard, click **Credentials**, and under **Android**, click your app's **Application identifier**.
- Under **Service Credentials**, click **Add a Google Service Account Key**.
- Under **Change Google Service Account Key**, ensure **Upload new key** is selected and upload the downloaded JSON key. This will add the key to your project's credentials.
Step 7: 
## Internal release
Let's set the track to `internal` in **eas.json**.
- Under `submit.production` profile, set `track` to `internal`:
```json
{
  "submit": {
    "production": {
      "android": {
        "track": "internal"
      }
    }
  }
}
```
In the above snippet, we're adding [`track`](/eas/json/#track) property and setting its value to `internal`. This will enable the `eas submit` command to upload our production build and release it for internal testing on the Google Play Store.
- Now run the `eas submit` command to release a new internal testing version:
```sh
$ eas submit --platform android
```
- This command will automatically create a new internal release version in Google Play Console:
Step 8: 
## Production release
To release the app for production:
- Change the value for `track` to `production` in **eas.json**:
```json
{
  "submit": {
    "production": {
      "android": {
        "track": "production"
      }
    }
  }
}
```
- We can also use the same EAS Build we did for the internal testing release. Run the `eas submit` command to release to the Play Store:
```sh
$ eas submit --platform android
```
- To create a track and submit our app to the Google Play Store's review process, we need to go to **Test and release** > **Production** and under **Releases**, select the build we want to send for review.
Step 9: 
## Automated release
For subsequent releases in future, we can streamline the process by combining build creation and Play Store submission into a single step by using the [`--auto-submit`](/build/automate-submissions/) flag with `eas build`:
```sh
$ eas build --platform android --auto-submit
```
## Summary
<ProgressTracker
  currentChapterIndex={7}
  name="EAS_TUTORIAL"
  summary={
    <>
      We successfully created a production-ready Android build, discussed manual and automated
      uploading to Google Play Store using , and automated the release
      process with the .
    </>
  }
  nextChapterDescription="
In the next chapter, learn about the process of creating a production build for iOS."
  nextChapterTitle="Create a production build for iOS"
  nextChapterLink="/tutorial/eas/ios-production-build/"
/>


## Create a production build for iOS

Learn about the process of creating a production build for iOS and automating the release process.

In this chapter, we'll create our example app's production version and submit it for testing using TestFlight. After that, we'll submit them for App Store review to get it on the App Store.
Video Tutorial: [Watch: Creating and releasing a production build for iOS](https://www.youtube.com/watch?v=VZL_e0cEwo8)
---
## Prerequisites
To publish and distribute an app on the Apple Play Store, we need:
- **Apple Developer account:** To create one, see [Apple Developer Portal](https://developer.apple.com/account/).
- **Production build profile:** Ensure that a `production` build profile is present in your **eas.json**, which is added by default.
## Production build for iOS
A [production iOS build](/build/eas-json/#production-builds) is optimized for Apple's App Store Connect, which allows distributing builds to testers with TestFlight and public end users through the App Store. This build type cannot be side-loaded on a simulator or device and can only be distributed through App Store Connect.
Step 1: 
## Create a distribution provisioning profile
Run the `eas credentials` command in the terminal and then answer the following prompts by EAS CLI:
- **Select platform** iOS.
- **Which build profile do you want to configure?** Select production.
- **Do you want to log in to your Apple account?** Press <kbd>Y</kbd>. This will log in to our Apple Developer account.
- **What do you want to do?** Select **Build credentials** and choose **All: Set up all the required credentials to build your project**.
- Now, it will prompt whether we want to re-use the previous Distribution Certificate. Press <kbd>Y</kbd>.
- **Generate a new Apple Provisioning Profile?** Press <kbd>Y</kbd>. This will be the provisioning profile for the production app.
- Once the profiles are created, press any <kbd>ctrl</kbd> + <kbd>c</kbd> to exit the EAS CLI.
Step 2: 
## Create a production build
To create an iOS production build using the default `production` profile, open your terminal and execute the following command. Since `production` is set as the default profile in the EAS configuration, there is no need to specify it explicitly with the `--profile` flag.
```sh
$ eas build --platform ios
```
The command will queue the build. Notice on the EAS dashboard that the **Build Number** is auto-incremented.
Step 3: 
## Submit the app binary to the App Store
To submit the app binary created from our latest EAS Build, run the [`eas submit`](/submit/introduction/) command:
```sh
$ eas submit --platform ios
```
After running this command, we need to:
- **Select a build from EAS.** Let's select the latest build ID.
- **Follow the prompt to log in to our Apple account.** When it asks for **Reuse this App Store Connect API Key?** Press <kbd>Y</kbd>.
This will trigger the submission process.
Step 4: 
## Release an internal testing version
After the submission process is complete, we'll need to log in to the Apple Developer account from the web browser.
- Click **[Apps](https://appstoreconnect.apple.com/apps),** and see the app icon.
- Click the app name, and from the navigation tab menu, click **TestFlight**. If the build was just submitted, it may take a few minutes for Apple to process the build before it is available to distribute with TestFlight.
> **info** **Only if you have skipped [iOS development build for devices chapter](/tutorial/eas/ios-development-build-for-devices/):** You'll be prompted **iOS app only uses standard/exempt encryption?** Press <kbd>Y</kbd> to select the default value provided for this prompt. Since our app doesn't use encryption, it sets `ITSAppUsesNonExemptEncryption` in the **Info.plist** file to `NO` and manages the compliance check for the same when you are releasing your app to TestFlight/Apple App Store. When you are releasing your own app, and it uses encryption, you can select `N` to skip this prompt next time.
- In App Store Connect, under **Internal Testing**, and create a test group. This will allow us to invite test users.
- Once the group is created, an email will be sent to all the test users.
- In the email, click **View in TestFlight,** accept the invite, and then tap **Install**.
After that, the app will download on our device so that we can test it.
> **Note**: Similar to internal testing, we can also create a group for inviting external testers using TestFlight. Where internal testing has a limit of 100 users, TestFlight allows sharing a test release version externally with up to 10,000 testers and provides a publicly shareable link. For brevity, we are not going to cover those steps in this tutorial.
Step 5: 
## Submit the app to the Apple App Store
To prepare our app for App Store submission, go to the **App Store** tab:
- Provide metadata details, provide screenshots as per Apple's guidelines and also fill details under **General**.
- Then, manually select the build.
> **Complete App Store listing**: To prepare the app for store listing, see [Create app store assets](/guides/store-assets/) on how to create screenshots and previews.
- Once our app is ready, click on **Submit to App Review**. After that, Apple will review our app, and if approved, the app will be available on the App Store.
Step 6: 
## Automated submissions
For future releases, we can streamline the process by combining build creation and App Store submission into a single step by using the [`--auto-submit`](/build/automate-submissions/) flag with `eas build`:
```sh
$ eas build --platform ios --auto-submit
```
> **Note:** This command will automatically upload your build to TestFlight for internal testing, but it will not automatically submit your app for App Store review. You'll still need to manually promote the build from TestFlight to the App Store when you're ready for public release. For more information, see [Default submission behavior for app stores](/build/automate-submissions/#default-submission-behavior-for-app-stores).
## Summary
<ProgressTracker
  currentChapterIndex={8}
  name="EAS_TUTORIAL"
  summary={
    <>
      We successfully created a production-ready iOS build, discussed distribution using TestFlight
      and Apple App Store using , and automated the release process with the{' '}
      .
    </>
  }
  nextChapterDescription="In the next chapter, learn how to use the EAS Update to send OTA updates and share previews with our team."
  nextChapterTitle="Share previews with your team"
  nextChapterLink="/tutorial/eas/team-development/"
/>


## Share previews with your team

Learn how to use EAS Update to send OTA updates and share previews with a team.

Updates generally fix small bugs and push small changes in between app store releases. They allow updating the non-native parts of our example app, such as JavaScript code, styling, and images.
In this chapter, we'll use [EAS Update](/eas-update/introduction/) to share changes with our team. This will help [us and our team quickly share previews](/review/overview/) of the change.
Video Tutorial: [Watch: How to share previews with your team](https://www.youtube.com/watch?v=vPKh-tNm-yI)
---
Step 1: 
## Install expo-updates library
To initialize our project and send an update, we need to use the [`expo-updates`](/versions/latest/sdk/updates/) library. Run the following command to install it:
```sh
$ npx expo install expo-updates
```
Step 2: 
## Configure EAS Update
To initialize our project with EAS Update, we need to follow these steps:
- Since we are using dynamic **app.config.js** for our app's configuration, adding [`updates`](/versions/latest/config/app/#updates) and [`runtimeVersion`](/eas-update/runtime-versions/#setting-runtimeversion) properties are required to make our project compatible with EAS Update. Run the following command to obtain these properties and their values from EAS and manually copy them to **app.config.js**:
```sh
$ eas update:configure
```
Note: What about non-dynamic (app.json) projects?
---
If a project doesn't use dynamic app config (uses **app.json** instead of **app.config.js**), the above command will configure our app to be compatible with EAS Update and add the right properties to **app.json** and **eas.json**.
---
- Re-run `eas update:configure` to continue with the setup process. A [`channel`](/eas/json/#channel) should be added to every build profile in **eas.json**:
```json eas.json
{
  "build": {
    "development": {
      "channel": "development"
    },
    "ios-simulator": {
    },
    "preview": {
      "channel": "preview"
    },
    "production": {
      "channel": "production"
    }
  }
}
```
> **info** Notice that the `eas update:configure` command adds the `channel` to every build profile in **eas.json**. However, our `ios-simulator` profile extends the `development` profile and having a separate `channel` doesn't make sense. We can safely remove `ios-simulator.channel` from the above configuration.
Note: What is a channel?
---
[Channels](/eas-update/how-it-works/#conceptual-overview) are used to group builds together. If we have an Android and iOS build, both on the app store, we can give them both a channel of production. Later, we can tell EAS Update to target the production channel, so our update will affect all builds with a production channel.
---
Step 3: 
## Create a development build
We need to create a new development build since our last build doesn't contain the `expo-updates` library. Run the following command:
```sh
$ eas build --platform android --profile development
```
> We are using a development build for Android devices to demonstrate updates. However, we can use `--platform all` or `--platform ios` to create a build for both platforms or just for iOS.
After the new version of the development build is created, make sure to install it on a device.
Step 4: 
## Modify the JavaScript code of the app
Let's modify our example app's JavaScript code. If you are not using [Sticker Smash app](/tutorial/eas/introduction/#prerequisites), you can modify any piece of your code to see the changes in the app.
We'll modify the text of the first button in our example app that says **Choose a photo** to **Select a photo**.
```tsx app/(tabs)/index.tsx
<Button theme="primary" label="Select a photo" onPress={pickImageAsync} />
```
Step 5: 
## Publish an update
Instead of creating a new build to share this change with our team for testing, let's publish an update:
```sh
$ eas update --channel development --message "Change first button label"
```
In the command above, we used the `development` channel. Every update is associated with a [channel name](/eas-update/how-it-works/#publishing-an-update). It is similar to every commit that we make with git, which is associated with a git branch.
So, by using the channel `development` in our build profile and then publishing an, we're asking EAS to deliver this update to builds with the `development` channel. When we make an EAS Update channel it automatically gets mapped to a branch with the same name.
After the update is published, the CLI will prompt us with information about it.
Click on the **Website link** to see the Update on the EAS dashboard under **Over-the-air updates** > **Update groups**:
Step 6: 
## Preview the update live in a development build
To preview the live update in a development build:
- Log in to your Expo account within the development build.
- Open the **Extensions** tab.
- Look for **Branch: development** listed under **EAS Update**.
- Tap on **Open** to access the update.
Step 7: 
## Sharing changes with preview or production builds
Updates for non-development builds (preview or production) are automatically downloaded to the device when the app starts up and makes a request for any new updates.
Any team member running the preview or production build will receive the update with the changes we push to those specific branches.
For example, for a `preview` build, we can run:
```sh
$ eas update --channel preview --message "Change first button label"
```
Here is an example where we've published an update for the `preview` build. To test the update, force close and reopen the app twice to download and view the changes:
## Summary
<ProgressTracker
  currentChapterIndex={9}
  name="EAS_TUTORIAL"
  summary="We successfully configured  EAS Update to manage and publish over-the-air updates across platforms, and explored methods to fetch updates to review."
  nextChapterDescription="In the next chapter, learn about the process of triggering builds from a GitHub repository."
  nextChapterTitle="Trigger builds from a GitHub repository"
  nextChapterLink="/tutorial/eas/using-github/"
/>


## Trigger builds from a GitHub repository

Learn about the process of triggering builds from a GitHub repository.

[Expo GitHub App](/build/building-from-github/) automatically triggers builds from our GitHub projects with EAS. We can trigger builds for any build profile based on our development team's preferences. It also allows triggering builds for `git` push committed directly to a repository or a pull request.
In this chapter, we'll configure this functionality. We already have a GitHub repository for our example app to demonstrate this.
Video Tutorial: [Watch: How to trigger builds from a GitHub repository](https://www.youtube.com/watch?v=fBLFEFC0ip0)
---
Step 1: 
## Configure Expo GitHub app
To use this functionality, we need to connect our GitHub account:
- In the EAS dashboard, go to [expo.dev/settings](https://expo.dev/settings#connections), and under **Connections** > **GitHub**, click **Connect**. This opens the **Connect GitHub** accounts page.
- Click the **Get started** button which opens a popup to authorize the Expo GitHub app. Click **Install and Authorize**.
- Once the app is installed on our GitHub account, we need to link it to our Expo account. In the next popup, click **Link installation**.
- Once the account is linked, it will show under **GitHub**.
Step 2: 
## Connect the GitHub repository
To enable triggering builds from a GitHub repository, we need to connect it to our project in the EAS dashboard:
- In EAS dashboard, go to **Projects** > Select your project > **Project settings** > **GitHub**.
- Under **Connect a GitHub repository**, we'll see a list of our GitHub repos. We need to connect the right one. In the example, we're searching for our repo **sticker-smash.**
- Click **Connect** for the project repository.
Step 3: 
## Use default repository settings
The Expo GitHub app needs to know where to find the source code of our project. By default, it selects the root directory using `/`. In our example project, the source code is also available in the root repository. We can leave this to default in the EAS dashboard.
Step 4: 
## Trigger a build using a GitHub PR label
The Expo GitHub app provides us [multiple options](/build/building-from-github/#trigger-a-build-from-github) to trigger a build, such as:
- Manually from the Builds page for a specific platform
- Automatically when new code is pushed to the repository
- Automatically using GitHub PR labels
To automatically trigger a build using a GitHub PR label, we're going to utilize the third option from the list above:
- We need to specify the build image that we will be using. Open **eas.json**, and under the `development` profile, add [`android.image`](/eas/json/#image) and [`ios.image`](/eas/json/#image-1) properties and set their value to [`latest`](/build-reference/infrastructure/#configuring-build-environment).
  ```json eas.json
  {
    "build": {
      "development": {
        "android": {
          "image": "latest"
        },
        "ios": {
          "image": "latest"
        }
      }
    }
  }
  ```
- Next, let's create a new branch called `dev`, and make a change in our app's JavaScript code. Then, commit the change, push the branch, and create a PR from that branch.
- In the PR link, under **Labels**, create a label called `eas-build-all:development`.
- Click **Create pull request** button to create the PR. The Expo GitHub app will start the process of creating a development build.
- In the EAS dashboard, on the **Builds** page, we can verify that the builds for both Android and iOS are triggered.
- If we check the details of an individual build, we can see under **Created by** that the build is created by the GitHub app.
## Summary
<ProgressTracker
  currentChapterIndex={10}
  name="EAS_TUTORIAL"
  summary="We successfully linked our GitHub account with Expo, connected our repository to our EAS project, and learned about automated development build creation using GitHub PR labels."
  nextChapterDescription="Learn about the next steps to use EAS."
  nextChapterTitle="Next steps in your journey with EAS"
  nextChapterLink="/tutorial/eas/next-steps/"
/>


## Next steps

Learn about the next steps in your journey with EAS.

Congratulations! You've completed the EAS tutorial and learned about the main features. Now, you have a working [EAS project](https://expo.dev/eas).
## EAS
But this is just the beginning. Here are some next steps to continue your journey with EAS:
  }
  href="/eas-insights/introduction/"
/>
## eas.json reference
## Custom builds
## Relevant guides
We hope you enjoyed this course. If you have any questions or feedback, don't hesitate to reach out to us on [Discord](https://chat.expo.dev/), or share your experience on [X](https://x.com/expo).


# More

## Additional resources

## Guides: Overview

This section contains information about the development with Expo and Expo Application Services (EAS):
### <span className="inline-flex items-center gap-2"><CodeSquare01Icon />Development process</span
Learn about the process of [building an app with Expo](/workflow/overview/) to help understand the mental model of the core development loop. This section also dives into additional configurations and workflows you may require during the development process to help you develop, deploy, and maintain your app. It contains in-depth information about [app config](/workflow/configuration/), [permissions](/guides/permissions/), [universal links](/linking/into-your-app/), [custom native code](/workflow/continuous-native-generation/), [web](/workflow/web/), and more.
### <span className="inline-flex items-center gap-2"><RouterLogo />Expo Router</span
Learn about using different navigation functionalities from the [Expo Router](/router/basics/layout/#root-layout) library. It also covers a comprehensive [Hooks API](/router/reference/hooks/) that the library provides and other aspects of navigation such as [Authentication](/router/reference/authentication/), [Redirects](/router/reference/redirects/), [Testing](/router/reference/testing/), and more.
### <span className="inline-flex items-center gap-2"><CpuChip01Icon />Expo Modules API</span
Learn how to add and use native modules in your app using [Expo Modules API](/modules/overview/).
### <span className="inline-flex items-center gap-2"><GraduationHat02DuotoneIcon />Tutorials</span
If you're looking for step-by-step tutorials for Expo and EAS, see the [Tutorial section](/tutorial/overview/) which includes comprehensive tutorials for both [building apps with Expo](/tutorial/introduction/) and [using EAS services](/tutorial/eas/introduction/).
### Other content
Apart from the essentials listed above, there are plenty of other features to explore such as [Push notifications](/push-notifications/overview/). We also have a collection of guides in the **Assorted** and third-party **Integrations** sections.


# Development process

## Develop an app with Expo

An overview of the development process of building an Expo app to help build a mental model of the core development loop.

If you're new to Expo and React Native or you've been around the ecosystem for a while, this document will be useful to help you to better understand the development process of building an Expo app. It will help you build a mental model of the core development loop and how Expo tools fit into it.
## Key concepts
The following concepts are valuable to understand, and we recommend referring back to these definitions as you read through the rest of this guide and also as you use Expo tools.
<Collapsible summary={`What is an "Expo app"?`}>
This is a shorthand term we use for describing a _React Native app that uses Expo tools_. An "Expo app" can use a single package from the Expo SDK, or Expo Router, or Expo CLI, or Continuous Native Generation, a combination of them, or any other Expo tools.
We say "Expo app" because _React Native app that uses Expo tools_ is incredibly inconvenient to frequently type and speak out loud.
<Collapsible summary={<>Is the development process different for an "Expo app" and a "React Native app that does <span><i>not</i></span> use Expo tools"?</>}>
Expo provides a variety of tools and services that can be adopted independently, so the answer depends on which tools you choose to use. For most of what Expo provides, there is no React Native tooling provided by Meta that is comparable.
---
---
<Collapsible summary={`What is the difference between "Expo" and "Expo Application Services (EAS)"?`}>
Expo is an open-source project that gives developers powerful tools to assist in building and maintaining React Native apps at any scale. For example, Expo CLI, Expo Router, and Expo SDK packages. All Expo open-source tools are entirely free to use and carry the MIT license.
Expo Application Services (EAS) is a suite of hosted services that you can use with Expo and React Native projects to:
- Build, submit, and update your app
- Set up automation around all of these processes
- Collaborate with your team
EAS solves a set of problems that require physical resources, such as application servers and CDNs for serving over-the-air updates and physical servers for running builds. EAS has a generous [free plan](https://expo.dev/pricing#get-started) that will work for many student and hobby projects.
You don't have to use GitHub to use git, but it certainly helps for many cases. The same goes for EAS and Expo.
Note: Do I have to use EAS if I use Expo open source tools?
---
Nope! Your Expo project is just a React Native app, which is just a native app. You can use Fastlane or any native build, update, and more, tools you like.
Most EAS services also allow you to run them on your own infrastructure, and we provide instructions for how you can accomplish this. For example, [self-hosting updates](/versions/latest/sdk/updates/) (rather than using EAS Update), or [running builds locally](/guides/local-app-development/) or on [your own CI](build/building-on-ci/) (rather than using our EAS Build worker fleet).
For most teams, it makes sense to use EAS rather than spending the engineering time and resources on acquiring, setting up, and maintaining the services on other infrastructure. Additionally, EAS provides deep integration between services, such as the deployments page for monitoring app version adoption, assigning updates to specific builds, and rolling those updates out incrementally &mdash; which ties back into monitoring with [EAS Insights](/eas-insights/introduction/).
---
Note: Can I use EAS if I'm not using any Expo open source tools?
---
Yes! We think EAS is a great fit for any React Native project.
---
---
Note: Expo Go: an optional tool for learning, experimenting, and prototyping
---
There's no faster way to spin up a React Native project and run it on your device or emulator than [Expo Go](https://expo.dev/go), especially when combined with [Snack](https://snack.expo.dev/).
However, **Expo Go and Snack are not intended for building production apps**. They are great when you're getting started on a project or for prototypes. **If you plan on deploying your app to the store, then [development builds](#development-builds) will provide a more flexible, reliable, and complete development environment.** This guide does not go into any detail about Expo Go, and this is the only section that mentions it.
---
Note: Development builds
---
A development build is a debug build of your app that contains `expo-dev-client` library. It helps you iterate as quickly as possible and provides a more flexible, reliable, and complete development environment than Expo Go. You can install any native library and configure or apply changes to a [native project](#android-and-ios-native-projects) using [app config](/workflow/configuration/) or by creating a [config plugin](/config-plugins/introduction/). You can create a development build [locally](/guides/local-app-development/#local-builds-with-expo-dev-client) or use [EAS Build](/develop/development-builds/create-a-build/) to create a build in the cloud.
---
Note: Android and iOS native projects
---
React Native apps for mobile platforms are made of two interconnected parts:
Note: 1. The app JavaScript
---
This contains your React components and most, if not all, of your application logic. It has more or less the same role as the app JavaScript on React websites.
---
Note: 2. The native projects
---
Android and Xcode projects that bundle the JavaScript app, serve as the launchpad for the JavaScript app on each platform. They also handle the rendering of native components and provide the means to access platform-specific functionalities and integrate with any installed native libraries. App configuration, such as the name (as it appears on the home screen), icon, required permissions, associated domains, supported orientations, and so on, is configured in the native project.
---
Like any mobile app, the application that is distributed to users is created by compiling ("building") the Android Studio or Xcode project.
When you initialize a new app with `npx create-expo-app`, you will not see any **android** or **ios** directories. You can [generate the native projects by running `npx expo prebuild`](/workflow/prebuild/), which will initialize the native projects and then apply the project Expo app config (**app.json/app.config.js**) to them.
If you use a cloud-based development workflow, you may never need to run prebuild or install Android Studio or Xcode on your own machine (although you may find this useful). This is explained below in the [Local and cloud-based development workflows](#cloud-based-and-local-development-workflows).
<Collapsible summary={`Why aren't the native projects created by default when you initialize a project with create-expo-app?`}>
The default behavior encourages the use of [Continuous Native Generation](/workflow/continuous-native-generation/) (CNG) to generate the native projects when needed, which can make upgrades and project maintenance significantly easier.
The following three commands result in more or less the same project:
```sh
$ npx create-expo-app MyApp && cd MyApp && npx expo prebuild
$ npx create-expo-app --template bare-minimum
$ npx @react-native-community/cli@latest init MyApp && cd MyApp && npx install-expo-modules
```
---
---
Note: Continuous Native Generation (CNG)
---
Continuous Native Generation (CNG) is a process for building an Expo app where your [native projects](#android-and-ios-native-projects) are generated on-demand from your **app.json** and **package.json**, similar to how your **node_modules** are generated from your **package.json**.
The [native project](#android-and-ios-native-projects) directories (**android** and **ios**) are automatically added to your **.gitignore** when you create a new project, and you can delete them at any time, then re-generate them from the Expo app config with `npx expo prebuild` whenever required. You might never even run prebuild on your own development machine if you use a cloud-based development workflow.
Using CNG can make upgrading to new versions of React Native much easier. It can simplify project maintenance and facilitate setting up complex features such as [App Clips](https://github.com/bndkt/react-native-app-clip), [share extensions](https://github.com/timedtext/expo-config-plugin-ios-share-extension), and [error reporting](https://github.com/getsentry/sentry-react-native). This is all made possible with [config plugins](/config-plugins/introduction/). Learn more about [CNG](/workflow/continuous-native-generation/).
Note: What if I want to edit the native project configuration in Android Studio or Xcode rather than generating the projects with prebuild?
---
CNG has proven to be helpful to many teams. However, it may not be the best fit for your project and this is a perfectly reasonable way to use Expo tools in many cases.
You can run `npx expo prebuild` in the project and then make changes directly to the **android** and **ios** directories, instead of using Expo app config. If you decide to do this, then keep in mind that you won't be able to re-generate your projects using prebuild any longer &mdash; running prebuild after making native changes directly will overwrite all of those modifications.
Note that you can use [config plugins](/config-plugins/introduction/) to modify the native project configuration without having to modify the native projects directly, and if you decide to move back to CNG at some point.
---
Note: How do I know when I need to run prebuild again?
---
If you add a new native dependency to your project or change the project configuration in Expo app config (**app.json/app.config.js**), you can run `npx expo prebuild --clean` to re-generate the native project directories.
See [Determining third-party library compatibility](/workflow/using-libraries/#determining-third-party-library-compatibility) for more information on how to determine if a new dependency requires native code changes.
---
---
Note: Cloud-based and local development workflows
---
Whether you choose cloud-based or local doesn't significantly alter your development loop. It's about how you produce and distribute your app binaries that your JavaScript code runs against. Choosing a cloud-based or local development is a choice you can make each time you run a new native build.
Compiling your app in the cloud with EAS Build is as easy as running a single command, no need to install Android Studio or Xcode. Cloud builds make it easier to share your app with other teammates or stakeholders, [among other benefits](/build/introduction/).
To compile your app locally, you will need to install Android Studio and Xcode on your machine, and then you can either run the build from those tools or use `npx expo run:[android|ios]`. This is most useful when you want to debug your app on a physical device or emulator/simulator using the native debugging tools.
Learn more about [cloud-based workflows with EAS Build](/build/introduction/) and [local development](/guides/local-app-development/).
---
## Initialize and run a project
The easiest way to [create a new project is with `create-expo-app`](/get-started/create-a-project/). After creating your project, you can immediately launch it directly in Expo Go on your physical device or in an emulator/simulator if you want to experiment or build a quick prototype.
In most cases, you will create and use a development build of your project. You will install the [`expo-dev-client`](/develop/development-builds/introduction/#what-is-expo-dev-client) library. Development builds can be created with EAS Build or locally on your machine:
## The core development loop
The core development loop described in the diagram above is a cycle of four main activities that you typically go through when developing an app.
- #### Write and run JavaScript code
  This involves creating components, writing business logic, or installing libraries from npm that don't require native
  code changes. The changes you make here are reflected in your app without needing any interaction
  with the native side of your app.
- #### Update app configuration
  This involves modifying your app's
  configuration using the app config file (**app.json** or **app.config.js**). It includes updating
  your app's name, icon, splash screen, and other properties. These changes don't all affect the
  native project directly. However, if you make changes that affect the native projects, you can use
  the [app config](/workflow/configuration/) to modify the native project configuration or create or
  use a [config plugin](/config-plugins/introduction/). See [app config
  reference](/versions/latest/config/app/) for a complete list of properties available in the app
  config file.
- #### Write native code or modify native project configuration
  This includes writing native code directly or modifying native code configuration. You either need
  access to the native code project directories to make these changes, or you can write native code
  with a [local Expo Module](/modules/get-started/#adding-a-new-module-to-an-existing-application).
- #### Install a library that requires native code modifications
  This includes that a library requires making changes to the native code project configuration. Either
  the library provides a config plugin or steps to take to update the app config. Like the previous
  activity, this also requires you to create a development build.
When creating a [development build](#development-builds), you have two options. You can create a cloud-based build using [EAS Build](/build/setup/) or do it locally. If you choose to do it locally, you can use [CNG](#continuous-native-generation-cng) and then [`npx expo prebuild --clean`](#how-do-i-know-when-i-need), or you can create a development build using [`npx expo run android|ios` or Android Studio and Xcode](/guides/local-app-development/#local-app-compilation).
> **Note**: When creating a development build locally, the `npx expo run` commands will generate native directories before building your app. If you modify your project's configuration or native code after the first build, you will have to rebuild your project. Running `npx expo prebuild` again layers the changes on the top of existing files. It may also produce different results after the build. To avoid this, add native directories to the project's **.gitignore** and use `npx expo prebuild --clean` command.
During your app's development loop, you can also [install different variants (development, preview or production)](/build-reference/variants/) of your app on the same device.
Another key part of the development loop is debugging. See [Debugging runtime issues](/debugging/runtime-issues/) for more information about debugging your app and learn about different [debugging tools](/debugging/tools/) available.
## Share app with testers
The next step to developing an app is to share your app with your team, with beta testers, or run it on multiple test devices. A traditional approach is to upload your app's binary to the Google Play Beta (Android) or TestFlight (iOS). This can be a time-consuming effort and is limited to only one active build at a time (for example, in the case of TestFlight).
If you are using EAS Build, we recommend going through [Internal distribution](/build/internal-distribution/) to learn more about sharing your app for testing.
If you compile your app locally, you can create [production builds locally](/guides/local-app-production/).
## Release app to stores
To release your app on the app stores, you can use [EAS Submit](/submit/introduction/). For more information on using EAS Submit, see [Submit to Google Play Store](/submit/android/) and [Submit to Apple App Store](/submit/ios/).
To create a production build locally, see the [guide](/guides/local-app-production/) on the same and then go through the app stores guide to submit your app.
## Monitor app in production
Two ways to monitor your production app are crash reports and analytics. Crash reports help you learn about exceptions or errors that your users run into while using your app. You can use [Sentry](/guides/using-sentry/) or [BugSnag](https://docs.bugsnag.com/platforms/react-native/expo/) to enable crash reports.
Analytics allows you to track how users interact with your app. See [analytics overview](/guides/using-analytics/) to learn more about the services available in the Expo and React Native ecosystem.
## Update the app
The `expo-updates` library allows you to programmatically make instant updates to your app's JavaScript available to your production app.
You can use [EAS Update](/eas-update/introduction/) which provides first-class support for instant updates in a React Native app. It serves updates from the edge of a global CDN and uses modern networking protocols such as HTTP/3 for clients that support them. It is also [tailored for developers](/eas-update/develop-faster/) who use EAS Build. You can also use it for builds you have created [locally](/eas-update/standalone-service/).


## Configure with app config

Learn about what app.json/app.config.js/app.config.ts files are and how you can customize and use them dynamically.

<PossibleRedirectNotification newUrl="/versions/latest/config/app/" />
The app config (**app.json**, **app.config.js**, **app.config.ts**) is used for configuring [Expo Prebuild](/workflow/prebuild) generation, how a project loads in [Expo Go](/get-started/expo-go/), and the OTA update manifest.
It must be located at the root of your project, next to the **package.json**. Here is a minimal example:
```json app.json
{
  "name": "My app",
  "slug": "my-app"
}
```
If your Expo config has a top-level `expo: {}` object, then this will be used in place of the root object and all other keys will be ignored.
## Properties
The app config configures many things such as app name, icon, splash screen, deep linking scheme, API keys to use for some services and so on. For a complete list of available properties, see [app.json/app.config.js/app.config.ts reference](/versions/latest/config/app/).
> **info** Do you use Visual Studio Code? If so, we recommend that you install the [Expo Tools](https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-tools) extension to get auto-completion of properties in **app.json** files.
## Reading configuration values in your app
Most configuration in the app config is accessible at runtime from your JavaScript code, using [`Constants.expoConfig`](/versions/latest/sdk/constants/#nativeconstants--properties). You **should not** include any sensitive information in the app config (with a few exceptions for fields that are filtered out, as outlined below).
You can verify which configuration will be embedded in your builds/updates and available at runtime by running `npx expo config --type public`.
Note: Which fields are filtered out of the public app config?
---
The following fields are filtered out of the public app config (and not accessible through the `Constants.expoConfig` object):
- [`hooks`](/versions/latest/config/app/#hooks)
- [`ios.config`](/versions/latest/config/app/#config)
- [`android.config`](/versions/latest/config/app/#config-1)
- [`updates.codeSigningCertificate`](/versions/latest/config/app/#codesigningcertificate)
- [`updates.codeSigningMetadata`](/versions/latest/config/app/#codesigningmetadata)
---
> **warning** You should also avoid importing **app.json** or **app.config.js** directly in your JavaScript code, because this will import the entire file rather than a processed version of it. Instead, use [`Constants.expoConfig`](/versions/latest/sdk/constants/#nativeconstants--properties) to access the configuration.
## Extending configuration
Library authors can extend the app config by using [Expo Config plugins](/config-plugins/introduction/).
> **info** Config plugins are mostly used to configure the [`npx expo prebuild`](/workflow/prebuild) command.
## Dynamic configuration
For more customization, you can use the JavaScript (**app.config.js**) or [TypeScript](#using-typescript-for-configuration-appconfigts-instead-of-appconfigjs) (**app.config.ts**). These configs have the following properties:
- Comments, variables, and single quotes.
- ESM import syntax (the `import` keyword) is not supported, except when using [TypeScript with `tsx`](/guides/typescript/#appconfigjs). JS files that are compatible with your current version of Node.js can be imported with `require()`.
- TypeScript support with nullish coalescing and optional chaining.
- Updated whenever Metro bundler reloads.
- Provide environment information to your app.
- Does not support Promises.
For example, you can export an object to define your custom config:
```js app.config.js
const myValue = 'My App';
module.exports = {
  name: myValue,
  version: process.env.MY_CUSTOM_PROJECT_VERSION || '1.0.0',
  // All values in extra will be passed to your app.
  extra: {
    fact: 'kittens are cool',
  },
};
```
The `"extra"` key allows passing arbitrary configuration data to your app. The value of this key is accessed using [`expo-constants`](/versions/latest/sdk/constants/):
```js App.js
import Constants from 'expo-constants';
Constants.expoConfig.extra.fact === 'kittens are cool';
```
You can access and modify incoming config values by exporting a function that returns an object. This is useful if your project also has an **app.json**. By default, Expo CLI will read the **app.json** first and send the normalized results to the **app.config.js**.
For example, your **app.json** could look like this:
```json app.json
{
  "name": "My App"
}
```
And in your **app.config.js**, you are provided with that configuration in the arguments to the exported function:
```js app.config.js
module.exports = ({ config }) => {
  console.log(config.name); // prints 'My App'
  return {
    ...config,
  };
};
```
### Switching configuration based on the environment
It's common to have some different configuration in development, staging, and production environments, or to swap out configuration entirely to white label an app. To accomplish this, you can use **app.config.js** along with environment variables.
```js app.config.js
module.exports = () => {
  if (process.env.MY_ENVIRONMENT === 'production') {
    return {
      /* your production config */
    };
  } else {
    return {
      /* your development config */
    };
  }
};
```
To use this configuration with Expo CLI commands, set the environment variable either for specific commands or in your shell profile. To set environment variables for specific commands, prefix the command with the variables and values as shown in the example:
```sh
$ MY_ENVIRONMENT=production eas update
```
This is not anything unique to Expo CLI. On Windows you can approximate the above command with:
```sh
$ npx cross-env MY_ENVIRONMENT=production eas update
```
Or you can use any other mechanism that you are comfortable with for environment variables.
### Using TypeScript for configuration: app.config.ts instead of app.config.js
You can use autocomplete and doc-blocks with an Expo config in TypeScript. Create an **app.config.ts** with the following contents:
```ts app.config.ts
import { ExpoConfig, ConfigContext } from 'expo/config';
export default ({ config }: ConfigContext): ExpoConfig => ({
  ...config,
  slug: 'my-app',
  name: 'My App',
});
```
To import other TypeScript files into **app.config.ts** or customize the language features, we recommend using [`tsx`](/guides/typescript/#appconfigjs). `tsx` also enables using `import` syntax in any file imported by **app.config.ts**. This means you can write local [config plugins](/config-plugins/introduction/) in TypeScript with full language features.
### Configuration resolution rules
There are two different types of configs: static (**app.config.json**, **app.json**), and dynamic (**app.config.js**, **app.config.ts**). Static configs can be automatically updated with CLI tools, whereas dynamic configs must be manually updated by the developer.
1. The static config is read if **app.config.json** exists (falls back to **app.json**). If no static config exists, then default values are inferred from the **package.json** and your dependencies.
2. The dynamic config is read if either **app.config.ts** or **app.config.js** exist. If both exist, then the TypeScript config is used.
3. If the dynamic config returns a function, then the static config is passed to the function with `({ config }) => ({})`. This function can then mutate the static config values. Think of this like middleware for the static config.
4. The return value from the dynamic config is used as the final config. It cannot have any promises.
5. All functions in the config are evaluated and serialized before any tool in the Expo ecosystem uses it. The config must be a JSON manifest when it is hosted.
6. If the final config object has a top-level `expo: {}` object, then this will be used in place of the root object and all other keys will be ignored.
Running `npx expo config` will display the final configuration that will be used in Expo CLI after resolution has occurred.


## Continuous Native Generation (CNG)

Learn about managing your native projects with Continuous Native Generation (CNG) and Prebuild.

A single native project on its own is complicated to maintain, scale, and update. In a cross-platform app, you have multiple native projects that you must maintain and keep up to date with the latest operating system releases to avoid falling too far behind in any third-party dependencies.
As your native project grows, the complexity from third-party dependencies increases, complicating upgrades and slowing down developer momentum. This discourages adding advanced native functionality and leads to less powerful apps. In cross-platform apps, this complexity is multiplied across each platform.
To address this, we've introduced the concept of **Continuous Native Generation**. Instead of creating native projects a single time and maintaining customizations to those native projects for the lifetime of the codebase, short-lived native projects are generated only when needed, such as when debugging or building. These projects are generated from a standard template plus configuration or custom code that defines how the template should be customized. The result is a native project that can be compiled into a native app with any customizations desired by the developer. However, the developer is responsible for only maintaining the definition of their customizations, rather than all of the native project code.
## CNG in React Native apps
React Native apps can use **CNG** by using [Prebuild](#usage) to automate upgrades, install or uninstall libraries, apply white label customizations, share configuration across multiple apps, reduce [orphaned code](#how-does-prebuild-help-with-orphaned-code), and more.
**Expo as a framework** enables CNG by combining the following tools:
1. The [app config](/workflow/configuration/) file.
2. Arguments passed to the `npx expo prebuild` command.
3. Version of `expo` that's installed in the project and corresponding [prebuild template](https://github.com/expo/expo/tree/main/templates/expo-template-bare-minimum).
4. [Autolinking](/more/glossary-of-terms#autolinking), for linking [native modules](/more/glossary-of-terms/#native-module) found in the **package.json**.
5. Native subscribers, for reducing native code side-effects in entry point files, such as **MainApplication** or **AppDelegate**.
6. EAS Credentials for code signing additional targets and entitlements.
The end result is a workflow where a developer can express any native application with the app config and generate that project continuously &mdash; by running `npx expo prebuild`.
## Usage
Prebuild can be used by running:
```sh
$ npx expo prebuild
```
This creates the **android** and **ios** directories for running your React code. If you modify the generated directories manually then you risk losing your changes the next time you run `npx expo prebuild --clean`. Instead, use [config plugins](/config-plugins/introduction/) , which are functions that perform modifications on native projects during prebuild.
We highly recommend using Prebuild for the reasons listed in the [common questions](#prebuild) section, but the system is [fully optional](#optionality), and you can stop using it at any time.
### Usage with EAS Build
If your project does not contain **android** and **ios** directories, EAS Build will run Prebuild to generate these native directories before compilation. This is the default behavior for any project created using `npx create-expo-app`.
For a project that has **android** and **ios** directories, EAS Build will not run Prebuild to avoid overwriting any changes you've made to the native directories.
If you troubleshoot your app by [compiling it locally](/guides/local-app-development/#local-app-compilation) (running `npx expo prebuild`, or `npx expo run:android` or `npx expo run:ios`), you can still use Prebuild with EAS Build to generate fresh native directories during the build process. The **android** and **ios** directories are automatically added to **.gitignore** when you create a new project, but if you need to add them manually, you can add them to **.gitignore** or [**.easignore**](/build-reference/easignore/) files:
```diff
diff --git a/.gitignore b/.gitignore
--- a/.gitignore
+++ b/.gitignore
@@ -0,0 +1,2 @@
+/android
+/ios
```
### Usage with Expo CLI run commands
You can perform a native build locally by running:
```sh
$ npx expo run:android
$ npx expo run:ios
```
If native directories are absent, `npx expo prebuild` will run once for the specific platform. On subsequent uses of these `run` commands, manually run `npx expo prebuild --clean` to ensure the native code is freshly synchronized with your local configuration.
## Platform support
Prebuild currently supports Android and iOS. Web support is not required because there is no native project to generate for the web and the web app it runs in a web browser. Use the `--platform` option to run prebuild for individual platforms:
```sh
$ npx expo prebuild --platform ios
```
## Dependencies
Prebuild begins by initializing new native projects from a template corresponding to each Expo SDK version. This also aligns with specific React and React Native versions. You will see a warning when running `npx expo prebuild` when your project's React and React Native versions differ from the expected versions from specified in the `dependencies` field of the [template's **package.json**](https://github.com/expo/expo/tree/main/templates/expo-template-bare-minimum) if they differ.
You can skip changing npm package versions with the `--skip-dependency-update` option:
```sh
$ npx expo prebuild --skip-dependency-update react-native
react
```
## Package managers
When the [dependencies](#dependencies) are changed, Prebuild will reinstall libraries using the package manager that is currently used in the project (this is inferred from the lockfile). You can force a specific package manager by providing one of: `--npm`, `--yarn`, `--pnpm`.
All installations can be skipped by passing the `--no-install` command, which is useful for testing generation quickly.
## Clean
The `--clean` option deletes any existing native directories before generating. Re-running `npx expo prebuild` without the `--clean` option will layer changes on top of the existing files, which is faster, but may not produce the same results in some cases.
For example, some config plugins aren't idempotent. When a project utilizes multiple "dangerous modifiers" to add regex changes to an app's code, it can lead to unexpected behavior. This is why using the `--clean` option is the safest way to use the prebuild command and is generally recommended in most cases.
#### Using `--clean` option
When using the `--clean` option, you'll be warned if you have any uncommitted changes to your git code repository, as this option will delete and recreate all of your native project files. This prompt is optional and will be skipped when encountered in CI. You can disable this check by enabling the environment variable `EXPO_NO_GIT_STATUS=1`.
There are cases where developers may want to swap between workflows often. For example, you may want to build custom functionality natively in Android Studio and Xcode, and then move that functionality into local config plugins.
## Templates
You can customize how the native directories are generated by [config plugins](/config-plugins/introduction). Many config plugins already exist for lots of modifications, and community libraries often ship their own as well. You can [see a list of some popular plugins](https://github.com/expo/config-plugins) for more information.
Prebuild starts from template files, which are then modified with config plugins. The template files are based on the Expo SDK version and come from the npm package [`expo-template-bare-minimum`](https://github.com/expo/expo/tree/main/templates/expo-template-bare-minimum). You can change the template used by passing `--template /path/to/template.tgz` to the `npx expo prebuild` command. This is not generally recommended because the base modifiers in `@expo/prebuild-config` make some undocumented assumptions about the template files, so it may be tricky to maintain your custom template.
> **Note:** In network environments where all packages are downloaded from a private registry and npm public registry access is blocked, a locally-available template must be passed to the prebuild command. [Learn more about using a local version of the default template](https://expo.fyi/prebuild-without-npm-access).
## Side effects
`npx expo prebuild` performs several side effects outside of generating the **android** and **ios** directories. Work is in progress to eliminate these side effects &mdash; ideally, running `npx expo prebuild` would generate the Android and iOS projects and leave the rest of the project untouched.
In addition to generating the native directories, prebuild also makes the following modifications:
- Modifies the `scripts` field in the **package.json** to replace `expo start --android` and `expo start --ios` with `expo run:android` and `expo run:ios`
- Modifies the `dependencies` field in the **package.json**
The convenience change to the `scripts` field is the only side effect that alters how a developer works on their app before/after prebuild. All other changes can be left in place and committed to git to minimize the diff when running prebuild.
## Optionality
Prebuild is optional and works seamlessly with all Expo tools and services. For existing React Native projects, where the native projects are managed manually, do not use `npx expo prebuild`, as that may overwrite any manual customizations. Developers can continue to make ([direct changes to their native projects](/more/glossary-of-terms/#bare-workflow)) while adopting other Expo tools and workflows. Later on, they can move their manual customizations to app config and/or config plugins, and then adopt CNG.
Everything offered by Expo including [EAS](/eas/), Expo CLI, and the libraries in the Expo SDK are built to **fully support** bare React Native projects as this is a minimum requirement for supporting projects using `npx expo prebuild`. The only exception is the [Expo Go](https://expo.dev/go) app, which can load arbitrary React Native projects only if they include JavaScript fallbacks for native code absent in the Expo Go runtime.
## Common questions
### CNG
Note: How does CNG help with project upgrades?
---
React Native developers who don't use **Continuous Native Generation** have reported that upgrading their apps to the latest version of React Native is the number one weakness of the library as per [React Native Survey (2022)](https://results.2022.stateofreactnative.com/opinions/#opinions_pain_points).
When using CNG, the upgrade process simply involves upgrading the npm dependencies, app config, and re-running `npx expo prebuild --clean`.
---
Note: How a React Native library author can adopt CNG?
---
React Native library authors can adopt CNG in several ways. It depends on the complexity of their libraries. Here are a few scenarios:
- **No native code or configuration side-effects**: Libraries without native code or configuration side-effects, such as `react-native-blurhash`, can seamlessly integrate with `npx expo prebuild`. They can rely on Node Module Resolution without requiring any additional configuration.
- **Native code with no additional setup after install**: Libraries with native code can often be installed and linked automatically with [Expo Autolinking](/more/glossary-of-terms#autolinking), which runs before the native app is built.
- **Additional configuration side-effects and setup**: Libraries that require additional configuration side-effects can adopt CNG by creating [Expo config plugins](/config-plugins/introduction/) for their libraries. This approach enables library authors to automate adding values such as permission messages to the **Info.plist**, or injecting targets in the Xcode project.
- **Libraries Dependent on Native Runtime Hooks**: Libraries that depend on specific native runtime hooks, such as intercepting the initial launch URL via the `AppDelegate`, `MainActivity`, `MainApplication`, and so on, can utilize [**Lifecycle listeners**](/modules/android-lifecycle-listeners/) in the Expo Modules API. These lifecycle listeners allow these runtime hooks to be applied via Expo Autolinking instead of by modifying these standard native project files, eliminating the need for a config plugin.
Many complex libraries and services already support CNG via Expo Prebuild such as, [MapBox](https://github.com/rnmapbox/maps), [Sentry](https://github.com/getsentry/sentry-react-native), [Stripe](https://github.com/stripe/stripe-react-native), and [React Native Firebase](https://rnfirebase.io/#expo).
Adopting CNG by library authors is not a preqrequisite for using `npx expo prebuild`. If a library author has not adopted CNG, developers can still use `npx expo prebuild` by creating local [Config Plugins](https://github.com/expo/config-plugins/) to modify the native generation pipeline. This flexibility makes CNG accessible and beneficial to all developers within the React Native community.
---
Note: Is CNG limited to React Native projects?
---
No, CNG is a versatile pattern that can be applied to any native project. While Expo Prebuild is a tool that implements CNG specifically for React Native projects, the concept itself is not limited to this framework.
---
Note: How does community use CNG?
---
Here are a few community examples of difficult native features converted into simple configuration files, which have allowed developers to build more powerful apps without compromising on iteration speed:
- [iOS Safari Extensions](https://github.com/andrew-levy/react-native-safari-extension): Here, the process of creating a Safari Extension for iOS, which is a notoriously difficult feature to implement, is reduced to a few of lines of JSON.
- [iMessage Sticker App](https://github.com/expo/config-plugins/tree/main/packages/ios-stickers): This Expo config plugin can generate an entire iMessage Sticker App from a JSON object.
- [Cross-platform end-to-end testing](https://github.com/expo/config-plugins/tree/main/packages/detox): Configure native apps to support E2E testing with Detox in a single-line.
- [The entire Firebase suite](https://rnfirebase.io/): Here you can see the entire native Firebase suite going from a multi-step native configuration process across multiple IDEs, down to basic JSON configuration.
- [Cross-platform home screen widgets](https://github.com/gaishimo/eas-widget-example): This Expo config plugin can generate a home screen widget for Android and iOS.
- [Apple App Clips](https://github.com/bndkt/react-native-app-clip): This Expo config plugin takes the process of generating an Apple App Clip from a multi-step process, ranging across multiple targets, and reduces it to a single line `["react-native-app-clip", { "name": "My App Clip" }]`.
At any point, these features can be easily added and removed, without any side effects. CNG allows developers to experiment with complex features and iterate on them quickly without worrying about the long-term maintenance costs or potential orphaned code in their project.
---
Note: Can CNG be used for operating systems other than Android and iOS?
---
Absolutely! CNG is an abstract concept that can be applied to any operating system. Although Expo Prebuild officially implements CNG for Android and iOS, it also provides abstract platform support for developers to create implementations for additional platforms.
---
Note: Is using Expo a requirement for CNG?
---
Not at all. CNG is an open pattern that can be adopted by any community. We've defined the pattern abstractly to help other communities understand how they can adopt CNG for their own projects.
---
Note: How does CNG compare to web development patterns such as Static Site Generation (SSG)?
---
CNG shares similarities with SSG in that it generates a project from a set of inputs. However, CNG differs from SSG in its output. It generates native runtime code instead of static website code. This means the native project is generated on-demand, and the generated source code and configuration are discarded once the native project is compiled into a native app.
---
Note: Is it possible to use CNG with an existing brownfield project?
---
CNG is designed to manage the entire state of a native project continuously. As a result, it's not intended for use with existing brownfield projects. However, you can use CNG to generate a new native project, which can then be integrated into an existing brownfield project.
---
### Prebuild
Expo Prebuild streamlines CNG processing. Here are some issues in the React Native development cycle that are addressed by Prebuild:
Note: How can Prebuild help with sensible project upgrades?
---
Building native code requires familiarity with the platform's tooling, creating a steep learning curve. This challenge intensifies in cross-platform development due to multiple platforms. Cross-platform tooling doesn't help if you must implement many features in platform-specific native code.
When bootstrapping a native app, there's initial code and configuration that you may not understand. Yet you are not responsible for maintaining it. Eventually, you'll need to understand this code to upgrade your app safely. This challenge often leads developers to upgrade incorrectly or start a new app, copying existing source code.
**With Prebuild**, upgrading is much closer to upgrading a pure JavaScript application. Bump the versions in your **package.json**, regenerate the native project, and you should be ready to continue development.
---
Note: How does Prebuild simplify cross-platform configuration?
---
Cross-platform configurations such as the app icon, name, splash screen, and so on must be implemented manually in native code. These implementations are often quite different for each platform.
**With Prebuild** cross-platform configurations are handled at the config plugin level, and the developer only needs to set a single value like `"icon": "./icon.png"` to have all icon generation taken care of.
---
Note: How can I manage dependency side-effects with Prebuild?
---
Many complex native packages require additional setup beyond installing and [autolinking](/more/glossary-of-terms#autolinking). For example, a camera library requires permission settings to be added **AndroidManifest.xml** for Android and **Info.plist** for iOS. This additional setup can be considered a configuration side effect of a package. Pasting the required side effect code into your project's native files can lead to difficult native compilation errors, and it's also code that you now own and maintain.
**With Prebuild** library authors, who know how to configure their library better than anyone, can create a testable and versioned script called a [config plugin](/config-plugins/introduction/), to automate adding the required configuration side effects for their library. This means library side effects can be more expressive, powerful, and stable. For native code side effects, we also provide [Android Lifecycle Listeners](/modules/android-lifecycle-listeners) and [AppDelegate Subscribers](/modules/appdelegate-subscribers) which come standard in the default [prebuild template](#templates).
---
Note: How does Prebuild help with orphaned code?
---
When you uninstall a package, you have to be certain you removed all of the side effects required to make that package work. If you miss anything, it leads to orphaned code that you cannot trace back to any particular package, this code builds up and makes your project harder to understand and maintain.
**With Prebuild** the only side effect is the [config plugin](/config-plugins/introduction/) in a project's Expo config (**app.json**), which will throw an error when the corresponding node module has been uninstalled, meaning a lot less orphaned configuration.
---
Note: When Prebuild might not be the right fit for a project
---
Here are some reasons Expo Prebuild might **not** be the right fit for a particular project:
#### Platform compatibility
Prebuild can only be used for native platforms that are supported by the Expo SDK. This means Android and iOS for the time being. Except for web, which doesn't require `npx expo prebuild` since it uses the browser instead of a custom native runtime.
#### Making changes directly is quicker than modularizing and automating
All native changes must be added with native modules (using React Native's built-in Native Module APIs or the Expo Modules API) and config plugins. This means if you want to quickly add a native file to your project to experiment, then you may be better off running prebuild and adding the file manually, then working your way back into the system with a [monorepo](/guides/monorepos). We plan to speed this process up by adding functionality to [Expo Autolinking](/more/glossary-of-terms#expo-autolinking) that finds native project files outside of the native directories and links them before building.
If you want to modify the configuration, such as the **gradle.properties** file, you'll have to write a plugin ([example](https://github.com/expo/expo/blob/1c994bb042ad47fbf6878e3b5793d4545f2d1208/apps/native-component-list/app.config.js#L21-L28)). This can be easily automated with helper plugin libraries, however, it is a bit slower if you need to do it often.
#### Config plugin support in the community
Not all packages support _Expo Prebuild_ yet. If you find a library that requires extra setup after installation and doesn't yet have a config plugin, we recommend opening a pull request or an issue so that the maintainer is aware of the feature request.
Many packages, such as [`react-native-blurhash`](https://github.com/mrousavy/react-native-blurhash), don't require any additional native configuration beyond what is handled by [autolinking](/more/glossary-of-terms#autolinking) and so no config plugin is required.
Other packages, such as [`react-native-ble-plx`](https://github.com/Polidea/react-native-ble-plx), do require additional setup and therefore require a config plugin to be used with `npx expo prebuild` (in this case there's an external plugin called [`@config-plugins/react-native-ble-plx`](https://github.com/expo/config-plugins/tree/main/packages/react-native-ble-plx)).
Alternatively, we also have a repo for [out-of-tree config plugins](https://github.com/expo/config-plugins) which provides plugins for popular packages that haven't adopted the system yet. Think of this like [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) for TypeScript. We prefer packages ship their own config plugin, but if they haven't adopted the system yet, the community can use the packages listed in the repo.
---


## Using Expo SDK, React Native, and third-party libraries

Learn how to use Expo SDK, React Native libraries, and other third-party npm packages in your project.

Every app is inevitably going to use a third-party library, so it's important to understand how to determine whether a library is compatible with your project.
## React Native core libraries
React Native provides a set of built-in primitives that most developers will need in their apps. These include components such as `<ActivityIndicator>`, `<TextInput>`, `<Text>`, `<ScrollView>`, and `<View>`. These are listed at [Core Components and APIs](https://reactnative.dev/docs/components-and-apis) in React Native documentation. You can also view the [React Native version that corresponds to your Expo SDK version](/versions/latest).
To use a React Native component or API in your project, import it from the `react-native` package in your code:
<SnackInline>
```tsx
import { Text, View } from 'react-native';
export default function App() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text>Hello, world!</Text>
    </View>
  );
}
```
## Expo SDK libraries
The Expo SDK picks up where the React Native core libraries end. It provides access to a lot of device and system functionality such as audio, barcode scanning, camera, calendar, contacts, video, and so on. It also adds other powerful libraries like updates, maps, OAuth authentication tools, and more. For more information, see how we decide [what goes into the Expo SDK](https://expo.fyi/whats-in-the-sdk).
To use a library from the Expo SDK, find the one you are looking for in the [API reference](/versions/latest/) or use the documentation search.
<ConfigReactNative>
If you initialized your app using `npx @react-native-community/cli@latest init` and you don't have the `expo` package installed in it yet, see the [installing Expo modules guide](/bare/installing-expo-modules) for more information.
</ConfigReactNative>
You will see the platform compatibility tags at the top of each API reference. It tells you which platforms and environments the library is compatible with. For example, the platform tags for the [`expo-device`](/versions/latest/sdk/device/) library look like the following:
After the platform compatibility table, there is a library's description and a section with instructions on installing the library. For example:
<InstallSection packageName="expo-device" hideBareInstructions />
The `npx expo install` command picks a library version compatible with your project and then uses your JavaScript package manager (such as npm) to install it.
Next, a typical API reference includes:
- Config plugin usage information if the library requires a config plugin.
- A code example that shows how to use the library.
- API section that lists how to import the library, followed by a list of hooks, props, types, methods, and classes that the library provides.
> **Note**: If you use TypeScript, you can see the information included in the API section in your TypeScript-compatible code editor (such as VS Code) with auto-completion.
## Third-party libraries
### Finding a third-party library
[React Native Directory](https://reactnative.directory) is a searchable database of libraries built specifically for React Native. If the library that you are looking for is not provided by React Native or the Expo SDK then this is the best place to look first when trying to find a library for your app.
After the React Native Directory, the [npm registry](https://www.npmjs.com/) is the next best place. The npm registry is the definitive source for JavaScript libraries, but the libraries that it lists may not all be compatible with React Native. React Native is one of many JavaScript programming environments, including Node.js, web browsers, Electron, and more, and npm includes libraries that work for all of these environments. Any library that is compatible with React Native is compatible with the Expo project when you create a [development build](/workflow/overview/#development-builds). However, it may not be compatible with the [Expo Go](https://expo.dev/go) app.
### Determining third-party library compatibility
Use Expo [development builds](/workflow/overview/#development-builds) for building production-quality apps. It includes all of the native code that your project needs to run. This is a great way to test your app before you publish it to the App Store or Google Play. You can also include libraries that require native projects (**android** and **ios** directories) configuration.
The Expo Go app is an optional stepping stone toward development builds. You can use it to quickly test your app while you are developing it, but it does not include all of the native code required to support every library. You can check **React Native Directory** to find a library compatible with Expo Go by visiting the website and verifying that it has a "✔️ Expo Go" tag. You can also enable the [filter by Expo Go](https://reactnative.directory/?expoGo=true).
To determine if a new dependency changes native project directories, you can check the following:
- Does the library includes **android** or **ios** directories?
- Does the library's README mention linking?
- Does the library requires you to change **android/app/src/main/AndroidManifest.xml** or **ios/Podfile** or **ios/Info.plist** to change the project configuration?
- Does the library have a [config plugin](/config-plugins/introduction/)?
**If you answered yes to any of these questions,** then you should [create a development build](/develop/development-builds/introduction/) to use the library in your project.
**Not listed on the directory?** You can find the project on GitHub. A simple way to do this is with `npx npm-home --github <package-name>`. For example, to open the GitHub page for `react-native-localize`, run:
```sh
$ npx npm-home --github react-native-localize
```
> If you want some help determining library compatibility, [create an issue on the React Native Directory repository](https://github.com/react-native-community/directory/issues/new/choose) and let us know. This will not just help you, it will also help other developers have an easy answer in the future!
### Installing a third-party library
> We recommend always using `npx expo install` instead of `npm install` or `yarn add` directly because it allows [Expo CLI](/more/expo-cli/) to pick a compatible version of a library when possible and also warn you about known incompatibilities.
Once you have determined if the library is compatible with React Native, use [Expo CLI](/more/expo-cli/) to install the package:
```sh
$ npx expo install @react-navigation/native
```
Be sure to follow the project website or README for any additional configuration and usage instructions. You can get to the README quickly using this command:
```sh
$ npx npm-home @react-navigation/native
```
If the module needs additional native configuration, you can do so using [config plugins](/config-plugins/introduction/). Some packages require a config plugin but they don't have one yet, you can refer to the list of [out-of-tree config plugins](https://github.com/expo/config-plugins/).
<ConfigReactNative>
If your project does not support [Expo Prebuild](/workflow/prebuild) then you won't be able to use [config plugins](/config-plugins/introduction/). You can either [adopt Expo Prebuild](/guides/adopting-prebuild) or set up and configure each library manually by following any additional setup guides from the respective module's website or README.
</ConfigReactNative>
If the module is not supported in [Expo Go](https://expo.dev/go), you can create a [development build](/develop/development-builds/introduction/):
### Excluding a third-party library from version checks
If you have a specific version of a third-party library installed and want it to be excluded from version checks performed by `npx expo install`, `npx expo-doctor`, or `npx expo start`, use the [`expo.install.exclude`](/versions/latest/config/package-json/#exclude) property in the **package.json** file.


## Privacy manifests

Learn about configuring iOS privacy manifests for your mobile app.

If you're using a native iOS library that uses a "restricted reason" APIs, you'll need to configure an iOS privacy manifest to declare why you're including native code to call those APIs.
More details and a list of "required reason" APIs can be found in the [Apple Developer Documentation](https://developer.apple.com/documentation/bundleresources/privacy_manifest_files).
> **info** The information and steps included in this guide are still in development and may change due to new tools built for this purpose or new requirements from Apple.
## What is a Privacy manifest?
A privacy manifest is a file named **PrivacyInfo.xcprivacy** that is included in your iOS native project. This file is used to declare why the app includes native code that calls into certain APIs that Apple considers sensitive.
These APIs currently include accessing UserDefaults, file timestamp, system boot time, disk space, and active keyboard. Apple considers it an open list that can be expanded in the future.
## Configuration in app config
You can include an iOS privacy manifest by using the `privacyManifests` field under `expo.ios` in your app config.
```json app.json
{
  "expo": {
    "name": "My App",
    "slug": "my-app",
    "ios": {
      "privacyManifests": {
        "NSPrivacyAccessedAPITypes": [
          {
            "NSPrivacyAccessedAPIType": "NSPrivacyAccessedAPICategoryUserDefaults",
            "NSPrivacyAccessedAPITypeReasons": ["CA92.1"]
          }
        ]
      }
    }
  }
}
```
Make sure you have updated your Expo SDK libraries to the latest versions for your SDK version using `npx expo install --fix`.
<ConfigReactNative>
You can include an iOS privacy manifest in a bare Expo app by creating a **PrivacyInfo.xcprivacy** file using Xcode and adding it to your iOS app target.
Follow [Apple's Privacy manifest files](https://developer.apple.com/documentation/bundleresources/privacy_manifest_files) guide to create a **PrivacyInfo.xcprivacy** file.
</ConfigReactNative>
You can identify the `NSPrivacyAccessedAPITypes` and `NSPrivacyAccessedAPITypeReasons` values by looking at the [Apple Developer documentation](https://developer.apple.com/documentation/bundleresources/privacy_manifest_files/describing_use_of_required_reason_api).
### Including required reasons for Expo SDK packages and other third-party libraries
As of now, Apple does not correctly parse all the **PrivacyInfo** files included by static CocoaPods dependencies (such as Expo SDK packages and other ecosystem libraries). You may need to include the required reasons for the APIs used by those dependencies in your app's **PrivacyInfo.xcprivacy** file or the configuration in the **app.json**.
All Expo SDK packages that use "required reason" APIs file have a **PrivacyInfo** file included in the package directory. Here's [an example file](https://github.com/expo/expo/blob/main/packages/expo-application/ios/PrivacyInfo.xcprivacy) included with the `expo-application` library.
You can usually identify the required reasons for the APIs used by other third-party libraries by checking if the library you intend to use has a **PrivacyInfo.xcprivacy** file in the **node_modules/package_name/ios** directory. If it does, you can check the `NSPrivacyAccessedAPITypes` and `NSPrivacyAccessedAPITypeReasons` values in that file and copy those values to your configuration.
As an alternative, Apple notifies developers after they submit a build with missing privacy manifest files or specific reasons. You can wait until you receive a notification email from Apple and then include the required reasons listed in the email in your app's **PrivacyInfo.xcprivacy** file (if you don't use [CNG](/workflow/continuous-native-generation/)) or the configuration in your **app.json** file.
## Testing the Privacy manifest
You can test the privacy manifest by building your app and submitting it, either through App Store review process or to TestFlight's external review. Apple will email you within a few minutes of submitting if your app is missing any required reasons for the APIs used.


## Permissions

Learn about configuring and adding permissions in an app config file.

When developing a native app that requires access to potentially sensitive information on a user's device, such as their location or contacts, the app must request the user's permission first. For example, to access the user's media library, the app will need to run [`MediaLibrary.requestPermissionsAsync()`](/versions/latest/sdk/media-library#medialibraryrequestpermissionsasync).
Permissions in standalone and [development builds](/develop/development-builds/introduction/) require native build-time configuration before they can be requested using runtime JavaScript code. This is not required when testing projects in the [Expo Go](https://expo.dev/go) app.
> If you don't configure or explain the native permissions properly **it may result in your app getting rejected or pulled from the stores**.
## Android
Permissions are configured with the [`android.permissions`](/versions/latest/config/app/#permissions) and [`android.blockedPermissions`](/versions/latest/config/app/#blockedpermissions) keys in your [app config](/workflow/configuration/).
Most permissions are added automatically by libraries that you use in your app either with [config plugins](/config-plugins/plugins-and-mods/#create-a-plugin) or with a package-level **AndroidManifest.xml**. You only need to use `android.permissions` to add additional permissions that are not included by default in a library.
```json app.json
{
  "android": {
    "permissions": ["android.permission.SCHEDULE_EXACT_ALARM"]
  }
}
```
The only way to remove permissions that are added by package-level **AndroidManifest.xml** files is to block them with the [`android.blockedPermissions`](/versions/latest/config/app/#blockedpermissions) property. To do this, specify the **full permission name**. For example, if you want to remove the audio recording permissions added by `expo-camera`:
```json app.json
{
  "android": {
    "blockedPermissions": ["android.permission.RECORD_AUDIO"]
  }
}
```
- See [`android.permissions`](/versions/latest/config/app/#permissions) to learn about which permissions are included in the default [prebuild template](/workflow/prebuild#templates).
- Apps using _dangerous_ or _signature_ permissions without valid reasons **may be rejected by Google**. Ensure you follow the [Android permissions best practices](https://developer.android.com/training/permissions/usage-notes) when submitting your app.
- [All available Android `Manifest.permissions`](https://developer.android.com/reference/android/Manifest.permission).
<ConfigReactNative>
Modify **AndroidManifest.xml** to exclude specific permissions: add the `tools:node="remove"` attribute to a `<use-permission>` tag to ensure it is removed, even if it's included in a library's **AndroidManifest.xml**.
```xml
<manifest xmlns:tools="http://schemas.android.com/tools">
  <uses-permission tools:node="remove" android:name="android.permission.ACCESS_FINE_LOCATION" />
</manifest>
```
> You have to define the `xmlns:tools` attribute on `<manifest>` before you can use the `tools:node` attribute on permissions.
</ConfigReactNative>
## iOS
Your iOS app can ask for system permissions from the user. For example, to use the device's camera or access photos, Apple requires an explanation for how your app makes use of that data. Most packages will automatically provide a boilerplate reason for a given permission with [config plugins](/config-plugins/introduction/). These default messages will most likely need to be tailored to your specific use case for your app to be accepted by the App Store.
To set permission messages, use the [`ios.infoPlist`](/versions/latest/config/app/#infoplist) key in your [app config](/workflow/configuration/), for example:
```json app.json
{
  "ios": {
    "infoPlist": {
      "NSCameraUsageDescription": "This app uses the camera to scan barcodes on event tickets."
    }
  }
}
```
Many of these properties are also directly configurable using the [config plugin](/config-plugins/introduction/) properties associated with the library that adds them. For example, with [`expo-media-library`](/versions/latest/sdk/media-library) you can configure photo permission messages like this:
```json app.json
{
  "plugins": [
    [
      "expo-media-library",
      {
        "photosPermission": "Allow $(PRODUCT_NAME) to access your photos.",
        "savePhotosPermission": "Allow $(PRODUCT_NAME) to save photos."
      }
    ]
  ]
}
```
- Changes to the **Info.plist** cannot be updated over-the-air, they will only be deployed when you submit a new native binary. For example, with [`eas build`](/build/introduction).
- Apple's official [permission message recommendations](https://developer.apple.com/design/human-interface-guidelines/privacy#Requesting-permission).
- [All available **Info.plist** properties](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html).
<ConfigReactNative>
Add and modify the permission message values in **Info.plist** file directly. We recommend doing this directly in Xcode for autocompletion.
</ConfigReactNative>
## Web
On the web, permissions like the `Camera` and `Location` can only be requested from a [secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts#When_is_a_context_considered_secure). For example, using `https://` or `http://localhost`. This limitation is similar to Android's manifest permissions and iOS's **Info.plist** usage messages and is enforced to increase privacy.
## Resetting permissions
Often you want to be able to test what happens when a user rejects permissions, to ensure your app reacts gracefully. An operating-system level restriction on both Android and iOS prohibits an app from asking for the same permission more than once (you can imagine how this could be annoying for the user to be repeatedly prompted for permissions after rejecting them). To test different flows involving permissions in development, you may need to uninstall and reinstall the native app.
When testing in [Expo Go](https://expo.dev/go), you can delete the app and reinstall it by running `npx expo start` and pressing <kbd>i</kbd> or <kbd>a</kbd> in the [Expo CLI](/more/expo-cli/) Terminal UI.


## Environment variables in Expo

Learn how to use environment variables in an Expo project.

Environment variables are key-value pairs configured outside your source code that allow your app to behave differently depending on the environment. For example, you can enable or disable certain features when building a test version of your app, or switch to a different API endpoint when building for production.
The Expo CLI will automatically load environment variables with an `EXPO_PUBLIC_` prefix from **.env** files for use within your JavaScript code whenever you use the Expo CLI, such as when running `npx expo start` to start your app in local development mode.
## Reading environment variables from .env files
Create a **.env** file in the root of your project directory and add environment-specific variables on new lines in the form of `EXPO_PUBLIC_[NAME]=VALUE`:
```bash .env
EXPO_PUBLIC_API_URL=https://staging.example.com
EXPO_PUBLIC_API_KEY=abc123
```
Now you can use environment variables directly in your source code:
```tsx
import { Button } from 'react-native';
function Post() {
  const apiUrl = process.env.EXPO_PUBLIC_API_URL;
  async function onPress() {
    await fetch(apiUrl, { ... })
  }
  return <Button onPress={onPress} title="Post" />;
}
```
When you run `npx expo start`, `process.env.EXPO_PUBLIC_API_URL` will be replaced with `https://staging.example.com` in your app bundle. Variables can be updated as you edit your code without restarting the Expo CLI or clearing the cache. You will need to perform a full reload (for example, shake gesture and then Reload in Expo Go or your development build) to see the updated value.
> **warning** Do not store sensitive info, such as private keys, in `EXPO_PUBLIC_` variables. These variables will be visible in plain-text in your compiled application.
### How variables are loaded
Expo CLI loads **.env** files according to the [standard .env file resolution](https://github.com/bkeepers/dotenv/blob/c6e583a/README.md#what-other-env-files-can-i-use) and then replaces all references in your code to `process.env.EXPO_PUBLIC_[VARNAME]` with the corresponding value set in the **.env** files. Code inside **node_modules** is not affected for security purposes.
### How to read from environment variables
- <YesIcon small /> **Every environment variable must be statically referenced as a property of
  `process.env` using JavaScript's dot notation for it to be inlined.** For example, the expression
  `process.env.EXPO_PUBLIC_KEY` is valid and will be inlined.
- <NoIcon small /> **Alternative versions of the expression are not supported**. For example,
  `process.env['EXPO_PUBLIC_KEY']` or `const {EXPO_PUBLIC_X} = process.env` is invalid and will not
  be inlined.
### Using multiple .env files to define separate environments
You can define any of the [standard .env files](https://github.com/bkeepers/dotenv/blob/c6e583a/README.md#what-other-env-files-can-i-use), so it is possible to have separate **.env** and **.env.local**, files and they will load according to the standard priority.
You may choose to commit the default **.env** file or other standard configurations, but generally **.env.local** files should be added to your **.gitignore**, because they are used to specify environment configuration specific to your local machine (such as, for example, your network IP address if you need it to make a request against a local server).
```bash .gitignore
.env*.local
```
#### Environment variables and `NODE_ENV`
We recommend against using `NODE_ENV` to switch between **.env** files (such as **.env.test** and **.env.production**). While it is technically possible (`NODE_ENV=test npx expo start` will load **.env.test**) &mdash; it may not behave as you would expect. For example, `npx expo export` always forces `NODE_ENV` to `production`, so `NODE_ENV=test npx expo export` will not actually run the command with the `NODE_ENV` set to `test`.
Other tools that build on top of Expo CLI commands will exhibit the same behavior &mdash; for example, `eas update` calls into `npx expo export` and, as a result, `NODE_ENV=test eas update` will similarly not run with the `NODE_ENV` set to `test` (it will be `production`). The `NODE_ENV` environment variable is used by many tools in different ways (for example, if you run `NODE_ENV=production npm install` then your `devDependencies` will not be installed) and we have found that for React Native projects, it's best not to overload it further for this use case.
If you use EAS, consider using `eas env:pull` instead. This will swap your **.env.local** with an environment of your choice, rather than depending on `NODE_ENV`. You can accomplish a similar behavior without EAS by writing a script to overwrite **.env.local** or **.env** with the appropriate contents for the environment you wish to work with.
### Disabling environment variables
Environment variables in Expo CLI have two parts and both can be disabled:
1. Expo CLI automatically loads the **.env** files into the global process. To disable this behavior, set the environment variable `EXPO_NO_DOTENV` to `1` before running any Expo CLI command: `EXPO_NO_DOTENV=1`.
2. Expo's Metro config includes the inline serialization of environment variables in the client JavaScript bundle. To disable this behavior, you can use `EXPO_NO_CLIENT_ENV_VARS=1`.
If you're experiencing issues with environment variables, you can try disabling one or both of these features.
## Environment variables in Expo Application Services
### EAS Build
[EAS Build](/build/introduction/) uses Metro Bundler to build the JavaScript bundle embedded within your app binary, so it will use **.env** files uploaded with your build job to inline `EXPO_PUBLIC_` variables into your code. EAS Build also lets you define environment variables within build profiles in **eas.json** and via EAS Secrets. Check out the EAS Build documentation on [environment variables and build secrets](/build-reference/variables/) for more information.
### EAS Update
[EAS Update](/eas-update/introduction) uses Metro Bundler in your local environment or CI to build your app bundle, so it will use available **.env** files to inline `EXPO_PUBLIC_` variables into your code. Check out the EAS Update documentation on [environment variables](/eas-update/environment-variables/) for more information.
## Migrating to Expo environment variables
### From react-native-config
Update your **.env** files to prefix any variables used within your JavaScript code with `EXPO_PUBLIC_`:
```diff .env
- API_URL=https://myapi.com
+ EXPO_PUBLIC_API_URL=https://myapi.com
```
> If you have any non-standard **.env** files (for example, **.env.staging**), you will need to migrate those to one of the [standard .env files](https://github.com/bkeepers/dotenv/blob/c6e583a/README.md#what-other-env-files-can-i-use).
Then update your code to use `process.env.EXPO_PUBLIC_[VARNAME]`:
```diff
- import Config from 'react-native-config';
- const apiUrl = Config.API_URL;
+ const apiUrl = process.env.EXPO_PUBLIC_API_URL;
```
### From babel-plugin-transform-inline-environment-variables
Using a Babel plugin to transform your environment variable references in your code is similar to how Expo environment variables work. Set your variables inside a **.env** file and update your variable names to use the `EXPO_PUBLIC_` prefix:
```diff
- const apiUrl = process.env.API_URL;
+ const apiUrl = process.env.EXPO_PUBLIC_API_URL;
```
Then you can remove the plugin from your [Babel config](/versions/latest/config/babel/):
```diff babel.config.js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
--    plugins: ['transform-inline-environment-variables'],
  };
};
```
After updating your Babel config file, be sure to clear your cache with `npx expo start --clear`.
### From direnv
Move any environment variables used in your JavaScript from their **.envrc** file to a **.env** file and prefix it with `EXPO_PUBLIC_`.
Previously with `direnv`, you would need to use a [dynamic app config](/versions/latest/config/app/#app-config) that reads from [`process.env`](https://nodejs.org/dist/latest/docs/api/process.html#process_process_env) to set environment variables on the `extra` field so they can be used in your JavaScript code via [`expo-constants`](/versions/latest/sdk/constants). Move those references directly into your code, adding the `EXPO_PUBLIC_` prefix:
```diff
- import Constants from 'expo-constants';
- const apiUrl = Constants.expoConfig.extra.apiUrl;
+ const apiUrl = process.env.EXPO_PUBLIC_API_URL;
```
> [`direnv`](https://direnv.net/) automatically loads and unloads environment variables in your shell depending on your current directory, meaning it can affect the environment for any process running in that directly, not just the Expo CLI. You will likely want to continue using `direnv` for other environment variables that are not used in your JavaScript code.
## Security considerations
Never store sensitive secrets in environment variables that are prefixed with `EXPO_PUBLIC_`. When an end-user runs your app, they have access to all of the code and embedded environment variables in your app. Read more about [storing sensitive info](https://reactnative.dev/docs/security#storing-sensitive-info).


# Linking

## Overview of Linking, Deep Links, Android App Links, and iOS Universal Links

An overview of available resources to implement Linking and Deep Links in your Expo apps.

## Linking
Linking allows your app to interact with incoming and outgoing URLs. In this process, the user not only gets directed to open your app, but they are taken to a specific screen (route) within the app.
Video Tutorial: [Watch: Setting up linking with Expo](https://www.youtube.com/watch?v=kNbEEYlFIPs)
### Linking strategies
There are different linking strategies you handle in your Expo app:
- Linking to your app using your web domain links ([universal linking](#universal-linking) using the `https` or `http` scheme)
- Linking to your app from other apps or websites using a custom scheme (deep links)
- Linking to other apps from your app (outgoing links)
> **info** **Tip:** Support for incoming links in Expo Go is limited. We recommend using [Development builds](/develop/development-builds/introduction/) to test your app's linking strategies.
## Universal linking
Both Android and iOS implement their own systems for routing web URL's to an app if the app is installed. On Android, this system is called App Links, and on iOS it is called Universal Links. The pre-requisite for both systems is that you have a web domain where you can host a file which verifies you control the domain.
### Android App Links
Android App Links are different from [standard deep links](#linking-to-your-app-from-other-apps-or-websites) as they use regular HTTP and HTTPS schemes and are exclusive to Android devices.
This link type allows your app to always open when a user clicks the link instead of choosing between the browser or another handler from a dialog displayed on the device. If the user doesn't have your app installed, the link takes them to your app's associated website.
### iOS Universal Links
iOS Universal Links are different from [standard deep links](#linking-to-your-app-from-other-apps-or-websites) as they use regular HTTP and HTTPS schemes and are exclusive to iOS devices.
This link type allows your app to open when a user clicks an HTTP(S) link pointing to your web domain. If the user doesn't have your app installed, the link takes them to your app's associated website. You can further configure the website by displaying a banner for the user to open your app using [Apple Smart Banner](/linking/ios-universal-links/#apple-smart-banner).
## Linking to your app from other apps or websites
[Deep Links](https://en.wikipedia.org/wiki/Deep_linking) are links to a specific URL-based content inside an app or a website.
For example, by clicking a product advertisement, your app will open on the user's device and they can view that product's details. This product's link that the user clicked may look like (or alternatively be invoked by JavaScript with setting `window.location.href`):
```html
<a href="myapp://web-app.com/product">View Product</a>
```
This link is constructed by three parts:
- **Scheme**: The URL scheme that identifies the app that should open the URL (example: `myapp://`). It can also be `https` or `http` for non-standard deep links. We recommend [universal linking](#universal-linking) for http(s)-based deep links.
- **Host**: The domain name of the app that should open the URL (example: `web-app.com`).
- **Path**: The path to the screen that should be opened (example: `/product`). If the path isn't specified, the user is taken to the home screen of the app.
### Use Expo Router to handle deep linking
To implement any of the above Linking strategies, **we recommend using** [Expo Router](/router/introduction/) since deep linking is automatically enabled for all of your app's screens.
**Benefits:**
- `Link` component from Expo Router can be used to [handle URL schemes to other apps](/linking/into-other-apps/#expo-router)
- Android App Links and iOS Universal Links require configuring runtime routing in JavaScript for the link in your app. Using Expo Router, you don't have to configure runtime routing separately since deep links for all routes are automatically enabled.
- For third-party deep links, you can override the default linking behavior to handle incoming links and send navigation events. See [Customizing links](/router/advanced/native-intent).
## Linking to other apps from your app
Linking to other apps from your app is achieved using a URL based on the target app's URL scheme. This **URL scheme** allows you to reference resources within that native app.
Your app can use a [common URL scheme](/linking/into-other-apps/#common-url-schemes) for default apps, including `https` and `http` (commonly used by web browsers like Chrome, Safari, and so on), and use JavaScript to invoke the URL that launches the corresponding native app.


## Linking into other apps

Learn how to handle and open a URL from your app based on the URL scheme of another app.

Handling linking into other apps from your app is achieved by using the target app's URL. There are two methods you can use to open such URLs from your app:
- Using the [`expo-linking`](/versions/latest/sdk/linking) API
- Using Expo Router's [`Link` component](/develop/file-based-routing/#how-does-link-work)
## Using expo-linking API
The [`expo-linking`](/versions/latest/sdk/linking) API provides a universal abstraction over native linking APIs (such as `window.history` on the web) and offers utilities for your app to interact with other installed apps.
The example below opens at the [common URL scheme](#common-url-schemes) in the default browser of the operating system using [`Linking.openURL`](/versions/latest/sdk/linking/#linkingopenurlurl):
```tsx index.tsx|collapseHeight=240
import { Button, View, StyleSheet } from 'react-native';
import * as Linking from 'expo-linking';
export default function Home() {
  return (
    <View style={styles.container}>
      <Button title="Open a URL" onPress={() => Linking.openURL('https://expo.dev/')} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
## Using Expo Router's `Link` component
If your project uses [Expo Router](/router/introduction/), use the `Link` component to open a URL. It wraps a `<Text>` component on native platforms and an `<a>` element on the web. It also uses the `expo-linking` API to handle URL schemes.
The example below opens a [common URL scheme](#common-url-schemes) (HTTPS) in the default browser of the operating system:
```tsx index.tsx|collapseHeight=240
import { Button, View, StyleSheet } from 'react-native';
import { Link } from 'expo-router';
export default function Home() {
  return (
    <View style={styles.container}>
      <Link href="https://expo.dev">Open a URL</Link>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
## Common URL schemes
There are built-in URL schemes that provide access to core functionality on all platforms. Here is a list of commonly-used schemes:
| Scheme           | Description           | Example                   |
| ---------------- | --------------------- | ------------------------- |
| `https` / `http` | Open web browser app. | `https://expo.dev`        |
| `mailto`         | Open mail app.        | `mailto:support@expo.dev` |
| `tel`            | Open phone app.       | `tel:+123456789`          |
| `sms`            | Open SMS app.         | `sms:+123456789`          |
Note: Specify Android intents to handle common URL schemes
---
For Android 11 (API level 30) and above, you must specify the intents your app will handle in the **AndroidManifest.xml** file. You can accomplish this by [creating a config plugin](/config-plugins/plugins-and-mods/#create-a-plugin).
The following config plugin example enables linking to email and phone apps by defining the intents:
```ts my-plugin.ts|collapseHeight=300
import { withAndroidManifest, ConfigPlugin } from 'expo/config-plugins';
const withAndroidQueries: ConfigPlugin = config => {
  return withAndroidManifest(config, config => {
    config.modResults.manifest.queries = [
      {
        intent: [
          {
            action: [{ $: { 'android:name': 'android.intent.action.SENDTO' } }],
            data: [{ $: { 'android:scheme': 'mailto' } }],
          },
          {
            action: [{ $: { 'android:name': 'android.intent.action.DIAL' } }],
          },
        ],
      },
    ];
    return config;
  });
};
module.exports = withAndroidQueries;
```
After creating the config plugin, [import the custom config plugin](/config-plugins/plugins-and-mods/#import-a-plugin) under the `plugins` property:
```json app.json
{
  "expo": {
    "plugins": [
      "./my-plugin.ts"
    ]
  }
}
```
> **info** **Tip**: On Android, you can use `expo-intent-launcher` to open a **specific settings screen** on the device. See [`expo-intent-launcher` API reference](/versions/latest/sdk/intent-launcher/#enums) to view the list of available intents.
---
## Custom URL schemes
> If you know the custom scheme for the app you want to open, you can link to it using any of the methods: [Using `expo-linking` API](#using-expo-linking-api) or [Using `Link` from Expo Router](#using-expo-routers-link-component).
Some services provide documentation on how to use their app's custom URL schemes. For example, [Uber's deep linking documentation](https://developer.uber.com/docs/riders/ride-requests/tutorials/deep-links/introduction#standard-deep-links) describes how to link directly to a specific pickup location and destination:
```shell
uber://?client_id=<CLIENT_ID>&action=setPickup&pickup[latitude]=37.775818&pickup[longitude]=-122.418028&pickup[nickname]=UberHQ&pickup[formatted_address]=1455%20Market%20St%2C%20San%20Francisco%2C%20CA%2094103&dropoff[latitude]=37.802374&dropoff[longitude]=-122.405818&dropoff[nickname]=Coit%20Tower&dropoff[formatted_address]=1%20Telegraph%20Hill%20Blvd%2C%20San%20Francisco%2C%20CA%2094133&product_id=a1111c8c-c720-46c3-8534-2fcdd730040d&link_text=View%20team%20roster&partner_deeplink=partner%3A%2F%2Fteam%2F9383
```
In the example above, if the user does not have the Uber app installed on their device, your app can direct them to the Google Play Store or Apple App Store to install it. We recommend using the [`react-native-app-link`](https://github.com/FiberJW/react-native-app-link) library to handle these scenarios.
Note: Specify custom schemes for iOS
---
On iOS, using [`Linking.canOpenURL`](/versions/latest/sdk/linking/#linkingcanopenurlurl) to query other apps's linking schemes requires additional configuration in **InfoPlist**. You can use the [`ios.infoPlist`](/versions/latest/config/app/#infoplist) property in your app config to specify a list of schemes your app is allowed to query. For example:
```json app.json
{
  "expo": {
    "ios": {
      "infoPlist": {
        "LSApplicationQueriesSchemes": ["uber"]
      }
    }
  }
}
```
If your don't specify this list, `Linking.canOpenURL` may return `false` even if the device has the target app installed.
> **info** **Tip**: To test the configuration described above from an iOS device, [use a development build](/develop/development-builds/introduction/). It cannot be tested with Expo Go.
---
## Create URLs
You can use [`Linking.createURL`](/versions/latest/sdk/linking/#linkingcreateurlurl) to create a URL that can be used to open or redirect back to your app. This method resolves to the following:
- **Production and development builds**: `myapp://`, where `myapp` is the [custom scheme](/linking/into-your-app/#add-a-scheme-in-app-config) defined in the app config
- **Development in Expo Go**: `exp://127.0.0.1:8081`
Using `Linking.createURL` helps you avoid hardcoding URLs. You can modify the returned URL by passing optional parameters to this method.
To pass data to your app, you can append it as a path or query string to the URL. `Linking.createURL` will construct a working URL automatically. For example:
```tsx Example
const redirectUrl = Linking.createURL('path/into/app', {
  queryParams: { hello: 'world' },
});
```
This will resolve into the following, depending on the environment:
- **Production and development builds**: `myapp://path/into/app?hello=world`
- **Development in Expo Go**: `exp://127.0.0.1:8081/--/path/into/app?hello=world`
Note: Using Expo Go for testing?
---
For apps that require a stable URL (for example, auth provider redirects), use a development build with a custom scheme instead of using Expo Go. For more details on how to create and test a custom scheme, see [Linking into your app](/linking/into-your-app/).
---
## In-app browsers
The `expo-linking` API allows you to open a URL using the operating system's default web browser app. You can use the [`expo-web-browser`](/versions/latest/sdk/webbrowser) library to open URLs in an in-app browser. For example, an in-app browser is useful for secure [authentication](/guides/authentication).
Note: Example of opening a URL in an in-app browser
---
The example below simulates the behavior of opening a URL in an in-app browser using `expo-web-browser` and the default or preferred web browser using `expo-linking`:
#### WebBrowser compared to Linking
```tsx
import { Button, View, StyleSheet } from 'react-native';
import * as Linking from 'expo-linking';
import * as WebBrowser from 'expo-web-browser';
export default function Home() {
  return (
    <View style={styles.container}>
      <Button
        title="Open URL with the system browser"
        onPress={() => Linking.openURL('https://expo.dev')}
        style={styles.button}
      />
      <Button
        title="Open URL with an in-app browser"
        onPress={() => WebBrowser.openBrowserAsync('https://expo.dev')}
        style={styles.button}
      />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  button: {
    marginVertical: 10,
  },
});
```
---
## Additional link functionality on web
To provide additional link functionality on the web, such as right-click to copy or hover to preview, you can use a `Link` component from the [`expo-router`](/router/introduction/) library.
```tsx index.tsx
import { Link } from 'expo-router';
export default function Home() {
  return <Link href="https://expo.dev">Go to Expo</Link>;
}
```
Alternatively, you can use the [`@expo/html-elements`](https://www.npmjs.com/package/@expo/html-elements) library to use a universal `<A>` element:
```tsx index.tsx
import { A } from '@expo/html-elements';
export default function Home() {
  return <A href="https://expo.dev">Go to Expo</A>;
}
```
The `<A>` component renders an `<a>` on the web and an interactive `<Text>`that uses the `expo-linking` API on native platforms.


## Linking into your app

Learn how to handle an incoming URL in your React Native and Expo app by creating a deep link.

This guide provides steps to configure standard **deep links** in your project by adding a custom scheme.
> **info** For most apps, you probably want to set up [Android App/iOS Universal Links](/linking/overview/#universal-linking) instead of the deep links described in this guide or set up both.
## Add a custom scheme in app config
To provide a link to your app, add a custom string to the [`scheme`](/versions/latest/config/app/#scheme) property in the [app config](/workflow/configuration/):
```json app.json
{
  "expo": {
    "scheme": "myapp"
  }
}
```
After adding a custom scheme to your app, you need to [create a new development build](/develop/development-builds/create-a-build/). Once the app is installed on a device, you can open links within your app using `myapp://`.
If the **custom scheme is not defined**, the app will use `android.package` and `ios.bundleIdentifier` as the default schemes in both development and production builds. This is because [Expo Prebuild](/workflow/prebuild/) automatically adds these properties as custom schemes for Android and iOS.
## Test the deep link
You can test a link that opens your app using [`npx uri-scheme`](https://github.com/expo/expo/tree/main/packages/uri-scheme#readme), which is a command-line utility for interacting and testing URI schemes.
For example, if your app has a `/details` screen that you want to open when a user taps on a link (either through another app or a web browser), you can test this behavior by running the following command:
```sh
$ npx uri-scheme open com.example.app://somepath/details --android
$ npx uri-scheme open myapp://somepath/details --ios
```
Running the above command:
- Opens your app's `/details` screen
- The `android` or `ios` options specify that the link should be opened on Android or iOS
- Alternatively, you can try opening the link by clicking a link like `<a href="scheme://">Click me</a>` in the device's web browser. Note that entering the link in the address bar may not work as expected, and you can use [universal linking](/linking/overview/#universal-linking) to implement that ability.
Note: Test a link using Expo Go
---
By default, [Expo Go](https://expo.dev/go) uses the `exp://` scheme. If you link to `exp://` without specifying a URL address afterward, it will open the app to the home screen. In development, your app's complete URL looks like `exp://127.0.0.1:8081`.
To open the `/details` screen while testing on Expo Go, you can use `npx uri-scheme`:
```sh
$ npx uri-scheme open exp://127.0.0.1:8081/--/somepath/into/app?hello=world --ios
```
In Expo Go, `/--/` is added to the URL when a path is specified. This indicates to Expo Go that the substring after it corresponds to the deep link path and is not part of the path to the app itself.
By default, `exp://` is replaced with `http://` when opening a URL in Expo Go. You can also use `exps://` to open `https://` URLs. However, `exps://` does not currently support loading sites with insecure TLS certificates.
---
## Handle URLs
> **info** If you are using [Expo Router](/linking/overview/#use-expo-router-to-handle-deep-linking), you can ignore this section.
You can observe links that launch your app using the [`Linking.useURL()`](/versions/latest/sdk/linking/#useurl) hook from [`expo-linking`](/versions/latest/sdk/linking/).
```tsx index.tsx
import * as Linking from 'expo-linking';
export default function Home() {
  const url = Linking.useURL();
  return <Text>URL: {url}</Text>;
}
```
The `Linking.useURL()` hook works behind the scenes by following these imperative methods:
- The link that launched the app is initially returned using [`Linking.getInitialURL()`](/versions/latest/sdk/linking/#linkinggetinitialurl)
- Any new links triggered while the app is already open are observed with [`Linking.addEventListener('url', callback)`](/versions/latest/sdk/linking/#linkingaddeventlistenertype-handler)
## Parse URLs
You can use the [`Linking.parse()`](/versions/latest/sdk/linking/#linkingparseurl) method to parse the **path**, **hostname**, and **query parameters** from a URL. This method extracts deep linking information and considers nonstandard implementations.
```tsx index.tsx|collapseHeight=440
import * as Linking from 'expo-linking';
export default function Home() {
  const url = Linking.useURL();
  if (url) {
    const { hostname, path, queryParams } = Linking.parse(url);
    console.log(
      `Linked to app with hostname: ${hostname}, path: ${path} and data: ${JSON.stringify(
        queryParams
      )}`
    );
  }
  return (
  )
}
```
## Limitations
If a user does not have your app installed, deep links to your app will not work. Attribution services like [Branch](https://www.branch.io/deep-linking/) offer solutions for conditionally linking to your app or web page.
Android App/iOS Universal Links is another solution you can use to handle such cases. This type of linking allows your app to open when a user clicks follows an HTTP(S) link pointing to your web domain. If the user doesn't have your app installed, the link takes them to your website. For more details, see [universal linking](/linking/overview/#universal-linking).


## Android App Links

Learn how to configure Android App Links to open your Expo app from a standard web URL.

To configure Android App Links for your app, you need to:
- Add `intentFilters` and set `autoVerify` to true in your project's app config
- Set up two-way association to verify your website and native app
<VideoBoxLink
  videoId="kNbEEYlFIPs"
  time={399}
  title="Watch: Set up Android App Links with Expo Router"
/>
## Add `intentFilters` to the app config
Configure your app config by adding the `android.intentFilters` property and setting the `autoVerify` attribute to `true`. Specifying `autoVerify` is required for Android App Links to work correctly.
The following example shows a basic configuration that enables your app to appear in the standard Android dialog as an option for handling any links to the `webapp.io` domain. It also uses the regular `https` scheme since [Android App Links](/linking/overview/#android-app-links) are different from [standard deep links](/linking/into-other-apps/).
```json app.json|collapseHeight=454
{
  "expo": {
    "android": {
      "intentFilters": [
        {
          "action": "VIEW",
          "autoVerify": true,
          "data": [
            {
              "scheme": "https",
              "host": "*.webapp.io",
              "pathPrefix": "/records"
            }
          ],
          "category": ["BROWSABLE", "DEFAULT"]
        }
      ]
    }
  }
}
```
## Set up two-way association
To setup **two-way association** between the website and Android app, you will need the following:
- **Website verification:** This requires creating a **assetlinks.json** file inside the **/.well-known** directory and hosting it on the target website. This file is used to verify that the app opened from a given link is the correct app.
- **Native app verification:** This requires some form of code signing that references the target website domain (URL).
### Create assetlinks.json file
Step 1: 
Create an **assetlinks.json** file for the website verification (also known as [digital asset links](https://developers.google.com/digital-asset-links/v1/getting-started) file) at **/.well-known/assetlinks.json**. This file is used to verify that the app opened for a given link.
If you're using Expo Router to build your website (or any other modern React framework such as Remix, Next.js, and so on), create **assetlinks.json** at **public/.well-known/assetlinks.json**. For legacy Expo webpack projects, create the file at **web/.well-known/assetlinks.json**.
Step 2: 
Get the value of `package_name` from your app config, under `android.package`.
Step 3: 
Get the value of `sha256_cert_fingerprints` from your app's signing certificate. If you're using [EAS Build](/build/setup/) to build your Android app, after creating a build:
- Run `eas credentials -p android` command, and select the build profile to get its fingerprint value.
- Copy the fingerprint value listed under `SHA256 Fingerprint`.
Note: Alternate method to obtain the SHA256 certificate fingerprint from Google Play Console
---
If you're not using EAS to manage code signing, you can find the **sha256_cert_fingerprints** by building and submitting your app manually to the [Google Play Console](https://play.google.com/console/):
- Inside the Google Play Console's dashboard, go to **Release > Setup > App Signing**.
- Find the correct **Digital Asset Links JSON** snippet for your app.
- Copy the value looks like `14:6D:E9:83...` and paste it into your **public/.well-known/assetlinks.json** file under `sha256_cert_fingerprints`.
---
Step 4: 
Add `package_name` and `sha256_cert_fingerprints` to the **assetlinks.json** file:
```json public/.well-known/assetlinks.json
[
  {
    "relation": ["delegate_permission/common.handle_all_urls"],
    "target": {
      "namespace": "android_app",
      "package_name": "com.example",
      "sha256_cert_fingerprints": [
        // Supports multiple fingerprints for different apps and keys
        "14:6D:E9:83:51:7F:66:01:84:93:4F:2F:5E:E0:8F:3A:D6:F4:CA:41:1A:CF:45:BF:8D:10:76:76:CD"
      ]
    }
  }
]
```
> **info** You can add multiple fingerprints to the `sha256_cert_fingerprints` array to support different variants of your app. For more information, see [Android's documentation on how to declare website associations](https://developer.android.com/training/app-links/verify-android-applinks#web-assoc).
### Host assetlinks.json file
Host the **assetlinks.json** file using a web server with your domain. This file must be served with the content-type `application/json` and accessible over an HTTPS connection. Verify that your browser can access this file by typing the complete URL in the address bar.
### Native app verification
Install the app on an Android device to trigger the [Android app verification](https://developer.android.com/training/app-links/verify-android-applinks#web-assoc) process.
Once you have your app opened, see [Handle links into your app](/linking/into-your-app/#handle-urls) for more information on how to handle inbound links and show the user the content they requested.
## Debugging
The Expo CLI enables you to test Android App Links without deploying a website. Utilizing the [`--tunnel`](/more/expo-cli/#tunneling) functionality, you can forward your dev server to a publicly available HTTPS URL.
Step 1: 
Set the environment variable `EXPO_TUNNEL_SUBDOMAIN=my-custom-domain` where `my-custom-domain` is a unique string that you use during development. This ensures that your tunnel URL is consistent across dev server restarts.
Step 2: 
Add `intentFilters` to your app config as [described above](#add-intentfilters-to-the-app-config). Replace the `host` value with a Ngrok URL: `my-custom-domain.ngrok.io`.
Step 3: 
Start your dev server with the `--tunnel` flag:
```sh
$ npx expo start --tunnel
```
Step 4: 
Compile the development build on your device:
```sh
$ npx expo run:android
```
Step 5: 
Use the following `adb` command to start the intent activity and open the link on your app or type the custom domain link in your device's web browser.
```sh
$ adb shell am start -a android.intent.action.VIEW  -c android.intent.category.BROWSABLE -d "https://my-custom-domain.ngrok.io/" <your-package-name>
```
## Troubleshooting
Here are some common tips to help you troubleshoot when implementing Android App Links:
- Ensure your website is served over HTTPS and with the content-type `application/json`
- [Verify Android app links](https://developer.android.com/training/app-links/verify-android-applinks)
- Android verification may take 20 seconds or longer to take effect, so be sure to wait until it is completed.
- If you update your web files, rebuild the native app to trigger a server update on the vendor side (Google)


## iOS Universal Links

Learn how to configure iOS Universal Links to open your Expo app from a standard web URL.

To configure iOS Universal Links for your app, you need to set up the **two-way association** to verify your website and native app.
<VideoBoxLink
  videoId="kNbEEYlFIPs"
  time={68}
  title="Watch: Set up iOS Universal Links with Expo Router"
/>
## Set up two-way association
To setup **two-way association** between the website and app for iOS, you need to perform the following steps:
- **Website verification:** This requires creating a **apple-app-site-association (AASA)** file inside the **/.well-known** directory and hosting it on the target website. This file is used to verify that the app opened from a given link is the correct app.
- **Native app verification:** This requires some form of code signing that references the target website domain (URL).
### Create AASA file
Create an **apple-app-site-association** file for the website verification inside the **/.well-known** directory. This file specifies your Apple Developer Team ID, bundle identifier, and a list of supported paths to redirect to the native app.
> **info** You can run the experimental CLI command `npx setup-safari` inside your project to automatically register a bundle identifier to your Apple account, assign entitlements to the ID, and create an iTunes app entry in the store. The local setup will be printed and you can skip most the following. This is the easiest way to get started with universal links on iOS.
If you're using Expo Router to build your website (or any other modern React framework such as Remix, Next.js, and so on), create the AASA file at **public/.well-known/apple-app-site-association**. For legacy Expo webpack projects, create the file at **web/.well-known/apple-app-site-association**.
```json public/.well-known/apple-app-site-association
{
  // This section enables Universal Links
  "applinks": {
    "apps": [],
    "details": [
      {
        // Syntax: "<APPLE_TEAM_ID>.<BUNDLE_ID>"
        "appID": "QQ57RJ5UTD.com.example.myapp",
        // All paths that should support redirecting.
        "paths": ["/records/*"]
      }
    ]
  },
  // This section enables Apple Handoff
  "activitycontinuation": {
    "apps": ["<APPLE_TEAM_ID>.<BUNDLE_ID>"]
  },
  // This section enable Shared Web Credentials
  "webcredentials": {
    "apps": ["<APPLE_TEAM_ID>.<BUNDLE_ID>"]
  }
}
```
In the above example:
- Any links to `https://www.myapp.io/records/*` (with wildcard matching for the record ID) should be opened directly by the app with a matching bundle identifier on an iOS device. It is a combination of the [Apple Team ID](https://expo.fyi/apple-team) and the bundle identifier.
- The `*` wildcard does **not** match domain or path separators (periods and slashes).
- The `activitycontinuation` and `webcredentials` objects are optional, but recommended.
> See [Apple's documentation](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html) for further details on the format of the AASA. Branch provides an [AASA validator](https://branch.io/resources/aasa-validator/) which can help you confirm that your AASA is correctly deployed and has a valid format.
### Supporting `details` format
The [`details` format is supported](https://developer.apple.com/documentation/xcode/supporting-associated-domains) as of iOS 13. It allows you to specify:
- `appIDs` instead of `appID`: Makes it easier to associate multiple apps with the same configuration
- An array of `components`: Allows you to specify fragments, exclude specific paths, and add comments
Note: An example AASA JSON from Apple's documentation
---
```json public/.well-known/apple-app-site-association
{
  "applinks": {
    "details": [
      {
        "appIDs": ["ABCDE12345.com.example.app", "ABCDE12345.com.example.app2"],
        "components": [
          {
            "#": "no_universal_links",
            "exclude": true,
            "comment": "Matches any URL whose fragment equals no_universal_links and instructs the system not to open it as a universal link"
          },
          {
            "/": "/buy/*",
            "comment": "Matches any URL whose path starts with /buy/"
          },
          {
            "/": "/help/website/*",
            "exclude": true,
            "comment": "Matches any URL whose path starts with /help/website/ and instructs the system not to open it as a universal link"
          },
          {
            "/": "/help/*",
            "?": {
              "articleNumber": "????"
            },
            "comment": "Matches any URL whose path starts with /help/ and which has a query item with name 'articleNumber' and a value of exactly 4 characters"
          }
        ]
      }
    ]
  }
}
```
---
To support all iOS versions, you can provide both the above formats in your `details` key, but we recommend placing the configuration for more recent iOS versions first.
### Host AASA file
Host the **apple-app-site-association** file using a web server with your domain. This file must be served over an HTTPS connection. Verify that your browser can access this file.
After you have setup the AASA file, deploy your website to a server that supports HTTPS (most modern web hosts).
### Native app configuration
After deploying your **apple-app-site-association** (AASA) file, configure your app to use your associated domain by adding [`ios.associatedDomains`](/versions/latest/config/app/#associateddomains) to your [app config](/workflow/configuration/). Make sure to follow [Apple's specified format](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_developer_associated-domains) and **not** include the protocol (`https`) in your URL. This is a common mistake that will result in the universal links not working.
For example, if an associated website is `https://expo.dev/`, the `applinks` is:
```json app.json
{
  "expo": {
    "ios": {
      "associatedDomains": ["applinks:expo.dev"]
    }
  }
}
```
Build your iOS app with [EAS Build](/build/setup/) which ensures that the entitlement is registered with Apple automatically.
Note: Manual native configuration
---
If you're not using EAS or [Continuous Native Generation](/workflow/continuous-native-generation) (`npx expo prebuild`), you have to [manually configure](/build-reference/ios-capabilities#manual-setup) the **Associated Domains** capability for your bundle identifier.
If you enable through the [Apple Developer Console](/build-reference/ios-capabilities#apple-developer-console), then make sure to add the following entitlements in your **ios/[app]/[app].entitlements** file:
```xml
<key>com.apple.developer.associated-domains</key>
<array>
  <string>applinks:expo.dev</string>
</array>
```
---
### Native app verification
Install the app on your iOS device to trigger the verification process. A link to your website on your mobile device should open your app. If it doesn't, re-check the previous steps to ensure that your AASA is valid, the path specified in the AASA, and you have correctly configured your App ID in the [Apple Developer Console](https://developer.apple.com/account/resources/identifiers/list).
Once you have your app opened, see [Handle links into your app](/linking/into-your-app/#handle-urls) for more information on how to handle inbound links and show the user the content they requested.
> iOS downloads your AASA when your app is first installed or when updates are installed from the App Store. The operating system does not refresh frequently after that. If you want to change the paths in your AASA for a production app, you will need to issue a full update via the App Store so that all of your users' apps re-fetch your AASA and recognize the new paths.
## Apple Smart Banner
If a user doesn't have your app installed, they'll be directed to the website. You can use the [Apple Smart Banner](https://developer.apple.com/documentation/webkit/promoting_apps_with_smart_app_banners) to show a banner at the top of the page that prompts the user to install the app. The banner will only show up if the user is on a mobile device and doesn't have the app installed.
To enable the banner, add the following meta tag to the `<head>` of your website, replacing `<ITUNES_ID>` with your app's iTunes ID:
```html
<meta name="apple-itunes-app" content="app-id=<ITUNES_ID>" />
```
If you're having trouble setting up the banner, run the following command to automatically generate the meta tag for your project:
```sh
$ npx setup-safari
```
### Add the meta tag to your statically rendered website
If you're building a [statically rendered website with Expo Router](/router/web/static-rendering), then add the HTML tag to the `<head>` component in your [**app/+html.js** file](/router/web/static-rendering#root-html).
```tsx app/+html.tsx
import { type PropsWithChildren } from 'react';
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="apple-itunes-app" content="app-id=<ITUNES_ID>" />
        {/* Other head elements... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
```
## Debugging
Expo CLI enables you to test iOS Universal Links without deploying a website. Utilizing the [`--tunnel`](/more/expo-cli/#tunneling) functionality, you can forward your dev server to a publicly available HTTPS URL.
Step 1: 
Set the environment variable `EXPO_TUNNEL_SUBDOMAIN=my-custom-domain` where `my-custom-domain` is a unique string that you use during development. This ensures that your tunnel URL is consistent across dev server restarts.
Step 2: 
Add `associatedDomains` to your app config as [described above](#native-app-configuration). Replace the domain value with a Ngrok URL: `my-custom-domain.ngrok.io`.
Step 3: 
Start your dev server with the `--tunnel` flag:
```sh
$ npx expo start --tunnel
```
Step 4: 
Compile the development build on your device:
```sh
$ npx expo run:ios
```
You can now type your custom domain link in your device's web browser to open your app.
## Troubleshooting
Here are some common tips to help you troubleshoot when implementing iOS Universal Links:
- Read Apple's official documentation on [debugging universal links](https://developer.apple.com/documentation/technotes/tn3155-debugging-universal-links)
- Ensure your apple app site association file is valid by using a [validator tool](https://branch.io/resources/aasa-validator/).
- The uncompressed `apple-app-site-association` file cannot be [larger than 128kb](https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html).
- Ensure your website is served over HTTPS.
- If you update your web files, rebuild the native app to trigger a server update on the vendor side (Apple).


# Write native code

## Add custom native code

Learn how to add custom native code to your Expo project.

You can add custom native code by using one or both of the following approaches:
- [Using libraries that include native code](#using-libraries-that-include-native-code)
- [Writing native code](#writing-native-code)
## Using libraries that include native code
Expo and React Native developers typically spend the vast majority of their time writing JavaScript code and using native APIs and components that are made available through libraries like [`expo-camera`](/versions/latest/sdk/camera/), [`react-native-safe-area-context`](/versions/latest/sdk/safe-area-context/), and `react-native` itself. These libraries allow developers to access and use device features from their JavaScript code. They may also provide access to a third-party service SDK that is implemented in native code (such as [`@sentry/react-native`](/guides/using-sentry/), which provides bindings to the Sentry native SDK for Android and iOS).
Note: Using Expo Go?
---
If you are using the sandbox app, [Expo Go](http://expo.dev/go), [you can only access native libraries that are included in the Expo SDK](/versions/latest/sdk/third-party-overview/), or libraries that do not include any custom native code ([learn more](/workflow/using-libraries/#third-party-libraries)). [Creating a development build](/develop/development-builds/introduction/) allows you to change the native code or configuration as you would in any other native app.
---
### Installing libraries with custom native code in development builds
When using [development builds](/develop/development-builds/introduction/), using libraries with custom native code is straightforward:
- Install the library with npm, for example: `npx expo install react-native-localize`
- If the library includes a [config plugin](/config-plugins/introduction/), you can specify your preferred configuration in your app config.
- Create a new development build (either [locally](/guides/local-app-development/) or with [EAS](/develop/development-builds/create-a-build/)).
You can now use the library in your application code.
Note: Key concepts and development workflow
---
[The development overview](/workflow/overview/) provides details on key concepts for developing an app with Expo and the flow of the core development loop.
---
## Writing native code
Use the [Expo Modules API](/modules/overview/) to write Swift and Kotlin code and add new capabilities to your app with native modules and views. While there are other tools that you can use to build native modules, we believe that using the Expo Modules API makes building and maintaining nearly all kinds of React Native modules about as easy as it can be. We think that the Expo Modules API is the best choice for most developers building native modules for their apps.
Note: When should I consider writing native code?
---
It's common to encounter situations where a library doesn't quite do what you need. For example, the library might not provide access to a specific platform feature, or a third-party service might not provide bindings for React Native.
---
Note: Are you considering writing a module primarily in C++?
---
If you intend to write a native module primarily in C++, you may want to explore the [Turbo Modules API](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/turbo-modules.md) provided by React Native.
---
### Using the Expo Modules API
### Creating a local module
If you intend to use your native module in a single app (you can always change your mind later), we recommend [using a "local" Expo module](/modules/get-started/#creating-the-local-expo-module) to write custom native code. Local Expo Modules function similarly to [Expo Modules](/modules/overview) used by library developers and within the Expo SDK, like `expo-camera`, but they are not published on npm. Instead, you create them directly inside your project.
Creating a local module scaffolds a Swift and Kotlin module inside the `modules` directory in your project, and these modules are automatically linked to your app.
```sh
$ npx create-expo-module@latest --local
$ npx expo run
```
### Sharing a module with multiple apps
If you intend to use your native module with multiple apps, then use `npx create-expo-module@latest,` leave out the `--local` flag, and [create a standalone module](/modules/use-standalone-expo-module-in-your-project/). You can publish your package to npm, or you can put it in a packages directory in your [monorepo](/guides/monorepos/) (if you have one) to use it in [a similar way to local modules](/modules/use-standalone-expo-module-in-your-project/).
## Considerations when using Continuous Native Generation (CNG)
The following suggestions are most important when using [CNG](/workflow/continuous-native-generation/), but are good guidelines even if you don't use it.
Note: Build locally for the best debugging experience and fast feedback
---
By default, Expo projects created with `create-expo-app` use CNG and do not contain **android** or **ios** native directories until you've run the `npx expo prebuild` command in your project. When using CNG, developers typically do not commit the **android** and **ios** directories to source control and do not generate them locally, since EAS Build will do it automatically during the build process. That said, it is common to generate native directories and build locally with `npx expo run` when writing custom native code, to have a fast feedback loop and full access to native debugging tools in Android Studio / Xcode.
---
Note: Use config plugins for native project configuration
---
If your native code requires that you make changes to your project configuration, such as modifying the project's **AndroidManifest.xml** or **Info.plist**, [you should apply these changes through a config plugin](/modules/config-plugin-and-native-module-tutorial/) rather than by modifying the files directly in the **android** and **ios** directories. Remember that changes made directly to native project directories will be lost the next time you run prebuild when you use CNG.
---
Note: Use event subscribers to hook into app lifecycle events
---
If you need to hook into Android lifecycle events or `AppDelegate` methods, use the APIs provided by Expo Modules for [Android](/modules/android-lifecycle-listeners/) and [iOS](/modules/appdelegate-subscribers/) to accomplish this rather than modifying the source files in your native project directories directly or using a config plugin to add the code, which does not compose well with other plugins.
---


## Adopt Prebuild

Learn how to adopt Expo Prebuild in a project that was bootstrapped with React Native CLI.

There are [many advantages](/workflow/prebuild#pitch) of using [Expo Prebuild][prebuild] to [continuously generate your native projects](/workflow/continuous-native-generation). This guide will show you how to adopt Expo Prebuild in a project that was bootstrapped with `npx @react-native-community/cli@latest init`. The amount of time it will take to convert your project depends on the amount of custom native changes that you have made to your Android and iOS native projects. This may take a minute or two on a brand new project, and on a large project, it will be much longer.
Adopting prebuild will automatically add support for developing modules with the [Expo native module API][expo-modules-core] by linking `expo-modules-core` natively. You can also use any command from [Expo CLI][cli] in your project.
> **warning** [Not all versions of `react-native` are explicitly supported](/versions/latest/#each-expo-sdk-version-depends-on-a-react-native-version). Make sure to use a version of `react-native` that has a corresponding Expo SDK version.
## Install the `expo` package
The `expo` package contains the [`npx expo prebuild`](/more/expo-cli/#prebuild) command and indicates which [prebuild template](/workflow/prebuild#templates) to use:
```sh
$ npm install expo
```
Ensure you install the version of `expo` that works for your currently installed [version of `react-native`](/versions/latest/#each-expo-sdk-version-depends-on-a-react-native-version).
## Update the entry file
Modify the entry file to use [`registerRootComponent`](/versions/latest/sdk/expo/#registerrootcomponentcomponent) instead of `AppRegistry.registerComponent`:
```diff
diff --git a/index.js b/index.js
index 0000000..1111111 100644
--- a/index.js
+++ b/index.js
@@ -1,5 +1,4 @@
-import {AppRegistry} from 'react-native';
-import {name as appName} from './app.json';
+import {registerRootComponent} from 'expo';
 import App from './App';
-
-AppRegistry.registerComponent(appName, () => App);
+registerRootComponent(App);
```
> Learn more about [`registerRootComponent`](/versions/latest/sdk/expo/#registerrootcomponentcomponent).
## Prebuild
> **warning** Make sure you have committed your changes in case you want to revert, the command will warn you about this too!
If you're migrating an existing project, then you may want to refer to [**migrating native customizations**](#migrate-native-customizations) first.
Run the following command to regenerate the **android** and **ios** directories based on the app config (**app.json/app.config.js**) configuration:
```sh
$ npx expo prebuild --clean
```
You can test that everything worked by building the projects locally:
```sh
$ npx expo run:android
$ npx expo run:ios
```
> Learn more about [compiling native apps](/more/expo-cli/#compiling).
## Extra changes
The following changes are optional but recommended.
**.gitignore**
You can add **.expo** to your **.gitignore** to prevent generated values from Expo CLI from being committed. These [values are unique to your project](/more/expo-cli/#expo-directory) on your local computer.
The **android** and **ios** directories are automatically added to **.gitignore** when you create a new project, ensuring they are not committed between prebuilds.
**app.json**
Remove all fields that are outside the top-level `expo` object as these will not be used in `npx expo prebuild`.
```diff
diff --git a/app.json b/app.json
index 0000000..1111111 100644
--- a/app.json
+++ b/app.json
@@
-  "name": "myapp",
-  "displayName": "myapp"
+  "expo": {
+    "name": "myapp"
+  }
 }
```
**metro.config.js**
See [Customizing Metro](/guides/customizing-metro/).
**package.json**
You may want to change the scripts to use the [Expo CLI](/more/expo-cli/#compiling) run commands:
```diff
diff --git a/package.json b/package.json
index 0000000..1111111 100644
--- a/package.json
+++ b/package.json
@@
   "scripts": {
     "start": "expo start",
-    "android": "react-native run-android",
-    "ios": "react-native run-ios",
+    "android": "expo run:android",
+    "ios": "expo run:ios",
   },
```
These commands have better logging, auto code signing, better simulator handling, and they ensure you run `npx expo start` to serve files.
## Migrate native customizations
If your project has any native modifications (changes to the **android** or **ios** directories, such as app icon configuration or splash screen) then you'll need to configure your app config (**app.json**) to reflect those native changes.
- Check to see if your changes overlap with the built-in [app config fields](/versions/latest/config/app/). For example, if you have an app icon, be sure to define it as `expo.icon` in the **app.json** then re-run `npx expo prebuild`.
- Look up if any of the packages you are using require an [Expo config plugin][config-plugins]. If a package in your project requires additional changes inside the **android** or **ios** directories, then you will probably need a Config Plugin. Some plugins can be automatically added by running `npx expo install` with all of the packages in your **package.json** dependencies. If a package requires a plugin but doesn't supply one, then you can try checking the community plugins at [`expo/config-plugins`](https://github.com/expo/config-plugins) to see if one already exists.
- You can use the [VS Code Expo extension][vs-code-expo] to introspect your changes and debug if prebuild is generating the native code you expect. Just press <kbd>Cmd ⌘</kbd> + <kbd>Shift</kbd> + <kbd>p</kbd>, type "Expo: Preview Modifier", and select the native file you wish to introspect.
- Additionally, you can develop local config plugins to fit your needs. [Learn more](/config-plugins/development-and-debugging/#develop-a-plugin).
## Add more features
Prebuild is the tip of the automation iceberg, here are some features you can adopt next:
- [EAS Build](/build/setup): Code signing and cloud building.
- [EAS Update](/build/updates): Send over-the-air updates instantly.
- [Expo for web](/workflow/web): Run your app in the browser.
- [Expo Dev Client][dev-client]: Create your own personal "Expo Go" type app around your native runtime.
- [Expo native module API][expo-modules-core]: Write modules with Swift and Kotlin. This is automatically supported when using `npx expo prebuild`.
[vs-code-expo]: https://marketplace.visualstudio.com/items?itemName=expo.vscode-expo-tools
[expo-modules-core]: /modules/module-api/
[dev-client]: /develop/development-builds/introduction/
[config-plugins]: /config-plugins/introduction/
[prebuild]: /workflow/prebuild
[cli]: /more/expo-cli/


# Compile locally

## Compile locally: Overview

An overview on local app compilation process for your Expo apps.

You can leverage your local development environment to compile your app locally by utilizing Android Studio and Xcode. This compilation process can be done for both debug and release builds. This page provides an overview of the local app compilation process and references to other guides that might be necessary in this workflow.
## When to compile your app locally
There are different scenarios when you want to compile your app on your developer machine. It includes:
- You want to iterate quickly on native code changes or test platform-specific changes in your debug build
- You want to manually generate native code to test your debug build
- Any scenario where you are required to create builds inside an environment where access to a network is restricted
- You want to locally manage your own credentials (such as upload key, and so on)
- You want to test or integrate your own custom build cache provider
- You want to opt out of prebuilt Expo Modules for Android and compile them from source locally once
> **Note**: Compiling your app locally complements EAS Build. You can keep using the build service for cloud automation and fall back to local builds for development.
## Prerequisites
You need to install and set up Android Studio and Xcode to compile and run Android and iOS projects on your local machine. See the following guides on how to set up these tools:
- [Android Studio](/get-started/set-up-your-environment/?platform=android&device=physical&mode=development-build&buildEnv=local#set-up-an-android-device-with-a-development-build)
- [Xcode](/get-started/set-up-your-environment/?platform=ios&device=physical&mode=development-build&buildEnv=local#set-up-an-ios-device-with-a-development-build)
## Compiling your debug build
To quickly build and iterate on a debug build, you can use Expo CLI's `npx expo run:[android|ios]` commands. These commands compile your project, using your locally installed Android SDK or Xcode, into a debug build of your app.
## Compiling your release build
To create a release build (also known as production build) of your app, you generate signing credentials by utilizing tools provided by Android Studio and Xcode. Then, you can generate a release build and follow the process of manually submitting your app to Google Play Store or Apple App Store.
## Reuse previous builds from a provider
You can accelerate your local development by caching and reusing builds from a provider. You can use EAS as a build provider or create your own custom provider.
## Prebuilt Expo Modules for Android
SDK 53 and later ship with prebuilt Expo Modules for Android that reduce the work Gradle performs on each build. You can continue using the defaults or selectively opt out when you need to modify a module's source code.


## Local app development

Learn how to compile and build your Expo app locally.

To build your project into an app locally using your machine, you have to manually generate native code before testing the debug build or creating a production build for it to submit to the app store. There are two ways you can build your app locally. This guide provides a brief introduction to both methods and references to other guides that are necessary to create this workflow.
## Prerequisites
You need to install and set up Android Studio and Xcode to compile and run Android and iOS projects on your local machine. See the following on how to set up these tools:
- [Android Studio](/get-started/set-up-your-environment/?platform=android&device=physical&mode=development-build&buildEnv=local#set-up-an-android-device-with-a-development-build)
- [Xcode](/get-started/set-up-your-environment/?platform=ios&device=physical&mode=development-build&buildEnv=local#set-up-an-ios-device-with-a-development-build)
## Local app compilation
To build your project locally you can use compile commands from Expo CLI which generates the **android** and **ios** directories:
```sh
$ npx expo run:android
$ npx expo run:ios
```
The above commands compile your project, using your locally installed Android SDK or Xcode, into a debug build of your app.
- These compilation commands initially run `npx expo prebuild` to generate native directories (**android** and **ios**) before building, if they do not exist yet. If they already exist, this will be skipped.
- You can also add the `--device` flag to select a device to run the app on — you can select a physically connected device or emulator/simulator.
- You can pass in `--variant release` (Android) or `--configuration Release` (iOS) to build a [production build of your app](/deploy/build-project/#production-builds-locally). Note that these builds are not signed and you cannot submit them to app stores. To sign your production build, see [Local app production](/guides/local-app-production/).
- **Android only**: Starting in SDK 54, you can pass the `--variant debugOptimized` variant for faster development iteration. See [Compiling Android in Expo CLI reference](/more/expo-cli/#compiling-android) for more information.
To modify your project's configuration or native code after the first build, you will have to rebuild your project. Running `npx expo prebuild` again layers the changes on top of existing files. It may also produce different results after the build.
To avoid this, the native directories are automatically added to the project's **.gitignore** when you create a new project, and you can use `npx expo prebuild --clean` command. This ensures that the project is always managed, and the [`--clean` flag](/workflow/prebuild/#clean) will delete existing directories before regenerating them. You can use [app config](/workflow/configuration/) or create a [config plugin](/config-plugins/introduction/) to modify your project's configuration or code inside the native directories.
To learn more about how compilation and prebuild works, see the following guides:
## Local builds with `expo-dev-client`
If you install [`expo-dev-client`](/develop/development-builds/introduction/#what-is-expo-dev-client) to your project, then a debug build of your project will include the `expo-dev-client` UI and tooling, and we call these development builds.
```sh
$ npx expo install expo-dev-client
```
To create a development build, you can use [local app compilation](#local-app-compilation) commands (`npx expo run:[android|ios]`) which will create a debug build and start the development server.
## Local builds using Android product flavors
> **warning** This feature is only available for SDK 52 and later.
If you have a custom Android project with multiple product flavors using different application IDs, you can configure `npx expo run:android` to use the correct flavor and build type. Expo supports both `--variant` and `--app-id` to customize the build and launch behavior.
The `--variant` flag can switch the Android build type from **debug** to **release**. This flag can also configure a product flavor and build type, when formatted in camelCase. For example, if you have both [**free** and **paid** product flavors](https://developer.android.com/build/build-variants#change-app-id), you can build a development version of your app with:
```sh
$ npx expo run:android --variant freeDebug
$ npx expo run:android --variant paidDebug
```
The `--app-id` flag can be used to launch the app after building using a customized application id. For example, if your product flavor **free** is using `applicationIdSuffix ".free"` or `applicationId "dev.expo.myapp.free"` you can run build and launch the app with:
```sh
$ npx expo run:android --variant freeDebug --app-id dev.expo.myapp.free
```
> **info** Customizing the Android build type is also possible, but that would break Expo's assumption that the build type **release** is used for production. You might build unoptimized code in your app using a different build type instead of **release**.
## Local builds with EAS


## Create a release build locally

Learn how to create a release (production) build for your Expo app locally.

To create your app's release build (also known as production build) locally, you need to follow separate steps on your computer and use the tools required to create any native app. This guide provides the necessary steps for Android and iOS.
## Android
Creating a release build locally for Android requires signing it with an [upload key](https://developer.android.com/studio/publish/app-signing#certificates-keystores) and generating an Android Application Bundle (**.aab**). Follow the steps below:
### Prerequisites
- [OpenJDK distribution](/get-started/set-up-your-environment/?mode=development-build&buildEnv=local#install-watchman-and-jdk) installed to access the `keytool` command
- **android** directory generated. If you are using [CNG](/workflow/continuous-native-generation/), then run `npx expo prebuild` to generate it.
Step 1: 
### Create an upload key
Note: Already created a build with EAS Build? Download your credentials and skip to the next step.
---
If you've already created a build with EAS Build, follow the steps below to download the credentials, which contains the upload key and its password, key alias, and key password:
1. In your terminal, run `eas credentials -p android` and select the build profile.
2. Select **credentials.json** > **Download credentials from EAS to credentials.json**.
3. Move the downloaded **keystore.jks** file to the **android/app** directory.
4. Copy the values for the upload keystore password, key alias, and key password from the **credentials.json** as you will need them in the next step.
---
Inside your Expo project directory, run the following `keytool` command to create an upload key:
```sh
$ sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```
After running this command, you will be prompted to enter a password for the keystore. This password will protect the upload key. Remember the password you enter here, as you'll need it in the next step.
This command also generates the keystore file named **my-upload-key.keystore** in your project directory. Move it to the **android/app** directory.
> **warning** If you commit the **android** directory to a version control system like Git, don't commit this keystore file. It contains your upload key and should be kept private.
Step 2: 
### Update gradle variables
Open **android/gradle.properties** file and add the following gradle variables at the end of the file. Replace the `*****` with the correct keystore and key password that you provided in the previous step.
These variables contain information about your upload key:
```ruby android/gradle.properties
# If you've downloaded the credentials from `eas credentials` command, see comments below for each value.
MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystore     # Path to the "keystore" file
MYAPP_UPLOAD_KEY_ALIAS=my-key-alias                # Replace with value of the `keystore.keyAlias` field in the credentials.json file
MYAPP_UPLOAD_STORE_PASSWORD=*****                  # Replace with value of the `keystore.password` field in the credentials.json file
MYAPP_UPLOAD_KEY_PASSWORD=*****                    # Replace with value of the `keystore.keyPassword` field in the credentials.json file
```
> **warning** If you commit the **android** directory to a version control system like Git, don't commit the above information. Instead, create a **~/.gradle/gradle.properties** file on your computer and add the above variables to this file.
Step 3: 
### Add signing config to build.gradle
Open **android/app/build.gradle** file and add the following configuration:
<DiffBlock source="/static/diffs/android-release-build.diff" />
Step 4: 
### Generate release Android Application Bundle (aab)
Navigate inside the **android** directory and create a release build in **.aab** format by running Gradle's `bundleRelease` command:
```sh
$ cd android
$ ./gradlew app:bundleRelease
```
This command will generate app-release.aab inside the **android/app/build/outputs/bundle/release** directory.
Step 5: 
### Manual app submission to Google Play Console
Google Play Store requires manual app submission when submitting the **.aab** file for the first time.
## iOS
To create an iOS release build locally for Apple App Store, you need to use Xcode which handles the signing and submission process via App Store Connect.
### Prerequisites
- Paid Apple Developer membership
- [Xcode installed](/get-started/set-up-your-environment/?platform=ios&device=physical&mode=development-build&buildEnv=local#set-up-xcode-and-watchman) on your computer
- **ios** directory generated. If you are using [CNG](/workflow/continuous-native-generation/), then run `npx expo prebuild` to generate it.
Step 1: 
### Open iOS workspace in Xcode
Inside your Expo project directory, run the following command to open `your-project.xcworkspace` in Xcode:
```sh
$ xed ios
```
After opening the iOS project in Xcode:
1. From the sidebar on the left, select your app's workspace.
2. Go to **Signing & Capabilities** and select **All** or **Release**.
3. Under **Signing** > **Team**, ensure your Apple Developer team is selected. Xcode will generate an automatically managed Provisioning Profile and Signing Certificate.
Step 2: 
### Configure a release scheme
To configure your app's release scheme:
1. From the menu bar, open **Product** > **Scheme** > **Edit Scheme**.
2. Select **Run** from the sidebar, then set the **Build configuration** to **Release** using the dropdown.
Step 3: 
### Build app for release
To build your app for release, From the menu bar, open **Product** > **Build**. This step will build your app binary for release.
Step 4: 
### App submission using App Store Connect
Once the build is complete, you can distribute your app to TestFlight or submit it to the App Store using App Store Connect:
1. From the menu bar, open **Product** > **Archive**.
2. Under **Archives**, click **Distribute App** from the right sidebar.
3. Click **App Store Connect** and follow the prompts shown in the window. This step will create an app store record and upload your app to the App Store.
4. Now you can go to your App Store Connect account, select your app under Apps, and submit it for testing using TestFlight or prepare it for final release by following the steps in the App Store Connect dashboard.


## Use build cache providers

Accelerate local development by caching and reusing builds from a provider.

Build caching is a feature that speeds up `npx expo run:[android|ios]` by caching builds remotely, based on the project [fingerprint](/versions/latest/sdk/fingerprint/).
When you run `npx expo run:[android|ios]`, it checks if a build with a matching fingerprint exists, then downloads and launches it rather than compiling it again. Otherwise, the project is compiled as usual and then the resulting binary is uploaded to the remote cache for future runs.
## Using EAS as a build provider
To use the EAS Build provider plugin, start by installing the `eas-build-cache-provider` package as a developer dependency:
For macOS/Linux: 
```sh
$ npx expo install eas-build-cache-provider --dev
```
For Windows: 
```sh
$ npx expo install eas-build-cache-provider "--" --dev
```
Then, update your **app.json** to include the `buildCacheProvider` property and its provider:
```json app.json
{
  "expo": {
    "buildCacheProvider": "eas"
  }
}
```
You can roll your own cache provider by exporting a plugin that implements the following methods:
```ts
type BuildCacheProviderPlugin<T = any> = {
  /**
   * Try to fetch an existing build. Return its URL or null if missing.
   */
  resolveBuildCache(props: ResolveBuildCacheProps, options: T): Promise<string | null>;
  /**
   * Upload a new build binary. Return its URL or null on failure.
   */
  uploadBuildCache(props: UploadBuildCacheProps, options: T): Promise<string | null>;
  /**
   * (Optional) Customize the fingerprint hash algorithm.
   */
  calculateFingerprintHash?: (
    props: CalculateFingerprintHashProps,
    options: T
  ) => Promise<string | null>;
};
type ResolveBuildCacheProps = {
  projectRoot: string;
  platform: 'android' | 'ios';
  runOptions: RunOptions;
  fingerprintHash: string;
};
type UploadBuildCacheProps = {
  projectRoot: string;
  buildPath: string;
  runOptions: RunOptions;
  fingerprintHash: string;
  platform: 'android' | 'ios';
};
type CalculateFingerprintHashProps = {
  projectRoot: string;
  platform: 'android' | 'ios';
  runOptions: RunOptions;
};
```
A reference implementation using GitHub Releases to cache builds can be found in the [Build Cache Provider Example](https://github.com/expo/examples/tree/master/with-github-remote-build-cache-provider).
## Creating a custom build provider
Start by creating a **provider** directory for writing the provider plugin in TypeScript and add a **provider.plugin.js** file in the project root, which will be the plugin's entry point.
Step 1: 
### Create a `provider/tsconfig.json` file
```json provider/tsconfig.json
{
  "extends": "expo-module-scripts/tsconfig.plugin",
  "compilerOptions": {
    "outDir": "build",
    "rootDir": "src"
  },
  "include": ["./src"],
  "exclude": ["**/__mocks__/*", "**/__tests__/*"]
}
```
Step 2: 
### Create a `provider/src/index.ts` file for your plugin
```ts provider/src/index.ts
import { type BuildCacheProviderPlugin } from '@expo/config';
const plugin: BuildCacheProviderPlugin = {
  resolveBuildCache: async () => {
    console.log('Searching for remote builds...');
    return null;
  },
  uploadBuildCache: async () => {
    console.log('Uploading build to remote...');
    return null;
  },
};
export default plugin;
```
Step 3: 
### Create an `provider.plugin.js` file in the root directory
```js provider.plugin.js
// This file configures the entry file for your plugin.
module.exports = require('./provider/build');
```
Step 4: 
### Build your provider plugin
At the root of your project, run `npm run build provider` to start the TypeScript compiler in watch mode.
Step 5: 
### Configure your example project to use your plugin by adding the following line to the `example/app.json` file:
```json example/app.json
{
  "expo": {
    "buildCacheProvider": {
      "plugin": "./provider.plugin.js"
    }
  }
}
```
Step 6: 
### Test your provider
When you run the `npx expo run` command inside your **example** directory, you should see your plugin's console statements in the logs.
```sh
$ cd example
$ npx expo run:android
$ npx expo run:ios
```
That's it! You now have a remote build cache provider to speed up your builds.
### Passing custom options
To inject custom options to your plugin you can use the `options` field and it will be forwarded as the second parameter of your custom functions. To do so modify the `buildCacheProvider` field in **example/app.json** as shown below:
```json example/app.json
{
  "expo": {
    "buildCacheProvider": {
      "plugin": "./provider.plugin.js",
      "options": {
        "myCustomKey": "XXX-XXX-XXX"
      }
    }
  }
}
```


## Prebuilt Expo Modules for Android

Learn how prebuilt Expo Modules reduce Android build times by up to 25% on your machine.

When building React Native apps, longer build times can slow down your development workflow and reduce productivity. Each time you make changes to your code, you might need to wait for the build process to complete, which can add up to significant delays.
**Starting from SDK 53**, Expo introduces prebuilt Expo Modules for Android to address this pain point. Instead of compiling Expo Modules source code from scratch during each build, your project can now use pre-compiled versions of these modules. Ultimately, this results in faster build times.
## Benefits
- **Faster local development**: Up to 25% reduction in Android build times on local machines
- **Improved developer experience**: Less waiting time during development iterations
- **Automatic optimization**: Works out of the box with new projects for SDK 53 and later
## How prebuilt Expo Modules for Android work
During your project's Android build process, look for the `[📦]` emoji prefix next to package names in the build output. This indicates that those packages are using prebuilt versions rather than being compiled from source.
For example, after creating a project with SDK 53's default template, and running the `npx expo run:android` command, you will notice the `[📦 package-name` prefix next to packages that are precompiled:
## Configuration
**For SDK 53 and later, no configuration steps are required for projects** that are created with one of the available [Expo templates](/more/create-expo/#--template).
### Opting out of prebuilt Expo Modules
You can opt out of prebuilt modules. This might be required when you are modifying the module source code yourself. In this scenario, you can configure the Expo Autolinking configuration by adding `buildFromSource` to the **package.json** file:
```json package.json
{
  "name": "your-app-name",
  "expo": {
    "autolinking": {
      "android": {
        "buildFromSource": [
          ".*"
        ]
      }
    }
  }
}
```
### Selectively opt out
You can also opt out of specific modules while keeping others prebuilt by specifying individual package names instead of the wildcard `".*"`:
```json package.json
{
  "name": "your-app-name",
  "expo": {
    "autolinking": {
      "android": {
        "buildFromSource": [
          "expo-camera",
          "expo-web-browser",
          "expo-linking",
        ]
      }
    }
  }
}
```
## Considerations
- Existing projects can benefit from this feature when upgrading to SDK 53 and later
- Performance improvements may vary based on your hardware configuration
- Current improvements on EAS Builds are more modest but provide groundwork for future caching mechanisms


# Web

## Develop websites with Expo

Learn how to develop your app for the web so you can build a universal app.

Expo has first-class support for building full-stack websites with React. Expo websites can be [statically rendered](/router/web/static-rendering) for SEO and performance, or client-rendered for a more app-like experience in the browser.
For Universal: 
    Render text on any platform with the `<Text>` component from [React Native for web](https://github.com/necolas/react-native-web).
    ```jsx app/index.js
    import { Text } from 'react-native';
    export default function Page() {
      return <Text>Home page</Text>;
    }
    ```
    React Native for web (RNW) is a set of component libraries such as `<View>`, and `<Text>`, that wrap `react-dom` primitives such as `<div>`, `<p>`, and `<img>`. RNW is optional when developing for web since you can use React DOM directly, but we often recommended it when building across platforms as it maximizes code reuse.
    > React Native for web is used to power the entire [X](https://x.com/) website.
For Web-only: 
    Alternatively, you can write web-only React DOM components such as `<div>`, `<p>`, and so on, however, these components won't render on native platforms.
    ```jsx app/index.js
    export default function Page() {
      return <p>Home page</p>;
    }
    ```
    Building web-only components is fully supported by Expo, however, you may want to organize your code to better support building for both web and native platforms simultaneously. Learn more in [platform-specific modules](/router/advanced/platform-specific-modules).
All of the libraries in the Expo SDK are built to support both browser and server rendering environments (when applicable). Libraries are also optimized for the individual platforms they target.
Development features like Fast Refresh, debugging, environment variables, and [bundling](/guides/customizing-metro) are also fully universal, enabling a unified developer experience. Expo CLI **automatically optimizes code** for individual platforms when you build for production, using techniques like [platform shaking](/guides/tree-shaking#platform-shaking).
## Getting started
### Install web dependencies
```sh
$ npx expo install react-dom react-native-web @expo/metro-runtime
```
Note: Not using the  package in your app yet?
---
If you haven't added Expo to your React Native app yet, you can either [install Expo modules](/bare/installing-expo-modules/) (recommended) or just install the `expo` package and configure the app entry file. This will allow you to target web, but it will not include support for the Expo SDK.
1. Install [Expo CLI](/more/expo-cli/) in your project:
```sh
$ npm install expo
```
2. Modify the entry file to use [`registerRootComponent`](/versions/latest/sdk/expo/#registerrootcomponentcomponent) instead of `AppRegistry.registerComponent`:
```diff
diff --git a/index.js b/index.js
--- a/index.js
+++ b/index.js
@@ -1,5 +1,4 @@
-import {AppRegistry} from 'react-native';
-import {name as appName} from './app.json';
+import {registerRootComponent} from 'expo';
-AppRegistry.registerComponent(appName, () => App);
+registerRootComponent(App);
```
---
### Start the dev server
You can now start the dev server and develop in the browser with:
```sh
$ npx expo start --web
```
The app can be exported as a production website with:
```sh
$ npx expo export --platform web
```
## Next


## Publish websites

Learn how to deploy Expo websites for production.

An Expo web app can be served locally for testing the production behavior, and deployed to a hosting service. We recommend deploying to [EAS Hosting](/eas/hosting) for the best feature support. You can also self-host or use a third-party service.
> For SDK 49 and earlier, you may need the [guide for publishing `webpack` builds](/archive/publishing-websites-webpack/).
## Output targets
The [`web.output`](/versions/latest/config/app/#output) target can be configured in the [app config](/workflow/configuration/) to set the export method for the web app:
```json app.json
{
  "expo": {
    "web": {
      "output": "server",
      "bundler": "metro"
    }
  }
}
```
Expo Router supports three output targets for web apps.
| Output             | Expo Router | API Routes  | Description                                                                                                                                                                      |
| ------------------ | ----------- | ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `single` (default) | <YesIcon /> | <NoIcon />  | Outputs a Single Page Application (SPA) with a single **index.html** in the output directory and has no statically indexable HTML.                                               |
| `server`           | <YesIcon /> | <YesIcon /> | Creates **client** and **server** directories. Client files are output as separate HTML files. API routes as separate JavaScript files for hosting with a custom Node.js server. |
| `static`           | <YesIcon /> | <NoIcon />  | Outputs separate HTML files for every route in the **app** directory.                                                                                                            |
## Create a build
Creating a build of the project is the first step to publishing a web app. Whether you want to serve it locally or deploy to a hosting service, you'll need to export all JavaScript and assets of a project. This is known as a static bundle. It can be exported by running the following command:
Run the universal export command to compile the project for web:
```sh
$ npx expo export -p web
```
The resulting project files are located in the **dist** directory. Any files inside the **public** directory are also copied to the **dist** directory.
## Serve locally
Use `npx expo serve` to quickly test locally how your website will be hosted in production. Run the following command to serve the static bundle:
```sh
$ npx expo serve
```
Open [`http://localhost:8081`](http://localhost:8081) to see your project in action. This is **HTTP only**, so permissions, camera, location, and many other secure features may not work as expected.
## Hosting with EAS
When you're ready to go to production, you can instantly deploy your website with EAS CLI.
## Hosting on third-party services
### Netlify
[Netlify](https://www.netlify.com/) is a mostly-unopinionated platform for deploying web apps. This has the highest compatibility with Expo web apps as it makes few assumptions about the framework.
#### Manual deployment with the Netlify CDN
Step 1: 
Install the Netlify CLI by running the following command:
```sh
$ npm install -g netlify-cli
```
Step 2: 
Configure redirects for single-page applications.
> If your app uses [static rendering](/router/web/static-rendering), then you can skip this step.
`expo.web.output: 'single'` generates a single-page application. It means there's only one **dist/index.html** file to which all requests must be redirected. This can be done in Netlify by creating a **./public/\_redirects** file and redirecting all requests to **/index.html**.
```sh public/_redirects
/*    /index.html   200
```
If you modify this file, you must rebuild your project with `npx expo export -p web` to have it safely copied into the **dist** directory.
Step 3: 
Deploy the web build directory by running the following command:
```sh
$ netlify deploy --dir dist
```
You'll see a URL that you can use to view your project online.
#### Continuous delivery
Netlify can also build and deploy when you push to git or open a new pull request:
- [Start a new Netlify project](https://app.netlify.com/signup).
- Pick your Git hosting service and select your repository.
- Click **Build your site**.
### Vercel
[Vercel](https://vercel.com/) has a single-command deployment flow.
Step 1: 
Install the [Vercel CLI](https://vercel.com/docs/cli).
```sh
$ npm install -g vercel@latest
```
Step 2: 
  Configure redirects for single-page applications.
Create a **vercel.json** file at the root of your app and add the following configuration:
```json vercel.json
{
  "buildCommand": "expo export -p web",
  "outputDirectory": "dist",
  "devCommand": "expo",
  "cleanUrls": true,
  "framework": null,
  "rewrites": [
    {
      "source": "/:path*",
      "destination": "/"
    }
  ]
}
```
If your app uses [static rendering](/router/web/static-rendering), then you may want to add additional [dynamic route configuration](/router/web/static-rendering#dynamic-routes).
Step 3: 
  Deploy the website.
{' '}
```sh
$ vercel
```
You'll now see a URL that you can use to view your project online. Paste that URL into your browser when the build is complete, and you'll see your deployed app.
### AWS Amplify Console
The [AWS Amplify Console](https://console.amplify.aws) provides a Git-based workflow for continuously deploying and hosting full-stack serverless web apps. Amplify deploys your PWA from a repository instead of from your computer. In this guide, we'll use a GitHub repository. Before starting, [create a new repo on GitHub](https://github.com/new).
Step 1: 
Add the [**amplify-explicit.yml**](https://github.com/expo/amplify-demo/blob/master/amplify-explicit.yml) file to the root of your repository. Ensure you have removed the generated **dist** directory from the **.gitignore** file and committed those changes.
Step 2: 
Push your local Expo project to a GitHub repository. If you haven't pushed to GitHub yet, follow [GitHub's guide to add an existing project to GitHub](https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/adding-locally-hosted-code-to-github).
Step 3: 
Login to the [Amplify Console](https://console.aws.amazon.com/amplify/home) and select an existing app or create a new app. Grant Amplify permission to read from your GitHub account or the organization that owns your repo.
Step 4: 
Add your repo, select the branch, and select **Connecting a monorepo?** to enter the path to your app's **dist** directory and choose **Next**.
The Amplify Console will detect the **amplify.yml** file in your project. Select **Allow AWS Amplify to automatically deploy all files hosted in your project root directory** and choose **Next**.
Step 5: 
Review your settings and choose **Save and deploy**. Your app will now be deployed to a `https://branchname.xxxxxx.amplifyapp.com` URL. You can now visit your web app, deploy another branch, or add a unified backend environment across your Expo mobile and web apps.
Follow the steps in the **Learn how to get the most out of Amplify Hosting** drop-down to **Add a custom domain with a free SSL certificate** and more information.
### Firebase hosting
[Firebase Hosting](https://console.firebase.google.com/) is production-grade web content hosting for web projects.
Step 1: 
Create a firebase project with the [Firebase Console](https://console.firebase.google.com) and install the Firebase CLI by following these [instructions](https://firebase.google.com/docs/hosting).
Step 2: 
Using the CLI, login to your Firebase account by running the command:
```sh
$ firebase login
```
Step 3: 
Then, initialize your firebase project to host by running the command:
```sh
$ firebase init
```
The settings will depend on how you built your Expo website:
1. When asked about the public path, make sure to specify the **dist** directory.
2. When prompted **Configure as a single-page app (rewrite all urls to /index.html)**, only select **Yes** if you used `web.output: "single"` (default). Otherwise, select **No**.
Step 4: 
In the existing `scripts` property of **package.json**, add `predeploy` and `deploy` properties. Each has the following values:
```json package.json
"scripts": {
  "predeploy": "expo export -p web",
  "deploy-hosting": "npm run predeploy && firebase deploy --only hosting",
}
```
Step 5: 
To deploy, run the following command:
```sh
$ npm run deploy-hosting
```
Open the URL from the console output to check your deployment, for example: `https://project-name.firebaseapp.com`.
In case you want to change the header for hosting add the following config for `hosting` section in **firebase.json**:
```json firebase.json
  "hosting": [
    {
      "headers": [
        {
          "source": "/**",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "no-cache, no-store, must-revalidate"
            }
          ]
        },
        {
          "source": "**/*.@(jpg|jpeg|gif|png|svg|webp|js|css|eot|otf|ttf|ttc|woff|woff2|font.css)",
          "headers": [
            {
              "key": "Cache-Control",
              "value": "max-age=604800"
            }
          ]
        }
      ],
    }
  ]
```
### GitHub Pages
[GitHub Pages](https://pages.github.com/) allows you to publish a website directly from a GitHub repository.
> **warning** GitHub Pages deployment uses experimental `baseUrl` functionality that may not work as intended.
Step 1: 
Start by initializing a new git repository in your project and configuring it to push to a GitHub repository. If you are already syncing your changes with a GitHub repository, skip this step.
Create a repository on the GitHub website. Then, run the following commands in your project's root directory:
```sh
$ git init
$ git remote add origin https://github.com/username/expo-gh-pages.git
```
The above commands initialize a new Git repository and configure it to push your source code to the specified GitHub repository.
Step 2: 
Install the `gh-pages` package as a development dependency in your project:
For npm: 
```sh
$ npm install --save-dev gh-pages
```
For Yarn: 
```sh
$ yarn add -D gh-pages
```
Step 3: 
To deploy the project, configure it to a subdomain with the [`baseUrl`](/versions/latest/config/app/#baseurl) property in [app config](/workflow/configuration/). Set its value to the string `/repo-name`.
For example, if the GitHub repository is `expo-gh-pages`, the following will be the value of the [experimental `baseUrl` property](/more/expo-cli/#hosting-with-sub-paths):
```json app.json
{
  "expo": {
    "experiments": {
      "baseUrl": "/expo-gh-pages"
    }
  }
}
```
Step 4: 
Modify the `scripts` in the **package.json** file by adding `predeploy` and `deploy` scripts. Each has its own value:
```json package.json
"scripts": {
  "deploy": "gh-pages --nojekyll -d dist",
  "predeploy": "expo export -p web"
}
```
Since Expo uses underscores in generated files, you need to disable Jekyll with the `--nojekyll` flag.
Step 5: 
To generate a production build of the web app and deploy it to GitHub Pages, run the following command:
For npm: 
```sh
$ npm run deploy
```
For Yarn: 
```sh
$ yarn deploy
```
This publishes a build of the web app to the `gh-pages` branch of your GitHub repository. This branch only contains build artifacts from the **dist** directory, plus the **.nojekyll** file generated by `gh-pages`. It does not include development source code.
Step 6: 
Now that the web app is published to the `gh-pages` branch, configure GitHub Pages to serve the app from that branch.
- Navigate to the **Settings** tab of the GitHub repository.
- Scroll down to **Pages** section.
- Ensure the **Source** is set to **Deploy from a branch**.
- Under **Branch** section, select **gh-pages** and the **root** directory.
- Click **Save**.
Step 7: 
Once the web app is published and the GitHub Pages configuration is set, a GitHub Action will deploy your website. You can monitor its progress by navigating to your repository's **Actions** tab. Upon completion, your web app will be available at the URL `http://username-on-github.github.io/repo-name`.
For subsequent deployments and updates, run the `deploy` command and the GitHub Action will start automatically to update your web app.


## Using React DOM in Expo native apps

Learn about rendering React DOM components in Expo native apps using the 'use dom' directive.

> **info** Available in **SDK 52 and later**.
Expo offers a novel approach to work with modern web code directly in a native app via the `'use dom'` directive. This enables incremental migration for an entire website to a universal app by moving on a per-component basis.
While the Expo native runtime generally does not support elements like `<div>` or `<img>`, there may be instances where you need to quickly incorporate web components. In such cases, DOM components provide a useful solution.
## Prerequisites
Note: Your project must use Expo CLI and extend the Expo Metro Config
---
If you already run your project with `npx expo [command]` (for example, if you created it with `npx create-expo-app`), then you're all set, and you can skip this step.
If you don't have the `expo` package in your project yet, then install it by running the command below and [opt in to using Expo CLI and Metro Config](/bare/installing-expo-modules/#configure-expo-cli-for-bundling-on-android-and-ios):
```sh
$ npx install-expo-modules@latest
```
If the command fails, refer to the [Installing Expo modules](/bare/installing-expo-modules/#manual-installation) guide.
---
Note: Expo Metro Runtime, React DOM, and React Native Web
---
If you are using Expo Router and Expo Web, you can skip this step. Otherwise, install the following packages:
```sh
$ npx expo install @expo/metro-runtime react-dom react-native-web
```
---
## Usage
Install `react-native-webview` in your project:
```sh
$ npx expo install react-native-webview
```
To render a React component to the DOM, add the `'use dom'` directive to the top of the web component file:
```tsx my-component.tsx (web)
'use dom';
export default function DOMComponent({ name }: { name: string }) {
  return (
    <div>
      <h1>Hello, {name}</h1>
    </div>
  );
}
```
Inside the native component file, import the web component to use it:
```tsx App.tsx (native)
import DOMComponent from './my-component.tsx';
export default function App() {
  return (
    // This is a DOM component. It re-exports a wrapped `react-native-webview` behind the scenes.
    <DOMComponent name="Europa" />
  );
}
```
## Features
- Shared bundler config across web, native, and DOM components.
- React, TypeScript, CSS, and all other Metro features are enabled in DOM components.
- Logging in the terminal and Safari/Chrome debugging.
- Fast Refresh and HMR.
- Embedded exports for offline support.
- Assets are unified across web and native.
- DOM component bundles can be introspected in [Expo Atlas](/guides/analyzing-bundles/#analyzing-bundle-size-with-atlas) for debugging.
- Access to all web functionality without needing a native rebuild.
- Runtime error overlay in development.
- Supports Expo Go.
## WebView props
To pass props to the underlying native **WebView**, use the `dom` prop on the component. This prop is built into every DOM component and accepts an object with any [`WebView` props](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md) that you would like to change.
```tsx App.tsx (native)
import DOMComponent from './my-component';
export default function App() {
  return (
    <DOMComponent
      dom={{
        scrollEnabled: false,
      }}
    />
  );
}
```
On your DOM component, add the `dom` prop so it is recognized in TypeScript:
```tsx my-component.tsx (web)
'use dom';
export default function DOMComponent({}: { dom: import('expo/dom').DOMProps }) {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```
## Marshalled props
You can send data to the DOM component through serializable props (`number`, `string`, `boolean`, `null`, `undefined`, `Array`, `Object`). For example, inside a native component file, you can pass a prop to the DOM component:
```tsx App.tsx (native)
import DOMComponent from './my-component';
export default function App() {
  return <DOMComponent hello={'world'} />;
}
```
Inside the web component file, you can receive the prop as shown in the example below:
```tsx my-component.tsx (web)
'use dom';
export default function DOMComponent({ hello }: { hello: string }) {
  return <p>Hello, {hello}</p>;
}
```
Props are sent over an asynchronous bridge so they are not updated synchronously. They are passed as props to the React root component, which means they re-render the entire React tree.
## Native actions
You can send type-safe native functions to DOM components by passing asynchronous functions as top-level props to the DOM component:
```tsx App.tsx (native)
import DomComponent from './my-component';
export default function App() {
  return (
    <DomComponent
      hello={(data: string) => {
        console.log('Hello', data);
      }}
    />
  );
}
```
```tsx my-component.tsx (web)
'use dom';
export default function MyComponent({ hello }: { hello: (data: string) => Promise<void> }) {
  return <p onClick={() => hello('world')}>Click me</p>;
}
```
> You cannot pass functions as nested props to DOM components. They must be top-level props.
Native actions are always asynchronous and accept only serializable arguments (meaning no functions) because the data is sent over a bridge to the DOM component's JavaScript engine.
Native actions can return serializable data to the DOM component, which is useful for getting data back from the native side.
```tsx
getDeviceName(): Promise<string> {
  return DeviceInfo.getDeviceName();
}
```
Think of these functions like React Server Functions, but instead of residing on the server, they live locally in the native app and communicate with the DOM component. This approach provides a powerful way to add truly native functionality to your DOM components.
## Passing refs
> **important** This is in alpha and may change in the future.
You can use the `useDOMImperativeHandle` hook inside a DOM component to accept ref calls from the native side. This hook is similar to React's [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) hook, but it does not need a ref object to be passed to it.
```tsx App.tsx (native)
import { useRef } from 'react';
import { Button, View } from 'react-native';
import MyComponent, { type DOMRef } from './my-component';
export default function App() {
  const ref = useRef<DOMRef>(null);
  return (
    <View style={{ flex: 1 }}>
      <MyComponent ref={ref} />
      <Button
        title="focus"
        onPress={() => {
          ref.current?.focus();
        }}
      />
    </View>
  );
}
```
For SDK 53 and later: 
Expo SDK 53 and later use React 19. This means that the `ref` prop is passed to the component as a prop, and you can use it directly in the component.
```tsx my-component.tsx (web)
'use dom';
import { useDOMImperativeHandle, type DOMImperativeFactory } from 'expo/dom';
import { Ref, useRef } from 'react';
export interface DOMRef extends DOMImperativeFactory {
  focus: () => void;
}
export default function MyComponent(props: {
  ref: Ref<DOMRef>;
  dom?: import('expo/dom').DOMProps;
}) {
  const inputRef = useRef<HTMLInputElement>(null);
  useDOMImperativeHandle(
    props.ref,
    () => ({
      focus: () => {
        inputRef.current?.focus();
      },
    }),
    []
  );
  return <input ref={inputRef} />;
}
```
For SDK 52 and earlier: 
In Expo SDK 52 and earlier (React 18), use the legacy `forwardRef` function to access the `ref` handle.
```tsx my-component.tsx (web)
'use dom';
import { useDOMImperativeHandle, type DOMImperativeFactory } from 'expo/dom';
import { forwardRef, useRef } from 'react';
export interface MyRef extends DOMImperativeFactory {
  focus: () => void;
}
export default forwardRef<MyRef, object>(function MyComponent(props, ref) {
  const inputRef = useRef<HTMLInputElement>(null);
  useDOMImperativeHandle(
    ref,
    () => ({
      focus: () => {
        inputRef.current?.focus();
      },
    }),
    []
  );
  return <input ref={inputRef} />;
});
```
React is meant to have a unilateral data flow, so the concept of using callbacks to go back up the tree is not idiomatic. Expect the behavior to be flakey and possibly phased out in the future with newer versions of React. The preferred way to send data back up the tree is to use native actions, which update the state and then pass it back to the DOM component.
## Feature detection
Since DOM components are used to run websites, you might need extra qualifiers to better support certain libraries. You can detect if a component is running in a DOM component with the following code:
```ts
import { IS_DOM } from 'expo/dom';
```
While `process.env.EXPO_OS` will always be web in a DOM component, you can detect the _top_ platform with `process.env.EXPO_DOM_HOST_OS`. This will be either `ios`, `android`, depending on the OS of the top-most native platform, and `undefined` on web.
## Public assets
> **important** **Warning:** This is in alpha and may change in the future. Public assets are not supported in EAS Update. Use `require()` to load local assets instead.
The contents of the root **public** directory are copied to the native app's binary to support the use of public assets in DOM components. Since these public assets will be served from the local filesystem, use the `process.env.EXPO_BASE_URL` prefix to reference the correct path. For example:
```tsx
<img src={`${process.env.EXPO_BASE_URL}img.png`} />
```
## Debugging
By default, all `console.log` methods are extended in WebViews to forward logs to the terminal. This makes it fast and easy to see what's happening in your DOM components.
Expo also enables WebView inspection and debugging when bundling in development mode. You can open **Safari** > **Develop** > **Simulator** > **MyComponent.tsx** to see the WebView's console and inspect elements.
## Manual WebViews
You can create a manual WebView using the `WebView` component from `react-native-webview`. This can be useful for rendering websites from a remote server.
```tsx App.tsx (native)
import { WebView } from 'react-native-webview';
export default function App() {
  return <WebView source={{ html: '<h1>Hello, world!</h1>' }} />;
}
```
## Routing
Expo Router APIs such as `<Link />`, and `useRouter` can be used in DOM components to navigate between routes.
```tsx my-component.tsx (web)
'use dom';
import Link from 'expo-router/link';
export default function DOMComponent() {
  return (
    <div>
      <h1>Hello, world!</h1>
      <Link href="/about">About</Link>
    </div>
  );
}
```
APIs that synchronously return routing info such as `useLocalSearchParams()`, `useGlobalSearchParams()`, `usePathname()`, `useSegments()`, `useRootNavigation()`, and `useRootNavigationState()` are not automatically supported. Instead, read these values outside of DOM components and supply them as props.
```tsx App.tsx (native)
import DOMComponent from './my-component';
import { usePathname } from 'expo-router';
export default function App() {
  const pathname = usePathname();
  return <DOMComponent pathname={pathname} />;
}
```
The `router.canGoBack()` and `router.canDismiss()` functions are also unsupported and require manual marshalling, this ensures no extraneous render cycles are triggered.
Avoid using standard web `<a />` anchor elements for navigation as these will change the DOM component origin in a way that users may not be able to navigate back from. Prefer launching `WebBrowser`s if you want to present external websites.
Since DOM components cannot render native children, layout routes (`_layout`) can never be DOM components. You can render DOM components from layout routes to create headers, backgrounds, and more, but the layout route itself should always be native.
## Measuring DOM components
You may want to measure the size of a DOM component and report it back to the native side (for example, native scrolling). This can be done using a `matchContents` prop or a manual native action:
### Automatically with `matchContents` prop
You can use the `dom={{ matchContents: true }}` prop to measure the size of the DOM component automatically and resize the native view. This is particularly useful for certain layouts where the DOM component must have an intrinsic size in order to be displayed, such as when the component is centered within a parent view:
```tsx App.tsx (native)
import DOMComponent from './my-component';
export default function Route() {
  return <DOMComponent dom={{ matchContents: true }} />;
}
```
### Manually by specifying a size
You can also manually provide a size by passing it to the `WebView` `style` prop via the `dom` prop:
```tsx App.tsx (native)
import DOMComponent from './my-component';
export default function Route() {
  return (
    <DOMComponent
      dom={{
        style: { width, height },
      }}
    />
  );
}
```
### Observing changes in size
If you would like to report changes in the size of the DOM component back to the native side, you can add a native action to your DOM component that is called whenever the size is changed:
```tsx my-component.tsx (web)
'use dom';
import { useEffect } from 'react';
function useSize(callback: (size: { width: number; height: number }) => void) {
  useEffect(() => {
    // Observe window size changes
    const observer = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        callback({ width, height });
      }
    });
    observer.observe(document.body);
    callback({
      width: document.body.clientWidth,
      height: document.body.clientHeight,
    });
    return () => {
      observer.disconnect();
    };
  }, [callback]);
}
export default function DOMComponent({
  onDOMLayout,
}: {
  dom?: import('expo/dom').DOMProps;
  onDOMLayout: (size: { width: number; height: number }) => void;
}) {
  useSize(onDOMLayout);
  return <div style={{ width: 500, height: 500, background: 'blue' }} />;
}
```
Then update your native code to set the size in state whenever the DOM component reports a change in size:
```tsx App.tsx (native)
import DOMComponent from '@/components/my-component';
import { useState } from 'react';
import { View, ScrollView } from 'react-native';
export default function App() {
  const [containerSize, setContainerSize] = useState<{
    width: number;
    height: number;
  } | null>(null);
  return (
    <View style={{ flex: 1 }}>
      <ScrollView>
        <DOMComponent
          onDOMLayout={async ({ width, height }) => {
            if (containerSize?.width !== width || containerSize?.height !== height) {
              setContainerSize({ width, height });
            }
          }}
          dom={{
            containerStyle:
              containerSize != null
                ? { width: containerSize.width, height: containerSize.height }
                : null,
          }}
        />
      </ScrollView>
    </View>
  );
}
```
## Architecture
Built-in DOM support only renders websites as single-page applications (no SSR or SSG). This is because search engine optimization and indexing are unnecessary for embedded JS code.
When a module is marked with `'use dom'`, it is replaced with a proxy reference imported at runtime. This feature is primarily achieved through a series of bundler and CLI techniques.
If desired, you can still use a WebView with the standard approach by passing raw HTML to a `WebView` component.
DOM components rendered within websites or other DOM components will behave as regular components, and the `dom` prop will be ignored. This is because web content is passed directly through and not wrapped in an `iframe`.
Overall, this system shares many similarities with Expo's React Server Components implementation.
## Considerations
We recommend building truly native apps using universal primitives such as `View`, `Image`, and `Text`. DOM components only support standard JavaScript, which is slower to parse and start up than optimized Hermes bytecode.
Data can be sent between DOM components and native components only through an asynchronous JSON transport system. Avoid relying on data across JS engines and deep linking to nested URLs in DOM components, as they do not currently support full reconciliation with Expo Router.
While DOM components are not exclusive to Expo Router, they are developed and tested against Expo Router apps to provide the best experience when used with Expo Router.
If you have a global state for sharing data, it will not be accessible across JS engines.
While native modules in the Expo SDK can be optimized to support DOM components, this optimization has not been implemented yet. Use native actions and props to share native functionality with DOM components.
DOM components and websites in general are less optimal than native views but there are some reasonable uses for them. For example, the web is conceptually the best way to render rich-text and markdown. The web also has very good WebGL support, with the caveat that devices in low-power mode will often throttle web frame rates to preserve battery.
Many large apps also use some web content for auxiliary routes such as blog posts, rich-text (for example, long-form posts on X), settings pages, help pages, and other less frequently visited parts of the app.
## Server Components
DOM components currently only render as single-page applications and don't support static rendering or React Server Components (RSC). When the project uses React Server Components, `'use dom'` will work the same as `'use client'` regardless of the platform. RSC Payloads can be passed as properties to DOM components. However, they cannot be hydrated correctly on native platforms as they'll be rendered for a native runtime.
## Limitations
- Unlike server components, you cannot pass `children` to DOM components.
- DOM components are standalone and do not automatically share data between different instances.
- You cannot add native views to DOM components. While you can attempt to float native views over DOM components, this approach results in a suboptimal user experience.
- Function props cannot return values synchronously. They must be asynchronous.
- DOM components can currently only be embedded and do not support OTA updates. This functionality may be added in the future as part of React Server Components.
Ultimately, universal architecture is the most exciting kind. Expo CLI's extensive universal tooling is the only reason we can even offer a feature as intricate and valuable as this one.
While DOM components help with migration and moving quickly, we recommend using truly native views whenever possible.
## Common questions
### How to obtain a Secure Context in DOM components?
Some Web APIs require a [Secure Context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts) function correctly. For example, the [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API) is only available in secure contexts. A secure context means that remote resources must be served over HTTPS. [Learn more about features restricted to secure contexts](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts/features_restricted_to_secure_contexts).
To ensure your DOM components run within a secure context, follow these guidelines:
- **Release builds**: DOM components served using the `file://` scheme are provided a secure context by default.
- **Debug builds**: When using development servers (which default to the `http:// `protocol), you can use [tunneling](/more/expo-cli/#tunneling) to serve DOM components over HTTPS.
Note: Example commands to tunnel DOM components over HTTPS
---
```sh
$ npx expo install expo-dev-client
$ npx expo run:android
$ npx expo start --tunnel -d -a
$ npx expo run:ios
$ npx expo start --tunnel -d -i
```
---


## Progressive web apps

Learn how to add progressive web app support to Expo websites.

A progressive web app (or PWA for short) is a website that can be installed on the user's device and used offline. We recommend building native apps whenever possible as they have the best offline support, but PWAs are a great option for desktop users.
## Favicons
Expo CLI automatically generates the **favicon.ico** file based on the `web.favicon` field in the **app.json**.
```json
{
  "web": {
    "favicon": "./assets/favicon.png"
  }
}
```
Alternatively, you can create a **favicon.ico** file in the **public** directory to manually specify the icon.
## Manifest file
PWAs can be [configured with a manifest file](https://developer.mozilla.org/en-US/docs/Web/Manifest) that describes the app's name, icon, and other metadata.
Step 1: 
Create a PWA manifest in **public/manifest.json**:
```json
{
  "short_name": "Expo App",
  "name": "Expo Router Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
```
Step 2: 
The files **logo192.png** and **logo512.png** are the icons that will be used when the app is installed on the user's device. These should be added to the **public** directory too.
```
└── public/
    ├── manifest.json  # PWA Manifest
    ├── logo192.png  # 192x192 icon
    └── logo512.png  # 512x512 icon
```
Step 3: 
Now link the manifest in your HTML file. The method here depends on the output mode of your website (indicated in `web.output` in the **app.json**––defaults to `single`).
For single: 
If you're using a single-page app, you can link the manifest in your HTML file by first creating a template HTML in **public/index.html**:
```sh
$ npx expo customize public/index.html
```
Then add the manifest to the `<head>` tag:
```html
<link rel="manifest" href="/manifest.json" />
```
For static & server: 
If you're using static or server rendering, the HTML entry can be dynamically created in **app/+html.tsx**. Here we'll link the manifest by adding a `<link>` tag to the `<head>` component:
```tsx app/+html.tsx
import { ScrollViewStyleReset } from 'expo-router/html';
import type { PropsWithChildren } from 'react';
// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        {/* Link the PWA manifest file. */}
        <link rel="manifest" href="/manifest.json" />
        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
```
## Service workers
Service workers are primarily used to add offline support to websites. Google's Workbox is the best way to add service workers to a website. Follow the guide for [using Workbox CLI](https://developer.chrome.com/docs/workbox/modules/workbox-cli/), and wherever it refers to a "build script" use `npx expo export -p web` instead.
> **warning** Be careful adding service workers as they are known to cause unexpected behavior on web. If you accidentally ship a service worker that aggressively caches your website, users cannot request updates easily. For the best offline mobile experience, create a native app with Expo. Unlike websites with service workers, native apps can be updated through the app store to clear the cached experience. This would be similar to resetting the user's native browser (which they may have to do if the service worker is aggressive enough). See [why service workers are suboptimal](https://github.com/facebook/create-react-app/issues/2398) for more information.
For example, here's a possible flow for setting up Workbox:
Step 1: 
Create a new project with the following command:
```sh
$ npm create expo -t tabs my-app
$ cd my-app
```
Step 2: 
Now register the service worker in the HTML file. The method here depends on the output mode of your website (indicated in `web.output` in the **app.json**––defaults to `single`).
For single: 
Next add a service worker registration script to the root **index.html**.
First create a template HTML in **public/index.html** if one does not already exist:
```sh
$ npx expo customize public/index.html
```
Then create the service worker registration script in the `<head>` tag:
```html
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker
        .register('/sw.js')
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service Worker registration failed:', error);
        });
    });
  }
</script>
```
For static & server: 
Next, create a root HTML file for the app and add the service worker registration script:
```tsx app/+html.tsx
import { ScrollViewStyleReset } from 'expo-router/html';
import type { PropsWithChildren } from 'react';
// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        {/* Bootstrap the service worker. */}
        <script dangerouslySetInnerHTML={{ __html: sw }} />
        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
const sw = `
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
        }).catch(error => {
            console.error('Service Worker registration failed:', error);
        });
    });
}
`;
```
Step 3: 
Now build the website before running the wizard:
```sh
$ npx expo export -p web
```
Step 4: 
Run the wizard command, select `dist` as the root of the app, and the defaults for everything else:
```sh
$ npx workbox-cli wizard
? What is the root of your web app (that is which directory do you deploy)? dist/
? Which file types would you like to precache? js
html
ttf
ico
json
? Where would you like your service worker file to be saved? dist/sw.js
? Where would you like to save these configuration options? workbox-config.js
? Does your web app manifest include search parameter(s) in the 'start_url
other than 'utm_' or 'fbclid' (like '?source=pwa')? No
```
Step 5: 
Finally, run `npx workbox-cli generateSW workbox-config.js` to generate the service worker config.
Going forward, you can add a build script in **package.json** to run both scripts in the correct order:
```json package.json
{
  "scripts": {
    "build:web": "expo export -p web && npx workbox-cli generateSW workbox-config.js"
  }
}
```
Step 6: 
If you host your website and visit with Chrome, you can inspect the service worker by going to **Application > Service Workers** in the Chrome DevTools.


## Tailwind CSS

Learn how to configure and use Tailwind CSS in your Expo project.

> **info** Standard Tailwind CSS supports only web platform. For universal support, use a library such as [NativeWind](https://www.nativewind.dev/), which allows creating styled React Native components with Tailwind CSS.
[Tailwind CSS](https://tailwindcss.com/) is a utility-first CSS framework and can be used with Metro for web projects. This guide explains how to configure your Expo project to use the framework.
## Prerequisites
The following files will be modified to set the Tailwind CSS configuration:
```
├── app.json
├── package.json
├── global.css
└── index.js
```
Ensure that your project is using Metro for web. You can verify this by checking the `web.bundler` field which is set to `metro` in the **app.json** file.
```json app.json
{
  "expo": {
    "web": {
      "bundler": "metro"
    }
  }
}
```
## Configuration
Configure Tailwind CSS in your Expo project according to the [Tailwind PostCSS documentation](https://tailwindcss.com/docs/installation/using-postcss).
For v3: 
Step 1: 
Install `tailwindcss` and its required peer dependencies. Then, the run initialization command to create **tailwind.config.js** and **post.config.js** files in the root of your project.
```sh
$ npx expo install tailwindcss@3 postcss autoprefixer --dev
$ npx tailwindcss init -p
```
Step 2: 
Add paths to all of your template files inside **tailwind.config.js**.
```js tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    // Ensure this points to your source code
    './app/**/*.{js,tsx,ts,jsx}',
    // If you use a `src` directory, add: './src/**/*.{js,tsx,ts,jsx}'
    // Do the same with `components`, `hooks`, `styles`, or any other top-level directories
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```
> If you are using Expo Router, consider using a root **src** directory to simplify this step. Learn more about [top-level src directory](/router/reference/src-directory/).
Step 3: 
Create a **global.css** file in the root of your project and directives for each of Tailwind's layers:
```css global.css
/* This file adds the requisite utility classes for Tailwind to work. */
@tailwind base;
@tailwind components;
@tailwind utilities;
```
Step 4: 
Import the **global.css** file in your **app/\_layout.tsx** (if using Expo Router) or **index.js** file:
```tsx
import '../global.css';
```
```tsx
// Import the global.css file in the index.js file:
import './global.css';
```
> **info** If you are using [DOM components](/guides/dom-components), add this file import to each module using the `"use dom"` directive since they don't share globals.
Step 5: 
You now start your project and use Tailwind CSS classes in your components.
```sh
$ npx expo start
```
For v4: 
Step 1: 
Install `tailwindcss` and its required peer dependencies:
```sh
$ npx expo install tailwindcss @tailwindcss/postcss postcss --dev
```
Step 2: 
Add Tailwind to your PostCSS configuration
```js postcss.config.mjs
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
```
Step 3: 
Create a global CSS file that imports Tailwind CSS.
You can choose any name for this file. Using **global.css** is common practice.
```css global.css
@import 'tailwindcss';
```
Step 4: 
Import your CSS file in your **app/\_layout.tsx** (if using Expo Router) or **index.js** file:
```tsx
// If using Expo Router, import your CSS file in the app/_layout.tsx file
import '../global.css';
```
```tsx
// Otherwise import your CSS file in the index.js file:
import './global.css';
```
> **info** If you are using [DOM components](/guides/dom-components), add this file import to each module using the `"use dom"` directive since they don't share globals.
Step 5: 
You now start your project and use Tailwind CSS classes in your components.
```sh
$ npx expo start
```
## Usage
You can use Tailwind with React DOM elements as-is:
```tsx app/index.tsx
export default function Index() {
  return (
    <div className="bg-slate-100 rounded-xl">
      <p className="text-lg font-medium">Welcome to Tailwind</p>
    </div>
  );
}
```
You can use the `{ $$css: true }` syntax to use Tailwind with React Native web elements:
```tsx app/index.tsx
import { View, Text } from 'react-native';
export default function Index() {
  return (
    <View style={{ $$css: true, _: 'bg-slate-100 rounded-xl' }}>
      <Text style={{ $$css: true, _: 'text-lg font-medium' }}>Welcome to Tailwind</Text>
    </View>
  );
}
```
## Tailwind for Android and iOS
Tailwind does not support Android and iOS platforms. You can use a compatibility library such as [NativeWind](https://www.nativewind.dev/) for universal support.
## Alternative for Android and iOS
Alternatively, you can use [DOM components](/guides/dom-components) to render your Tailwind web code in a `WebView` on native.
```tsx app/index.tsx
'use dom';
// Remember to import the global.css file in each DOM component.
import '../global.css';
export default function Page() {
  return (
    <div className="bg-slate-100 rounded-xl">
      <p className="text-lg font-medium">Welcome to Tailwind</p>
    </div>
  );
}
```
## Troubleshooting
If you have a custom `config.cacheStores` in your **metro.config.js**, you need to extend the Expo superclass of `FileStore`:
```js metro.config.js
// Import the Expo superclass which has support for PostCSS.
const { FileStore } = require('@expo/metro-config/file-store');
config.cacheStores = [
  new FileStore({
    root: '/path/to/custom/cache',
  }),
];
module.exports = config;
```
Ensure you don't have CSS disabled in your **metro.config.js**:
```js metro.config.js
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname, {
  // Do not disable CSS support when using Tailwind.
  isCSSEnabled: true,
});
```


## Using local HTTPS development

Learn how to set up local HTTPS for Expo web apps.

When developing Expo web apps locally, you may need to use HTTPS with your local development environment for testing secure browser APIs. This guide shows you how to set up local HTTPS for Expo web apps.
## Prerequisites
This guide requires the following tool installed on your machine:
- `mkcert`: A tool for creating development certificates. For installation instructions, see the [`mkcert` GitHub repository](https://github.com/FiloSottile/mkcert#installation).
## Benefits
- **Team scalability**: Same setup works for everyone
- **Authentication support**: HTTP-Only Cookies and secure contexts
- **Production parity**: Match your production HTTPS environment
- **Easy sharing**: Consistent development URLs across the team
## Set up your project
Step 1: 
Create or navigate to your Expo project:
```sh
$ npx create-expo-app@latest example-app
$ cd example-app
$ cd your-expo-project
```
Step 2: 
Start your Expo development server:
```sh
$ npx expo start --web
```
Your app will be running on `http://localhost:8081`. Keep this terminal window open.
Step 3: 
Use `mkcert` to generate a certificate for localhost. Run the following command in a new terminal window from your project's root directory:
```sh
$ mkcert localhost
```
> **info** **Tip**: Ensure that after installing `mkcert`, you run `mkcert -install` to install the local certificate authority (CA).
This will generate two signed certificate files: `localhost.pem` (certificate) and `localhost-key.pem` (private key), inside your project's root directory.
Step 4: 
Inside your project's root directory, run the following command to start the proxy:
```sh
$ npx local-ssl-proxy --source 443 --target 8081 --cert localhost.pem --key localhost-key.pem
```
> **info** **Tip**: [`local-ssl-proxy`](https://github.com/cameronhunter/local-ssl-proxy) is a tool that creates a proxy server that forwards HTTPS traffic from port 443 to your Expo dev server on port 8081.
This creates a proxy that forwards HTTPS traffic from port 443 to your Expo dev server on port 8081.
Step 5: 
Open `https://localhost` in your browser to access your app. Your Expo app is now running with HTTPS.


# Bundling

## Metro bundler

Learn about different Metro bundler configurations that can be customized.

Expo CLI uses [Metro](https://metrobundler.dev/) during [`npx expo start`](/more/expo-cli/#develop) and [`npx expo export`](/more/expo-cli/#exporting) to bundle your JavaScript code and assets. Metro is built and optimized for React Native and used for large-scale applications such as Facebook and Instagram.
## Customizing
You can customize the Metro bundler by creating a **metro.config.js** file at the root of your project. This file should export a [Metro configuration](https://metrobundler.dev/docs/configuration/) that extends [`expo/metro-config`](https://github.com/expo/expo/tree/main/packages/@expo/metro-config). Import `expo/metro-config` instead of `@expo/metro-config` to ensure version consistency.
Run the following command to generate the template file:
```sh
$ npx expo customize metro.config.js
```
The **metro.config.js** file looks as below:
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
module.exports = config;
```
See [**metro.config.js** documentation](https://metrobundler.dev/docs/configuration/) for more information.
## Assets
Metro resolves files as either source code or assets. Source code is JavaScript, TypeScript, JSON, and other files used by your application. [Assets](/develop/user-interface/assets/) are images, fonts, and other files that should not be transformed by Metro. To accommodate large-scale codebases, Metro requires all extensions for both source code and assets to be explicitly defined before starting the bundler. This is done by adding the `resolver.sourceExts` and `resolver.assetExts` options to the Metro configuration. By default, the following extensions are included:
- [`resolver.assetExts`](https://github.com/facebook/metro/blob/7028b7f51074f9ceef22258a8643d0f90de2388b/packages/metro-config/src/defaults/defaults.js#L15)
- [`resolver.sourceExts`](https://github.com/facebook/metro/blob/7028b7f51074f9ceef22258a8643d0f90de2388b/packages/metro-config/src/defaults/defaults.js#L53)
### Adding more file extensions to `assetExts`
The most common customization is to include extra asset extensions to Metro.
In the **metro.config.js** file, add the file extension (without a leading `.`) to `resolver.assetExts` array:
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.resolver.assetExts.push(
  // Adds support for `.db` files for SQLite databases
  'db'
);
module.exports = config;
```
## Aliases
Sometimes you want an import to be redirected to another module or file. This is called an alias. Due to the way Metro bundles for multiple platforms simultaneously, we recommend using a custom resolver to handle aliases.
In the following example, we'll add an alias for `old-module` to `new-module`:
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);
const ALIASES = {
  'old-module': 'new-module',
};
config.resolver.resolveRequest = (context, moduleName, platform) => {
  // Ensure you call the default resolver.
  return context.resolveRequest(
    context,
    // Use an alias if one exists.
    ALIASES[moduleName] ?? moduleName,
    platform
  );
};
module.exports = config;
```
If you want to only apply the alias on a certain platform, you can check the `platform` argument:
```js metro.config.js
config.resolver.resolveRequest = (context, moduleName, platform) => {
  if (platform === 'web') {
    // The alias will only be used when bundling for the web.
    return context.resolveRequest(context, ALIASES[moduleName] ?? moduleName, platform);
  }
  // Ensure you call the default resolver.
  return context.resolveRequest(context, moduleName, platform);
};
```
You will see the changes the next time you restart the dev server. Resolutions are never cached and do not need the `--clear` flag to update. If you use a transform-based system like `babel-plugin-module-resolver`, you will need to clear the cache to see changes applied.
## Bundle splitting
Expo CLI automatically splits bundles based on async imports (web-only).
This technique can be used with Expo Router to automatically split the bundle based on route files in the **app** directory. It will only load the code required for the current route, and defer loading additional JavaScript until the user navigates to different pages. See [Async Routes](/router/web/async-routes) for more information.
## Tree shaking
## Minification
## Web support
Expo CLI has support for bundling websites using Metro. This is the same bundler used for native apps, and it is designed to be universal across platforms. It is the recommended bundler for web projects.
### Expo webpack versus Expo Metro
If you previously wrote your website using the deprecated `@expo/webpack-adapter`, see the [migration guide](/router/migrate/from-expo-webpack) and [comparison chart](/router/migrate/from-expo-webpack#expo-cli).
### Adding Web support to Metro
Modify your [app config](/workflow/configuration) to enable the feature using the `expo.web.bundler` field:
```json app.json
{
  "expo": {
    "web": {
      "bundler": "metro"
    }
  }
}
```
#### Development
To start the development server run the following command:
```sh
$ npx expo start --web
```
Alternatively, press <kbd>W</kbd> in the Expo CLI terminal UI.
#### Static files
Expo's Metro implementation supports hosting static files from the dev server by putting them in the root **public/** directory. It is similar to many other web frameworks.
When exporting with `npx expo export`, the contents of the **public** directory are copied into the **dist/** directory. It means your app can expect to fetch these assets relative to the host URL. The most common example of this is the **public/favicon.ico** which is used by websites to render the tab icon.
You can overwrite the default **index.html** in Metro web by creating a **public/index.html** file in your project.
In the future, this will work universally across platforms with EAS Update hosting. Currently, the feature is web-only based on the static host used for the native app, for example, the legacy Expo service updates do not support this feature.
## TypeScript
Expo's Metro config supports the `compilerOptions.paths` and `compilerOptions.baseUrl` fields in the project's **tsconfig.json** (or **jsconfig.json**) file. This enables absolute imports and aliases in the project. See [TypeScript](/guides/typescript) guide for more information.
This feature requires additional setup in bare projects. See the [Metro setup guide](/versions/latest/config/metro#bare-workflow-setup) for more information.
## CSS


## Analyzing JavaScript bundles with Expo Atlas and Lighthouse

Learn about improving the production JavaScript bundle size of Expo apps and websites with Expo Atlas and Lighthouse.

Bundle performance varies for different platforms. For example, web browsers don't support precompiled bytecode, so the JavaScript bundle size is important for improving startup time and performance. The smaller the bundle, the faster it can be downloaded and parsed.
## Analyzing bundle size with Expo Atlas
The libraries used in a project influence the size of the production JavaScript bundle. You can use [Expo Atlas](https://github.com/expo/expo-atlas#readme) to visualize the production bundle and identify which libraries contribute to the bundle size.
### Using Atlas with `npx expo start`
You can use Expo Atlas with the local development server. This method allows Atlas to update whenever you change any code in your project.
Once your app is running using the local development server on Android, iOS, and/or web, you can open Atlas through the [dev tools plugin menu](/debugging/devtools-plugins/#using-a-dev-tools-plugin) using <kbd>shift</kbd> + <kbd>m</kbd>.
```sh
$ EXPO_ATLAS=true npx expo start
```
#### Changing development mode to production
By default, Expo starts the local development server in [development mode](/workflow/development-mode/#development-mode). Development mode disables some optimizations that are enabled in [production mode](/workflow/development-mode/#production-mode). You can also start the local development server in production mode to get a more accurate representation of the production bundle size:
```sh
$ EXPO_ATLAS=true npx expo start --no-dev
```
### Using Expo Atlas with `npx expo export`
You can also use Expo Atlas when generating a production bundle for your app or EAS Update. Atlas generates a **.expo/atlas.jsonl** file during export, which you can share and open without having access to the project.
```sh
$ EXPO_ATLAS=true npx expo export
$ npx expo-atlas .expo/atlas.jsonl
```
You can also specify the platforms you want to analyze using the `--platform` option. Expo Atlas will gather the data for the exported platforms only.
### Analyzing transformed modules
Inside Atlas, you can hold <kbd>⌘ Cmd</kbd> and click on a graph node to see the transformed module details. This feature helps you understand how a module is transformed by Babel, which modules it imports, and which modules imported it. This can be used to trace the origin of a module across the dependency graph.
## Analyzing bundle size with source-map-explorer
> Alternative method for **SDK 50 and earlier**.
If you are using SDK 50 or below, you can use the [`source-map-explorer`](https://www.npmjs.com/package/source-map-explorer) library to visualize and analyze the production JavaScript bundle.
Step 1: 
To use source map explorer, run the following command to install it:
```sh
$ npm i --save-dev source-map-explorer
```
Step 2: 
Add a script to **package.json** to run it. You might have to adjust the input path depending on the platform or SDK you are using. For brevity, the following example assumes the project is Expo SDK 50 and does not use Expo Router `server` output.
```json package.json
{
  "scripts": {
    "analyze:web": "source-map-explorer 'dist/_expo/static/js/web/*.js' 'dist/_expo/static/js/web/*.js.map'",
    "analyze:ios": "source-map-explorer 'dist/_expo/static/js/ios/*.js' 'dist/_expo/static/js/ios/*.js.map'",
    "analyze:android": "source-map-explorer 'dist/_expo/static/js/android/*.js' 'dist/_expo/static/js/android/*.js.map'"
  }
}
```
If you are using the SDK 50 `server` output for web, then use the following to map web bundles:
```sh
$ npx source-map-explorer 'dist/client/_expo/static/js/web/*.js' 'dist/client/_expo/static/js/web/*.js.map'
```
Web bundles are output to the **dist/client** subdirectory to prevent exposing server code to the client.
Step 3: 
Export your production JavaScript bundle and include the `--source-maps` flag so that the source map explorer can read the source maps. For native apps using Hermes, you can use the `--no-bytecode` option to disable bytecode generation.
```sh
$ npx expo export --source-maps --platform web
$ npx expo export --source-maps --platform ios --no-bytecode
```
This command shows the JavaScript bundle and source map paths in the output. In the next step, you will pass these paths to the source map explorer.
> Avoid publishing source maps to production as they can cause both security issues and performance issues (a browser will download the large maps).
Step 4: 
Run the script to analyze your bundle:
```sh
$ npm run analyze:web
```
On running this command, you might see the following error:
```text
You must provide the URL of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer
```
This is probably due to a [known issue](https://github.com/danvk/source-map-explorer/issues/247) in `source-map-explorer` in Node.js 18 and above. To resolve this, set the environment variable `NODE_OPTIONS=--no-experimental-fetch` before running the analyze script.
You might encounter a warning such as `Unable to map 809/13787 bytes (5.87%)`. This occurs because source maps often exclude bundler runtime definitions (for example, `__d(() => {}, [])`). This value is consistent and not a reason for concern.
## Lighthouse
Lighthouse is a great way to see how fast, accessible, and performant your website is. You can test your project with the **Audit** tab in Chrome, or with the [Lighthouse CLI](https://github.com/GoogleChrome/lighthouse#using-the-node-cli).
After creating a production build with `npx expo export -p web` and serving it (using either `npx serve dist`, or production deployment, or custom server), run Lighthouse with the URL your site is hosted at.
```sh
$ npm install -g lighthouse
$ npx lighthouse <url> --view
```


## Tree shaking and code removal

Learn about how Expo CLI optimizes production JavaScript bundles.

Tree shaking (also referred to as _dead code removal_) is a technique to remove unused code from the production bundle. Expo CLI employs different techniques, including [minification](/guides/minify), to improve startup time by removing unused code.
## Platform shaking
Expo CLI employs a process known as **platform shaking** for app bundling, where it creates separate bundles for each platform (Android, iOS, web). It ensures that the code is only used on one platform and is removed from other platforms.
Any code that is used conditionally based on the `Platform` module from `react-native` is removed from the other platforms. However, this exclusion specifically applies to instances where `Platform.select` and `Platform.OS` are directly imported from react-native in each file. If these are re-exported through a different module, they will not be removed during the bundling process for different platforms.
For example, consider the following transformation input:
```js Input
import { Platform } from 'react-native';
if (Platform.OS === 'ios') {
  console.log('Hello on iOS');
}
```
The production bundle will remove the conditional based on the platform:
```js Output (Android)
```
```js Output (iOS)
console.log('Hello on iOS');
```
This optimization is production only and runs on a per-file basis. If you re-export `Platform.OS` from a different module, it will not be removed from the production bundle.
The `process.env.EXPO_OS` can be used to detect the platform that the JavaScript was bundled for (cannot change at runtime). This value does not support platform shaking imports due to how Metro minifies code after dependency resolution.
## Remove development-only code
In your project, there might be code designed to help with the development process. It should be excluded from the production bundle. To handle these scenarios, use the `process.env.NODE_ENV `environment variable or the non-standard `__DEV__` global boolean.
Step 1: 
For example, the following code snippet will be removed from the production bundle:
```js Input
if (process.env.NODE_ENV === 'development') {
  console.log('Hello in development');
}
if (__DEV__) {
  console.log('Another development-only conditional...');
}
```
Step 2: 
After _constants folding_ takes place, the conditions can be evaluated statically:
```js Post constants folding
if ('production' === 'development') {
  console.log('Hello in development');
}
if (false) {
  console.log('Another development-only conditional...');
}
```
Step 3: 
The unreachable conditions are removed during [minification](/guides/minify):
```js Output (production)
```
To improve speed, Expo CLI only performs code elimination in production builds. Conditionals from the above code snippet are kept in development builds.
## Custom code removal
`EXPO_PUBLIC_` environment variables are inlined before the minification process. This means they can be used to remove code from the production bundle. For example:
Step 1: 
```js .env
EXPO_PUBLIC_DISABLE_FEATURE=true;
```
```js Input
if (!process.env.EXPO_PUBLIC_DISABLE_FEATURE) {
  console.log('Hello from the feature!');
}
```
Step 2: 
The above input code snippet is transformed to the following after `babel-preset-expo`:
```js Post babel-preset-expo
if (!'true') {
  console.log('Hello from the feature!');
}
```
Step 3: 
The above code snippet is then minified, which removes the unused conditional:
```js Post minifier
// Empty file
```
- This system does not apply to server code as environment variables are not inlined in server bundles.
- Library authors should not use `EXPO_PUBLIC_` environment variables as they only run in application code for security reasons.
## Removing server code
It's common to use `typeof window === 'undefined'` to conditionally enable or disable code for server and client environments.
`babel-preset-expo` will transform `typeof window === 'undefined'` to `true` when bundling for server environments. By default, this check remains unchanged when bundling for web client environments. This transform runs in both development and production but only removes conditional requires in production.
You can configure `babel-preset-expo` to enable this transform by passing `{ minifyTypeofWindow: true }`.
By default, this transform remains disabled even for web environments since web workers won't have a `window` global.
Step 1: 
```js Input
if (typeof window === 'undefined') {
  console.log('Hello on the server!');
}
```
Step 2: 
The input code from the previous step is transformed to the following code snippet after `babel-preset-expo` when bundling for server environments (API routes, server rendering):
```js Post babel-preset-expo (bundling for server)
if (true) {
  console.log('Hello on the server!');
}
```
Bundling client code for web or native apps will not replace `typeof window` unless `minifyTypeOfWindow: true` is set:
```js Post babel-preset-expo
if (typeof window === 'undefined') {
  console.log('Hello on the server!');
}
```
Step 3: 
For server environments, the above code snippet is then minified which removes the unused conditional:
```js Post minifier (server)
console.log('Hello on the server!');
```
```js Post minifier (client)
if (typeof window === 'undefined') {
  console.log('Hello on the server!');
}
// Empty file
```
## React Native web imports
`babel-preset-expo` provides a built-in optimization for the `react-native-web` barrel file. If you import `react-native` directly using ESM, then the barrel file will be removed from the production bundle.
For ESM: 
If you import `react-native` using the static `import` syntax, the barrel file will be removed.
```js Input
import { View, Image } from 'react-native';
```
```js Output (web)
import View from 'react-native-web/dist/exports/View';
import Image from 'react-native-web/dist/exports/Image';
```
For CJS: 
If you import `react-native` using `require()`, the barrel file will be left as-is in the production bundle.
```js Input
const { View, Image } = require('react-native');
```
```js Output (web)
const { View, Image } = require('react-native-web');
```
## Remove unused imports and exports
> Experimentally available in SDK 52 and later.
You can experimentally enable support for automatically removing unused imports and exports across modules. This is useful for speeding up native OTA downloads and optimizing web performance where JavaScript must be parsed and executed using a standard JavaScript engine.
Consider the following example code:
```js index.js
import { ArrowUp } from './icons';
export default function Home() {
  return <ArrowUp />;
}
```
```js icons.js
export function ArrowUp() {
  /* ... */
}
export function ArrowDown() {
  /* ... */
}
export function ArrowRight() {
  /* ... */
}
export function ArrowLeft() {
  /* ... */
}
```
Since only `ArrowUp` is used in `index.js`, the production bundle will remove all other components from `icons.js`.
```js icons.js (Output)
export function ArrowUp() {
  /* ... */
}
```
This system scales up to automatically optimize all `import` and `export` syntax in your app, across all platforms. While this results in smaller bundles, processing JS still requires time and computer memory so avoid importing millions of modules.
- Tree-shaking only runs in production bundles and can only run on modules that use `import` and `export` syntax. Files that use `module.exports` and `require` will not be tree-shaken.
- Avoid adding Babel plugins such as `@babel/plugin-transform-modules-commonjs` which convert `import`/`export` syntax to CJS. This will break tree-shaking across your project.
- Modules that are marked as side-effects will not be removed from the graph.
- `export * from "..."` will be expanded and optimized unless the export uses `module.exports` or `exports`.
- All modules in the Expo SDK are shipped as ESM and can be exhaustively tree-shaken.
## Enabling tree shaking
> Experimentally available in SDK 52 and later.
Step 1: 
Ensure `experimentalImportSupport` and ensure your app builds and runs as expected.
> **info** **Note**: Enabled by default in SDK 54 and later.
Note: How to enable import support in older SDK versions?
---
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.getTransformOptions = async () => ({
  transform: {
    experimentalImportSupport: true,
  },
});
module.exports = config;
```
Experimental import support uses a custom version of the `@babel/plugin-transform-modules-commonjs` plugin. This drastically reduces the number of resolutions and simplifies your output bundle. This feature can be used with `inlineRequires` to further optimize your bundle experimentally.
---
Step 2: 
Toggle on the environment variable `EXPO_UNSTABLE_METRO_OPTIMIZE_GRAPH=1` to keep modules around until the entire graph is created. Ensure your app builds and runs as expected in production with this feature enabled before continuing.
```sh .env
EXPO_UNSTABLE_METRO_OPTIMIZE_GRAPH=1
```
This will only be used in production mode.
Step 3: 
Toggle on the environment variable `EXPO_UNSTABLE_TREE_SHAKING=1` to enable the feature.
```sh .env
EXPO_UNSTABLE_TREE_SHAKING=1
```
This will only be used in production mode.
Step 4: 
Bundle your app in production mode to see the effects of tree shaking.
```sh
$ npx expo export
```
This feature is very experimental because it changes the fundamental structure of how Metro bundles code. By default, Metro bundles everything on-demand and lazily to ensure the fastest possible development times. In contrast, tree shaking requires some transformation to be delayed until after the entire bundle has been created. This means less code can be cached, which is generally fine because tree shaking is a production-only feature and production bundles often don't use transform caches.
## Barrel files
> Experimentally available in SDK 52 and later.
With Expo tree shaking, star exports will automatically be expanded and shaken based on usage. For example, consider the following code snippet:
```js Input
export * from './icons';
```
The optimization pass will crawl `./icons` and add the exports to the current module. If the exports are unused, they will be removed from the production bundle.
```js Expanded
export { ArrowRight, ArrowLeft } from './icons';
```
This will be shaken according to standard tree shaking rules. If you only import `ArrowRight`, then `ArrowLeft` will be removed from the production bundle.
If the star export pulls in ambiguous exports such as `module.exports.ArrowUp` or `exports.ArrowDown`, then the optimization pass will not expand the star export and no exports will be removed from the barrel file. You can use [Expo Atlas](/guides/analyzing-bundles/#analyzing-bundle-size-with-atlas) to inspect the expanded exports.
You can use this strategy with libraries like `lucide-react` to remove all icons that are not used in your app.
## Recursive optimizations
> Experimentally available in SDK 52 and later.
Expo optimizes a module by recursing through the graph exhaustively to find unused imports. Consider the following code snippet:
```js Input
export function foo() {
  // Because bar is used here, it cannot be removed.
  bar();
}
export function bar() {}
```
In this case, `bar` is used in `foo`, so it cannot be removed. However, if `foo` is not used anywhere in the app, then `foo` will be removed and the module will be scanned again to see if `bar` can be removed. This process recurses 5 times for a given module before bailing out due to performance reasons.
## Side-effects
Expo CLI respects module side-effects according to the [Webpack system](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free). Side-effects are generally used for defining global variables (`console.log`) or modifying prototypes (avoid doing this).
You can mark if your module has side-effects in the **package.json**:
```json package.json
{
  "name": "library",
  "sideEffects": ["./src/*.js"]
}
```
Side-effects will prevent the removal of unused modules and disable module inlining to ensure JS code runs in the expected order. Side-effects will be removed if they're empty or contain only comments and directives (`"use strict"`, `"use client"`, and so on).
When Expo tree shaking is enabled, you can safely enable `inlineRequires` in your **metro.config.js** for production bundles. This will lazily load modules when they're evaluated, leading to faster startup time. Avoid using this feature without Expo tree shaking as it will move modules around in ways that can change the execution order of side-effects.
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.getTransformOptions = async () => ({
  transform: {
    experimentalImportSupport: true,
    inlineRequires: true,
  },
});
module.exports = config;
```
## Optimizing for tree shaking
Before Expo tree shaking, React Native libraries would remove imports by wrapping them in conditional blocks such as:
```js
if (process.env.NODE_ENV === 'development') {
  require('./dev-only').doSomething();
}
```
This is problematic because you don't have accurate TypeScript support and it makes the graph ambiguous since you cannot statically analyze the code. With Expo tree shaking enabled, you can restructure this code to use ESM imports:
```js Input
import { doSomething } from './dev-only';
if (process.env.NODE_ENV === 'development') {
  doSomething();
}
```
In both cases, the entire module will be empty in production bundles.


## Minifying JavaScript

Learn about customizing the JavaScript minification process in Expo CLI with Metro bundler.

Minification is an optimization build step. It removes unnecessary characters such as collapses whitespace, removes comments, and shortens static operations, from the source code. This process reduces the final size and improves load times.
## Minification in Expo CLI
In Expo CLI, minification is performed on JavaScript files during the production export (when `npx expo export`, `npx expo export:embed`, `eas build`, and so on, commands run).
For example, consider following code snippet in a project:
```js Input
// This comment will be stripped
console.log('a' + ' ' + 'long' + ' string' + ' to ' + 'collapse');
```
This will be minified by the Expo CLI:
```js Output
console.log('a long string to collapse');
```
> **info** **Tip:** Comments can be preserved by using the `/** @preserve */` directive.
The default minification of Expo CLI is sufficient for most projects. However, you can customize the minifier to optimize for speed or remove additional features like logs.
## Remove console logs
You can remove console logs from your production build. Use the `drop_console` option in the Terser minifier config.
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.minifierConfig = {
  compress: {
    // The option below removes all console logs statements in production.
    drop_console: true,
  },
};
module.exports = config;
```
You can also pass an array of console types to drop if you want to preserve certain logs. For example: `drop_console: ['log', 'info']` will remove `console.log` and `console.info` but preserve `console.warn` and `console.error`.
## Customizing the minifier
Different minifiers have tradeoffs between speed and compression. You can customize the minifier used by Expo CLI by modifying the **metro.config.js** file in your project.
### Terser
> [`terser`](https://github.com/terser/terser) is the default minifier ([Metro@0.73.0 changelog](https://github.com/facebook/metro/releases/tag/v0.73.0)).
Step 1: 
To install Terser in a project, run the command:
```sh
$ yarn add --dev metro-minify-terser
```
Step 2: 
Set Terser as a minifier with `transformer.minifierPath`, and pass in [`terser` options](https://github.com/terser/terser#compress-options) to `transformer.minifierConfig`.
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.minifierPath = 'metro-minify-terser';
config.transformer.minifierConfig = {
  // Terser options...
};
module.exports = config;
```
### Unsafe Terser options
For additional compression that may not work in all JavaScript engines, enable the [`unsafe` `compress` options](https://terser.org/docs/miscellaneous/#the-unsafe-compress-option):
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.minifierPath = 'metro-minify-terser';
config.transformer.minifierConfig = {
  compress: {
    // Enable all unsafe optimizations.
    unsafe: true,
    unsafe_arrows: true,
    unsafe_comps: true,
    unsafe_Function: true,
    unsafe_math: true,
    unsafe_symbols: true,
    unsafe_methods: true,
    unsafe_proto: true,
    unsafe_regexp: true,
    unsafe_undefined: true,
    unused: true,
  },
};
module.exports = config;
```
### esbuild
[`esbuild`](https://esbuild.github.io/) is used to minify exponentially faster than `uglify-es` and `terser`. For more information, see [`metro-minify-esbuild`](https://github.com/EvanBacon/metro-minify-esbuild#usage) usage.
### Uglify
You can use [`uglify-es`](https://github.com/mishoo/UglifyJS) by following the steps below:
Step 1: 
To install Uglify in a project, run the command:
```sh
$ yarn add --dev metro-minify-uglify
```
> Make sure the version of `metro-minify-uglify` matches the version of `metro` in your project.
Step 2: 
Set Uglify as a minifier with `transformer.minifierPath`, and pass in [options](https://github.com/mishoo/UglifyJS#compress-options) to `transformer.minifierConfig`.
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const config = getDefaultConfig(__dirname);
config.transformer.minifierPath = 'metro-minify-uglify';
config.transformer.minifierConfig = {
  // Options: https://github.com/mishoo/UglifyJS#compress-options
};
module.exports = config;
```


## Why Metro?

Learn why Metro is the future of universal bundling in React Native and how it benefits developers.

[Metro](https://metrobundler.dev/) is the official bundler for Expo and React Native. It's a central build tool in the Expo framework. Bundlers comprise thousands of opinions and trade-offs. This document outlines the key reasons why Expo is developed around Metro and how it benefits developers.
## Official Meta bundler
Metro is maintained by Meta, the maintainers of React, React Native, Yoga, and Hermes. It's used for developing some of the world's largest apps, ranging across all categories in the app stores.
Meta engineers actively develop Metro with the express requirement of bundling all their apps, across 400k+ source files, while remaining fast and reliable.
By having first-class Metro support, we ensure Expo developers have continuity across Meta's tools and get instant access to emerging features. This includes:
- React Fast Refresh was [first introduced](https://reactnative.dev/blog/2019/09/18/version-0.61) as a Metro feature in 2019. The React web community adopted it the following year via Webpack.
- Transforming JavaScript to Hermes bytecode for instant native startup.
- React Native DevTools, including first-class support for [network and JS debugging](/debugging/tools/#debugging-with-react-native-devtools), is exclusively available with Metro and Hermes.
- React Compiler was initially rolled out as a Metro-compatible Babel plugin.
New and upcoming features that are planned to come to Metro include:
- Compiling Flow code to native machine code with Static Hermes. Learn more in the [Static Hermes](https://www.youtube.com/watch?v=GUM64b-gAGg) talk by Tzvetan Mikov.
- Data fetching, streaming, React Suspense, server rendering, and build-time static rendering with universal React Server Components for all platforms. Learn more in the [Universal React Server Components](https://www.youtube.com/watch?v=djhEgxQf3Kw) talk at React Conf 2024.
The Expo team collaborates with Meta to develop Metro for Expo Router, adding features like [file-based routing](/develop/file-based-routing/), [web support](/guides/customizing-metro/#web-support), [bundle splitting](/guides/customizing-metro/#bundle-splitting), [tree shaking](/guides/tree-shaking/), [CSS](/versions/latest/config/metro/#css), [DOM components](/guides/dom-components/), server components, and [API routes](/router/web/api-routes/).
## Battle-tested at scale
Nearly every React Native app in the world uses Metro, making it a battle-tested solution optimized for large-scale projects. This makes it suitable for developers of all sizes, from hobbyists to large companies. Metro is designed specifically to handle large-scale Meta apps, which is why it has features such as native file watching with Watchman and [shared remote caches](https://metrobundler.dev/docs/caching).
## On-demand processing
In development, Metro doesn't perform any platform-specific work until requested. This allows developers to work on large projects without paying a performance cost for the number of platforms they support. In conjunction with aggressive caching and [async routes](/router/web/async-routes/), developers can incrementally bundle only the parts of the app that they're actively working on.
## Multi-dimensional
Unlike traditional bundlers, which create multiple instances to bundle server and client code, Metro maximizes resource reuse across platforms and environments (server, client, DOM components). This architecture is ideal for multiplatform and server development.
## Reusable transform memoization
Metro is incremental and can create cached transform artifacts that can be used across machines. This enables large teams to reuse work from remote builders, a technique used at Meta for all large projects.
## Optimized for custom runtimes
While other bundlers are designed around the static specification of web browsers, Metro is optimized for the flexibility of React Native. This enables features like generating the specific set of supported language features required for Hermes bytecode compilation which enables faster app startup in production. This will also extend to Static Hermes, which will compile static type information into machine code for native apps.
## Cross-technology support
Expo leverages Metro's technology to create novel functionality like [DOM components](/guides/dom-components/). This allows a React component in a native app to be dynamically bundled as an entire website with all the same defaults as the parent app, on-demand.
## Native asset exports
Unlike traditional bundlers, where the end result is a fully hosted app, Metro's configuration options support exporting bundles to embed as native artifacts in standalone app binaries. This leverages OS-specific optimizations such as `xcassets` on Apple platforms.
## Concurrent processing
All AST transformation in Metro is performed concurrently across all available threads, maximizing the use of hardware.
## Comparison with other approaches
While Metro is designed for universal app development, it's often compared to other web-only bundlers. Here are some key differences:
### Browser ESM versus bundling
While bundlers like Vite leverage built-in ESM support in the browser, this approach can lead to slower practical development times at medium to large scales due to thousands of cascading network requests. Metro performs bundling in local development, which aligns the development results much closer to the production results and is better suited for React Native's larger module count.
### JavaScript versus native languages
Several bundlers are opting to write their core in Rust for performance reasons, but this comes with some trade-offs, such as more challenging contributions, patches, and development. Metro uses a mix of technologies based on the operation:
- The core bundler and utilities are written in JS/Flow.
- File watching is written in C++ via Watchman, with a JS fallback. Watchman is then used across projects on your computer.
- AST is parsed with Hermes parser (WebAssembly) to a Babel-compatible format.
- AST transformation is done with Babel. This maximizes developer customization.
- Minification uses Hermes on native platforms and Terser (with optional ESBuild support) for web.
- CSS parsing and minification is performed with [LightningCSS](https://lightningcss.dev/) (Rust).
This approach aligns with Meta and community tools while allowing easier debugging, profiling, and patching for developers.


# Reference

## Work with monorepos

Learn about setting up Expo projects in a monorepo with workspaces.

Monorepos, or _"monolithic repositories"_, are single repositories containing multiple apps or packages. They can help speed up development for larger projects, make it easier to share code, and act as a single source of truth. This guide will set up a simple monorepo with an Expo project. Expo has first-class support for monorepos managed with package managers supporting workspaces: [Bun](https://bun.sh/docs/install/workspaces), [npm](https://docs.npmjs.com/cli/using-npm/workspaces), [pnpm](https://pnpm.io/workspaces), and [Yarn](https://yarnpkg.com/features/workspaces) (v1 Classic and Berry). Expo automatically detects monorepos and configures new app projects added to a monorepo. The detection is based on the workspace configuration in your project.
> **info** Monorepos are not for every project. They're useful if multiple apps live in a single repository and share code, or can be helpful to colocate native modules with your app. The tradeoff is increased complexity when setting up and configuring tooling. Check whether your tools and libraries work well within a monorepo before setting one up.
Note: Automatic Configuration (Migrating to SDK 52+)
---
<a id="automatic-configuration" />
Since SDK 52, Expo configures Metro automatically for monorepos. You don't have to manually configure Metro when using monorepos if you use [`expo/metro-config`](/guides/customizing-metro/).
If you're migrating to an Expo SDK version after 52 and have a **metro.config.js** that manually modifies one of the following properties, delete these from your configuration:
- `watchFolders`
- `resolver.nodeModulesPath`
- `resolver.extraNodeModules`
- `resolver.disableHierarchicalLookup`
After deleting these options, you'll need to run Expo with `npx expo start --clear` once to erase the outdated Metro cache. If your app continues working as expected afterwards, it's a regular Node monorepo and won't need any special configuration going forward.
---
Note: Manual Configuration (Before SDK 52)
---
<a id="manual-configuration" />
Since SDK 52, Expo's Metro config has monorepo support for Bun, npm, pnpm and Yarn and configures itself automatically. You don't have to manually configure Metro when using monorepos if you use the config from [`expo/metro-config`](/guides/customizing-metro/). If that's the case, you don't need to manually configure monorepo support.
Before SDK 52, to configure a monorepo with Metro manually, there were two manual changes:
1. Metro had to be configured to watch code within the monorepo manually (for example, not just **apps/cool-app**.)
2. Metro's resolution had to be adjusted to find packages in other workspaces and multiple `node_modules` folders (for example, **apps/cool-app/node_modules** or **node_modules**.)
The configuration was adjusted by [creating a **metro.config.js**](/guides/customizing-metro/#customizing) with the following content:
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
const path = require('path');
// This can be replaced with `find-yarn-workspace-root`
const monorepoRoot = path.resolve(__dirname, '../..');
const config = getDefaultConfig(__dirname);
// 1. Watch all files within the monorepo
config.watchFolders = [monorepoRoot];
// 2. Let Metro know where to resolve packages and in what order
config.resolver.nodeModulesPaths = [
  path.resolve(projectRoot, 'node_modules'),
  path.resolve(monorepoRoot, 'node_modules'),
];
module.exports = config;
```
> Learn more about [customizing Metro](/guides/customizing-metro).
---
## Setting up a monorepo
In a monorepo, your app will typically be a in sub-directory of your repository and your package manager is configured to allow you to add dependencies to other packages from within your monorepo.
For example, a basic structure of a monorepo containing Expo apps may look like this:
- **apps**: Contains multiple projects, including Expo apps.
- **packages**: Contains different packages used by apps.
- **package.json**: Root package file.
All monorepos should have a "root" **package.json** file. It is the main configuration for monorepos and may contain tools installed for all projects in the repository. Depending on which package manager you're using, the steps for setting up workspaces might differ, but for [Bun](https://bun.sh/docs/install/workspaces), [npm](https://docs.npmjs.com/cli/using-npm/workspaces), and [Yarn](https://yarnpkg.com/features/workspaces), a `workspaces` property should be added to the root **package.json** file that specifies [glob patterns](https://classic.yarnpkg.com/lang/en/docs/workspaces/#toc-tips-tricks) for all workspaces in your monorepo:
```json package.json
{
  "name": "monorepo",
  "private": true,
  "version": "0.0.0",
  "workspaces": ["apps/*", "packages/*"]
}
```
For [pnpm](https://pnpm.io/workspaces), you'll have to create a [**pnpm-workspace.yaml**](https://pnpm.io/pnpm-workspace_yaml) instead:
```yaml pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'packages/*'
```
### Create your first app
Now that you have the basic monorepo structure set up, add your first app.
Before you create your app, you have to create the **apps** directory. This directory contains all separate apps or websites that belong to this monorepo. Inside this **apps** directory, you can create a sub-directory that contains the Expo app.
  For npm: 
    ```sh
$ npx create-expo-app@latest apps/cool-app
```
  For Yarn: 
    ```sh
$ yarn create expo-app apps/cool-app
```
  For pnpm: 
    ```sh
$ pnpm create expo-app apps/cool-app
```
  For Bun: 
    ```sh
$ bun create expo apps/cool-app
```
> If you have an existing app, you can copy all those files into a directory inside **apps**.
After copying or creating the first app, install your dependencies with your package manager from the root directory of your monorepo to check for common warnings.
### Create a package
Monorepos can help us group code in a single repository. That includes apps but also separate packages. They also don't need to be published. The [Expo repository](https://github.com/expo/expo) uses this as well. All the Expo SDK packages live inside the [**packages**](https://github.com/expo/expo/tree/main/packages) directory in our repo. It helps us test the code inside one of our [**apps**](https://github.com/expo/expo/tree/main/apps/native-component-list) directory before we publish them.
Let's go back to the root and create the **packages** directory. This directory can contain all the separate packages that you want to make. Once you are inside this directory, we need to add a new sub-directory. The sub-directory is a separate package that we can use inside our app. In the example below, we named it **cool-package**.
  For npm: 
    ```sh
$ mkdir -p packages/cool-package
$ cd packages/cool-package
$ npm init
```
  For Yarn: 
    ```sh
$ mkdir -p packages/cool-package
$ cd packages/cool-package
$ yarn init
```
  For pnpm: 
    ```sh
$ mkdir -p packages/cool-package
$ cd packages/cool-package
$ pnpm init
```
  For Bun: 
    ```sh
$ mkdir -p packages/cool-package
$ cd packages/cool-package
$ bun init --minimal
```
We won't go into too much detail in creating a package. If you are not familiar with this, consider using a simple app without monorepos. But, to make the example complete, let's add an **index.js** file with the following content:
```js index.js
export const greeting = 'Hello!';
```
### Using the package
Like standard packages, we need to add our **cool-package** as a dependency to our **cool-app**. The main difference between a standard package, and one from the monorepo, is you'll always want to use the _"current state of the package"_ instead of a version. Let's add **cool-package** to our app by adding `"cool-package": "*"` to our app **package.json** file:
```json package.json
{
  "name": "cool-app",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "cool-package": "*",
    "expo": "~54.0.0",
    "expo-status-bar": "~3.0.6",
    "react": "19.1.0",
    "react-native": "0.81.1"
  }
}
```
Bun, npm, and pnpm support specifying workspace dependencies using `"workspace:*"` instead of `"*"`. This will ensure that the workspace package never resolves a published package of the same name from the npm registry, but is optional.
After adding the package, install your dependencies with your package manager from the root directory of your monorepo to check for common warnings once again.
Now you should be able to use the package inside your app! To test this, let's edit the **App.js** in your app and render the `greeting` text from our **cool-package**.
```jsx App.js
import { greeting } from 'cool-package';
import { StatusBar } from 'expo-status-bar';
import React from 'react';
import { Text, View } from 'react-native';
export default function App() {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>{greeting}</Text>
      <StatusBar style="auto" />
    </View>
  );
}
```
## Common issues
Monorepos may cause resolution and dependency issues that a regular project won't. They require more in-depth knowledge and require specific tooling configuration. You take on increased complexity and will need to solve issues you wouldn't run into without workspaces. Here are a couple of common issues you might encounter.
### Package managers with isolated dependencies
> **info** From **SDK 54**, Expo supports isolated dependencies and isolated installations.
> With **SDK 53**, disabling isolated dependencies is recommended, or you may encounter native build errors and dependency conflicts.
[Bun](https://bun.com/docs/install/isolated) and [pnpm](https://pnpm.io/settings#nodelinker) have first-class support for isolated installs. For pnpm, this is the default installation strategy unless it's disabled.
With isolated dependencies, package managers don't hoist packages from nested `node_modules` directories into higher ones. Instead, they create a central directory that contains your Node modules and create links to this directory. This dependency structure enforces that packages may only access their explicitly declared dependencies. This is a much stricter installation strategy than the traditional **hoisted** installation strategy, which are npm's and Yarn's default, to install dependencies in a flattened structure.
A side-effect of **hoisted** installations is that you can accidentally depend on Node modules you haven't specified in your own **package.json**'s `dependencies` or `peerDependencies`. Instead, many more dependencies that other packages rely on are hoisted and become accessible to you. This can cause non-deterministic behavior, and allow you to have broken dependency chains, which are more fragile and can cause resolution errors when updating or upgrading packages. This is especially common in monorepos.
**Starting with SDK 54**, Expo supports isolated dependencies. Unfortunately, not all packages you install will work and some React Native libraries may cause build or resolution errors when used with isolated dependencies. If you encounter issues with isolated installations with [pnpm](https://pnpm.io/settings#nodelinker), switch to the **hoisted** installation strategy by changing the `node-linker` setting in an **.npmrc** file in the root of your repository:
```plain .npmrc
node-linker=hoisted
```
### Duplicate native packages within monorepos
Expo has improved support for more complete **node_modules** patterns, such as isolated modules. Unfortunately, if your app contains duplicate dependencies, issues may still occur:
- Duplicate React Native versions in a single monorepo are not supported
- Duplicate React versions in a single app will cause runtime errors
- Duplicate versions of Turbo and Expo modules may cause runtime or build errors
You can check if your monorepo has multiple versions of a package, for example, `react-native`, and why they're installed through the package manager you use.
  For npm: 
    ```sh
$ npm why react-native
```
  For Yarn: 
    ```sh
$ yarn why react-native
```
  For pnpm: 
    ```sh
$ pnpm why --depth=10 react-native
```
  For Bun: 
    ```sh
$ bun pm why react-native
```
The output of these commands will be very different from one package manager to another, but you can spot duplicate packages in any of their outputs by looking for multiple versions of the package, for example `react-native@0.79.5` and `react-native@0.81.0`.
**npm**,
#### Adding dependency resolutions for peer dependencies
If the duplicate dependency is not resolvable by you changing your dependencies, you may have to add a resolution. For example, not all packages have updated their **peerDependencies** to support React 19. To work around this, you can create a resolution to force a single version of `react` to be installed.
```json package.json
{
  "name": "monorepo",
  "private": true,
  "version": "0.0.0",
  "workspaces": ["apps/*", "packages/*"],
  "resolutions": {
    "react": "^19.1.0"
  }
}
```
For [npm](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides), you have to use a property named `overrides` rather than `resolutions`.
#### Deduplicating auto-linked native modules
> **important** This is an alpha feature starting in SDK 54 and later. The process will be automated and have better support in future versions.
Often, duplicate dependencies won't cause any problems. However, native modules should never be duplicated, because only one version of a native module can be compiled for an app build at a time. Unlike JavaScript dependencies, native builds cannot contain two conflicting versions of a single native module.
From **SDK 54**, you can set `experiments.autolinkingModuleResolution` to `true` in your **app.json** to apply autolinking to Expo CLI and Metro bundler automatically. This will force dependencies that Metro resolves to match the native modules that [autolinking](/modules/autolinking/) links for your native builds.
### Script '...' does not exist
React Native uses packages to ship both JavaScript and native files. These native files also need to be linked, like the [**react-native/react.Gradle**](https://github.com/facebook/react-native/blob/v0.70.6/react.gradle) file from **android/app/build.Gradle**. Usually, this path is hardcoded to something like:
**Android** ([source](https://github.com/facebook/react-native/blob/e918362be3cb03ae9dee3b8d50a240c599f6723f/template/android/app/build.gradle#L84))
```groovy
apply from: "../../node_modules/react-native/react.gradle"
```
**iOS** ([source](https://github.com/facebook/react-native/blob/e918362be3cb03ae9dee3b8d50a240c599f6723f/template/ios/Podfile#L1))
```ruby
require_relative '../node_modules/react-native/scripts/react_native_pods'
```
Unfortunately, this path can be different in monorepos because of [hoisting](https://classic.yarnpkg.com/blog/2018/02/15/nohoist/). It also doesn't use the [Node module resolution](https://nodejs.org/api/modules.html#all-together). You can avoid this issue by using Node to find the location of the package instead of hardcoding this:
**Android** ([source](https://github.com/expo/expo/blob/6877c1f5cdca62b395b0d5f49d87f2f3dbb50bec/templates/expo-template-bare-minimum/android/app/build.gradle#L87))
```groovy
apply from: new File(["node", "--print", "require.resolve('react-native/package.json')"].execute(null, rootDir).text.trim(), "../react.gradle")
```
**iOS** ([source](https://github.com/expo/expo/blob/61cbd9a5092af319b44c319f7d51e4093210e81b/templates/expo-template-bare-minimum/ios/Podfile#L2))
```ruby
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")
```
In the snippets above, you can see that we use Node's own [`require.resolve()`](https://nodejs.org/api/modules.html#requireresolverequest-options) method to find the package location. We explicitly refer to `package.json` because we want to find the root location of the package, not the location of the entry point. And with that root location, we can resolve to the expected relative path within the package. [Learn more about these references here](https://github.com/expo/expo/blob/4633ab2364e30ea87ca2da968f3adaf5cdde9d8b/packages/expo-modules-core/README.mdx#importing-native-dependencies---autolinking).
All Expo SDK modules and templates have these dynamic references and work with monorepos. However, occasionally, you might run into packages that still use the hardcoded path. You can manually edit it with [`patch-package`](https://github.com/ds300/patch-package#readme) or mention this to the package maintainers.


## View logs

Learn how to view logs when using Expo CLI, native logs in Android Studio and Xcode, and system logs.

Logging information in a React Native app works similarly to in a web browser. You can use `console.log`, `console.warn` and `console.error`. However, at times, you might want to dive deep to get more useful information about what's happening in your app. For that, you can use **native logs** and **system logs**.
## Console logs
When you run `npx expo start` and connect a device, console logs will show up in the terminal process. These logs are sent from the runtime to Expo CLI over web sockets, meaning the results are lower fidelity than connecting dev tools directly to the engine.
You can view **high fidelity** logs and use advanced logging functions like `console.table` by creating a development build with [Hermes](/guides/using-hermes), and [connecting the inspector](/guides/using-hermes#javascript-inspector-for-hermes).
## Native logs
You can view native runtime logs in Android Studio and Xcode by compiling the native app locally. For more information, see [native debugging](/debugging/runtime-issues/#native-debugging).
## System logs
While it's usually not necessary, if you want to see logs for everything happening on your device, for example, even the logs from other apps and the OS, you can use the following commands:
```sh
$ npx react-native log-android
$ npx react-native log-ios
```


## Development and production modes

Learn how to run a project in development mode or production mode.

Your project will always run in either **development** or **production** mode. By default, running your project locally with `npx expo start` runs it in development mode, whereas a published project (with `eas update`), or any standalone app, will run in production mode.
**Development mode** includes useful warnings and gives you access to tools that make development and debugging easier. **Production mode** [minifies your code](/guides/customizing-metro/#minification) and better represents the performance your app will have on end users' devices. Let's look at each of these modes in more detail and learn how you can switch between them.
## Development mode
React Native includes some very useful tools for development: remote JavaScript debugging in Chrome, live reload, hot reloading, and an element inspector similar to the beloved inspector you use in Chrome. If you want to see how to use those tools, see [Debugging](/debugging/runtime-issues/).
Development mode also performs validations while your app is running to give you warnings. For example, if you're using a deprecated property or if you forgot to pass a required property into a component. The video below shows the Element Inspector and Performance Monitor in action on both Android Emulator and iOS Simulator:
> **warning** **This comes at a cost. Your app runs slower in development mode.**  You can switch it on and off with the Expo CLI, see [Production mode](#production-mode). When you switch it, close and re-open your app for the change to take effect. **Any time you are testing your app's performance, make sure to disable development mode**.
### View the developer menu
The menu gives access to a host of features that make development and debugging much easier. For more information on how to open it on Android and iOS, see [Developer menu](/debugging/tools/#developer-menu).
## Production mode
Production mode is most useful for two things:
- Testing your app's performance, as Development slows your app down considerably.
- Catching bugs that only show up in production.
The easiest way to simulate how your project will run on end users' devices is with the command:
```sh
$ npx expo start --no-dev --minify
```
It runs the JavaScript of your app in production mode (which tells the Metro bundler to set the `__DEV__` environment variable to `false`, among a few other things). The `--minify` flag minifies your app. This flag also eliminates unnecessary data such as comments, formatting, and unused code. If you are getting an error or crash in your standalone app, running your project with this command can save you a lot of time in finding the root cause.
To completely compile your app for production see [Compiling Android](/more/expo-cli/#compiling-android) and [Compiling iOS](/more/expo-cli/#compiling-ios).


## Common development errors

A list of common development errors that are encountered by developers using Expo.

This page outlines a list of errors that are commonly encountered by developers using Expo. For each error, the first bullet provides an explanation for why the error occurs and the second bullet contains debugging suggestions. If there is an error you think belongs here, we welcome and encourage you to [create a PR](https://github.com/expo/expo/pulls)!
### Metro bundler ECONNREFUSED 127.0.0.1:19001
- An error is preventing the connection to your local development server.
- Run `rm -rf .expo` to clear your local state. Check for firewalls or [proxies](/troubleshooting/proxies/) affecting the network you are currently connected to.
### Module AppRegistry is not a registered callable module (calling runApplication)
- An error in your code is preventing the JavaScript bundle from being executed on startup.
- Try running `npx expo start --no-dev --minify` to reproduce the production JS bundle locally. If possible, connect your device and access the device logs via Android Studio or Xcode. Device logs contain much more detailed stacktraces and information. Check to see if you have any changes or errors in your Babel configuration. In some rare cases, this issue could be caused by incompatibility between the Metro JavaScript minifier and certain code in your app ([more information](https://forums.expo.dev/t/change-minifierconfig-for-minify-uglify/36460/2)).
### npm ERR! No git binary found in \$PATH
- Either you do not have git installed or it is not properly configured in your `$PATH`.
- [Install git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if you have not already. Otherwise, check how to set it in your `$PATH` based on your OS.
### XX.X.X is not a valid SDK version
- The SDK version you are running has been deprecated and is no longer supported.
- [Upgrade your project](/workflow/upgrading-expo-sdk-walkthrough) to a supported SDK version. If you are using a supported version and see this message, you'll need to update your Expo Go app.
### React Native version mismatch
- The development server running in your terminal is bundling a different version of React Native than the app in your device or simulator.
- [Align your versions of react-native](/troubleshooting/react-native-version-mismatch) by checking the versions in your **app.json** and **package.json**
### Application has not been registered
- There is a mismatch between the AppKey registered in the native and JS portion of your app.
- [Align your AppKey](/troubleshooting/application-has-not-been-registered/) with the native side of your project.
### Application not behaving as expected
- It is possible caches may be preventing you from seeing the current state of your application.
- Clear all caches associated with your project in [Unix-like](/troubleshooting/clear-cache-macos-linux/) or [Windows](/troubleshooting/clear-cache-windows/) systems.


## Android Studio Emulator

Learn how to set up the Android Emulator to test your app on a virtual Android device.

If you don't have an Android device available to test with, we recommend using the default emulator that comes with Android Studio. If you run into any problems setting it up, follow the steps in this guide.
<AndroidStudioEnvironmentInstructions />
<AndroidStudioInstructions />
<AndroidEmulatorInstructions />
## Troubleshooting
### Multiple `adb` versions
Having multiple `adb` versions on your system can result in the following error:
```sh
$ adb server version (xx) doesn't match this client (xx); killing...
```
This is because the `adb` version on your system is different from the `adb` version on the Android SDK platform-tools.
Step 1: 
Open the terminal and check the `adb` version on the system:
```sh
$ adb version
```
Step 2: 
And from the Android SDK platform-tool directory:
```sh
$ cd ~/Library/Android/sdk/platform-tools
$ ./adb version
```
Step 3: 
Copy `adb` from Android SDK directory to `usr/bin` directory:
```sh
$ sudo cp ~/Library/Android/sdk/platform-tools/adb /usr/bin
```


## iOS Simulator

Learn how you can install the iOS Simulator on your Mac and use it to develop your app.

Developing your app directly on a computer can be more convenient than constantly interacting with an iPhone or iPad, especially when network conditions are slow or when a [tunnel connection](/more/expo-cli/#tunneling) is required due to LAN limitations.
This guide explains how to install the iOS Simulator on your Mac for app development. Note that the iOS Simulator can only be installed on macOS. If you are developing an iOS app from a Windows or a Linux machine, you will need a physical iOS device.
## Setup Xcode and Watchman
<XcodeInstructions />
Step 4: 
### Try it out
Run your app with `npx expo start` and press <kbd>i</kbd> from the command line.
You may get a warning about needing to accept the Xcode license. Run the command that it suggests. Open your app again to see if it was successful. If not, check the [troubleshooting](#troubleshooting) tips below.
You can also press <kbd>shift</kbd> + <kbd>i</kbd> in the Expo CLI to interactively select a simulator to open.
## Expo Orbit
You can use the Expo Orbit app which allows launching builds and simulator management with one click from the menu bar on macOS.
## Limitations
Although the iOS Simulator is great for rapid development, it does come with a few limitations. We'll list out a few of the main differences that affect Expo APIs below. However, see [Apple's documentation](https://help.apple.com/simulator/mac/current/#/devb0244142d) for more details.
The following hardware is unavailable in the Simulator:
- Audio Input
- Barometer
- Camera
- Motion Support (accelerometer and gyroscope)
The Simulator also suspends background apps and processes on iOS 11 and later.
## Troubleshooting
### The CLI seems to be stuck when opening a Simulator
Sometimes the iOS Simulator doesn't respond to the open command. If it seems stuck on this prompt, you can open the iOS Simulator manually (`open -a Simulator`) and then in the macOS toolbar, choose **File** &gt; **Open Simulator**, and select an iOS version and device that you'd like to open.
You can use this menu to open any version of the simulator. You can also open multiple simulators at the same time, however, Expo CLI will always target the most recently opened simulator.
### Simulator opened but the Expo Go app isn't opening inside of it
The first time you install the app in the simulator, iOS will ask if you'd like to open the Expo Go app. You may need to interact with the simulator (click around, drag something) for this prompt to show up, then press **OK**.
### How do I force an update to the latest version?
Create a project with the desired SDK version and open it in a simulator to install a particular version of Expo Go.
```sh
$ npx create-expo-app --template blank@53
$ npx expo start --ios
```
### Expo CLI is printing an error message about `xcrun`, what do I do?
For miscellaneous errors, try the following:
- Manually uninstall Expo Go on your simulator and reinstall by pressing <kbd>shift</kbd> + <kbd>i</kbd> in the Expo CLI Terminal UI and selecting the desired simulator.
- If that doesn't help, focus the simulator window and in the Mac toolbar choose **Device** &gt; **Erase All Content and Settings...**
  This will reinitialize your simulator from a blank image. This is sometimes useful for cases where your computer is low on memory and the simulator fails to store some internal files, leaving the device in a corrupt state.


## React Native's New Architecture

Learn about React Native's "New Architecture" and how and why to migrate to it.

> **info** We recommend using the latest Expo version for the best experience with the New Architecture.
The New Architecture is a name that we use to describe a complete refactoring of the internals of React Native. It is also used to solve limitations of the original React Native architecture discovered over years of usage in production at Meta and other companies.
In this guide, we'll talk about how to use the New Architecture in Expo projects today.
Note: Why migrate to the New Architecture?
---
**The New Architecture is the future of React Native** &mdash; yet, for many apps, there may not be many immediate benefits to migrating today. You may want to think of migrating to the New Architecture as an investment in the future of your app, rather than as a way to immediately improve your app.
That said, **new React and React Native features are coming to the New Architecture only**. For example, the New Architecture includes [full support for Suspense](https://reactnative.dev/blog/2024/10/23/the-new-architecture-is-here#full-support-for-suspense) and [new styling capabilities](https://reactnative.dev/blog/2025/01/21/version-0.77#new-css-features-for-better-layouts-sizing-and-blending) are not implemented in the legacy architecture. Libraries such as [@shopify/flash-list](https://github.com/Shopify/flash-list) and [react-native-reanimated](https://github.com/software-mansion/react-native-reanimated) will be shipping new major versions that take full advantage of new features to deliver better performance than was possible before, and will drop support for the legacy architecture.
**The legacy architecture will not be around forever** &mdash; it's possible that the legacy architecture will be removed from React Native in a late 2025 release. When it is removed, you will not be able to upgrade React Native or the Expo SDK without migrating to the New Architecture.
---
## Expo tools and the New Architecture
As of SDK 53, all `expo-*` packages in the [Expo SDK](/versions/latest/) support the New Architecture (including [bridgeless](https://github.com/reactwg/react-native-new-architecture/discussions/154)). [Learn more about known issues](#known-issues-in-expo-sdk-libraries).
Additionally, all modules written using the [Expo Modules API](/modules/overview/) support the New Architecture by default! So if you have built your own native modules using this API, no additional work is needed to use them with the New Architecture.
**As of April 2025, approximately 75% of SDK 52+ projects built with [EAS Build](/build/introduction/) use the New Architecture**.
## Third-party libraries and the New Architecture
The compatibility status of many of the most popular libraries is tracked on [React Native Directory](https://reactnative.directory/) ([learn more about known issues in third-party libraries](#known-issues-in-third-party-libraries)). We've built tooling into Expo Doctor to integrate with React Native Directory to help you validate your dependencies, so you can quickly learn which libraries are unmaintained and which incompatible or untested with the New Architecture.
### Validate your dependencies with React Native Directory
Run `npx expo-doctor` to check your dependencies against the data in React Native Directory.
```sh
$ npx expo-doctor@latest
```
You can configure the React Native Directory check in your **package.json** file. For example, if you would like to exclude a package from validation:
```json package.json
{
  "expo": {
    "doctor": {
      "reactNativeDirectoryCheck": {
        "exclude": ["react-redux"]
      }
    }
  }
}
```
Note: See all available options
---
- **enabled**: If `true`, the check will warn if any packages are missing from React Native Directory. Set this to `false` to disable this behavior. In SDK 52 and later, this is set to `true` by default, otherwise it is `false` by default. You can also override this setting with the `EXPO_DOCTOR_ENABLE_DIRECTORY_CHECK` environment variable (0 is `false`, 1 is `true`).
- **exclude**: List any packages you want to exclude from the check. Supports exact package names and regex patterns. For example, `["exact-package", "/or-a-regex-.*/"]`.
- **listUnknownPackages**: By default, the check will warn if any packages are missing from React Native Directory. Set this to false to disable this behavior.
---
## Initialize a new project with the New Architecture
**As of SDK 52**, all new projects will be initialized with the New Architecture enabled by default.
```sh
$ npx create-expo-app@latest
```
## Enable the New Architecture in an existing project
  For SDK 53 and later: 
    **The New Architecture is enabled by default in SDK 53 and later**. If you have explicitly disabled it, remove that configuration to enable it.
  For SDK 52: 
    We recommend upgrading to SDK 53 to ensure that your app can take advantage of all of the latest New Architecture related fixes and improvements with libraries and React Native itself. If you want to try it on SDK 52 first, follow the instructions below.
    Step 1: 
    To enable it on both Android and iOS, use the `newArchEnabled` at the root of the `expo` object in your app config. You can selectively enable it for a single platform by setting, for example, `"android": { "newArchEnabled": true }`.
    ```json app.json
    {
      "expo": {
        "newArchEnabled": true
      }
    }
    ```
    Step 2: 
      Create a new build:
          ```sh
if you like
$ npx expo prebuild --clean && npx expo run:android
$ eas build -p android
```
          ```sh
if you like
$ npx expo prebuild --clean && npx expo run:ios
$ eas build -p ios
```
      If the build succeeds, you will now be running your app with the New Architecture! Depending on the native modules you use, your app may work properly immediately.
      Now you can tap around your app and test it out. For most non-trivial apps, you're likely to encounter some issues, such as missing native views that haven't been implemented for the New Architecture yet. Many of the issues you encounter are actionable and can be resolved with some configuration or code changes. We recommend reading [Troubleshooting](#troubleshooting) sections below for more information.
  For SDK 51 and earlier: 
    We recommend upgrading to at least SDK 52, preferably SDK 53. It's possible to enable the New Architecture in SDK 51, but you are likely to encounter a variety of issues that have been resolved in more recent releases. To enable it, you need to [install the `expo-build-properties` plugin](/versions/latest/sdk/build-properties/#installation) and set `newArchEnabled` on target platforms.
Note: Are you enabling the New Architecture in a bare React Native app?
---
If you are using Expo SDK 53 or higher, it will be enabled by default. The following instructions apply to older projects.
- **Android**: Set `newArchEnabled=true` in the **gradle.properties** file.
- **iOS**: If your project has a **Podfile.properties.json** file (which is created by `npx create-expo-app` or `npx expo prebuild`), you can enable the New Architecture by setting the `newArchEnabled` property to `"true"` in the **Podfile.properties.json** file. Otherwise, refer to the ["Enable the New Architecture for Apps"](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/enable-apps.md) section of the React Native New Architecture working group.
---
## Disable the New Architecture in an existing project
> **info**: Expo Go only supports the New Architecture.
If you want to opt out of using the New Architecture, set the `newArchEnabled` property to `false` in app config and create a [development build](/develop/development-builds/introduction/).
```json app.json
{
  "expo": {
    "newArchEnabled": false
  }
}
```
Note: Are you disabling the New Architecture in a bare React Native app?
---
- **Android**: Set `newArchEnabled=false` in the **gradle.properties** file.
- **iOS**: If your project has a **Podfile.properties.json** file (which is created by `npx create-expo-app` or `npx expo prebuild`), you can disable the New Architecture by setting the `newArchEnabled` property to `"false"` in the **Podfile.properties.json** file. Otherwise, refer to the ["Enable the New Architecture for Apps"](https://github.com/reactwg/react-native-new-architecture/blob/main/docs/enable-apps.md) section of the React Native New Architecture working group.
---
## Troubleshooting
Meta and Expo are working toward making the New Architecture the default for all new apps and ensuring it is as easy as possible to migrate existing apps. However, the New Architecture isn't just a name &mdash; many of the internals of React Native has been re-architected and rebuilt from the ground up. As a result, you may encounter issues when enabling the New Architecture in your app. The following is some advice for troubleshooting these issues.
Note: Can I still try the New Architecture even if some of the libraries I use aren't supported?
---
You may be able to try the New Architecture in your app even if some of the libraries you use aren't supported, but it will require temporarily removing those libraries. Create a new branch in your repository and remove any of the libraries that aren't compatible until your app is running. This will give you a good idea of what libraries still need work before you can fully migrate to the New Architecture. We recommend creating issues or pull requests on those libraries' repositories to help them become compatible with the New Architecture. Alternatively, you could switch to other libraries that are compatible with the New Architecture. Refer to [React Native Directory](https://reactnative.directory/) to find compatible libraries.
---
Note: Known issues in React Native
---
Refer to the [issues labeled with "Type: New Architecture" on the React Native GitHub repository](https://github.com/facebook/react-native/issues?q=is%3Aopen+is%3Aissue+label%3A%22Type%3A+New+Architecture%22).
---
Note: Known issues in Expo libraries
---
There are no known issues specific to the New Architecture in Expo libraries.
---
Note: Known issues in third-party libraries
---
Since React Native 0.74, there are various Interop Layers enabled by default. This allows many libraries built for the old architecture to work on the New Architecture without any changes. However, the interop is not perfect and some libraries will need to be updated. The libraries that are most likely to require updates are those that ship or depend on third-party native code. [Learn more about library support in the New Architecture](https://github.com/reactwg/react-native-new-architecture/discussions/167).
Refer to [React Native Directory](https://reactnative.directory/) a more complete list of libraries and their compatibility with the New Architecture. The following libraries were found to be popular among Expo apps and are known to be incompatible:
The following are known issues with libraries that are popular among Expo apps.
- **react-native-maps**: Version 1.20.x, which is the default for SDK 53, supports the New Architecture with the interop layer and works well for most features. A New Architecture-first version is available in version 1.21.0, which is still stabilizing. We encourage your to test it in your app, report issues that you find, and [follow along with the discussion on GitHub](https://github.com/react-native-maps/react-native-maps/discussions/5355). We are also investigating another approach that may provider a smoother migration path, by leaning on the [interop layer](https://github.com/reactwg/react-native-new-architecture/discussions/175) rather than rewriting the module. It's worth mentioning that if your app can force a minimum version of iOS 17, or does not need to support maps on iOS, then you can consider using [`expo-maps`](/versions/latest/sdk/maps/) instead.
- **@stripe/react-native**: The New Architecture is supported starting with version 0.45.0, which is the default for SDK 53.
- **@react-native-community/masked-view**: Use `@react-native-masked-view/masked-view` instead.
- **@react-native-community/clipboard**: Use `@react-native-clipboard/clipboard` instead.
- **rn-fetch-blob**: Use `react-native-blob-util` instead.
- **react-native-fs**: Use `expo-file-system` or [a fork of react-native-fs](https://github.com/birdofpreyru/react-native-fs) instead.
- **react-native-geolocation-service**: Use `expo-location` instead.
- **react-native-datepicker**: Use `react-native-date-picker` or `@react-native-community/datetimepicker` instead.
---
Note: My build failed after enabling the New Architecture
---
This isn't entirely surprising! Not all libraries are compatible yet, and in some cases compatibility was only recently added and so you will want to ensure you update your libraries to their latest versions. Read the logs to determine which library is incompatible. Also, run `npx expo-doctor@latest` to check your dependencies against the data in React Native Directory.
When you are using the latest version of a library and it is not compatible, report any issues you encounter to the respective GitHub repository. Create a [minimal reproducible example](https://stackoverflow.com/help/minimal-reproducible-example) and report the issue to the library author. If you believe the issue originates in React Native itself, rather than a library, report it to the React Native team (again, with a minimal reproducible example).
---


## React Compiler

Learn how to enable and use the React Compiler in Expo apps.

The new [React Compiler](https://react.dev/learn/react-compiler) automatically memoizes components and hooks to enable fine-grained reactivity. This can lead to significant performance improvements in your app. You can enable it in your app by following the instructions below.
## Enabling React Compiler
Step 1: 
[Check how compatible](https://react.dev/learn/react-compiler#checking-compatibility) your project is with the React Compiler.
```sh
$ npx react-compiler-healthcheck@latest
```
This will generally verify if your app is following the [**rules of React**](https://react.dev/reference/rules).
Step 2: 
Install `babel-plugin-react-compiler` and the React compiler runtime in your project:
    Babel is automatically configured in Expo SDK 54 and later.
    ```sh
$ npx expo install babel-plugin-react-compiler@beta
```
    ```sh
$ npx expo install babel-plugin-react-compiler@beta react-compiler-runtime@beta
```
Step 3: 
Toggle on the React Compiler experiment in your app config file:
```json app.json
{
  "expo": {
    "experiments": {
      "reactCompiler": true
    }
  }
}
```
### Enabling the linter
> In the future, all of the following steps below will be automated by Expo CLI.
Additionally, you should use the ESLint plugin to continuously enforce the rules of React in your project.
Step 1: 
Run [`npx expo lint`](/guides/using-eslint/#eslint) to ensure ESLint is setup in your app, then install the ESLint plugin for React Compiler:
```sh
$ npx expo install eslint-plugin-react-compiler -- -D
```
Step 2: 
Update your [ESLint configuration](/guides/using-eslint/) to include the plugin:
```js .eslintrc.js
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');
const reactCompiler = require('eslint-plugin-react-compiler');
module.exports = defineConfig([
  expoConfig,
  reactCompiler.configs.recommended,
  {
    ignores: ['dist/*'],
  },
]);
```
## Incremental adoption
You can incrementally adopt the React Compiler in your app using a few strategies:
Step 1: 
Configure the Babel plugin to only run on specific files or components. To do this:
1. If your project doesn't have [**babel.config.js**](/versions/latest/config/babel/), create one by running `npx expo customize babel.config.js`.
2. Add the following configuration to **babel.config.js**:
```js babel.config.js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      [
        'babel-preset-expo',
        {
          'react-compiler': {
            sources: filename => {
              // Match file names to include in the React Compiler.
              return filename.includes('src/path/to/dir');
            },
          },
        },
      ],
    ],
  };
};
```
Whenever you change your **babel.config.js** file, you need to restart the Metro bundler to apply the changes:
```sh
$ npx expo start --clear
```
Step 2: 
Use the `"use no memo"` directive to opt out of the React Compiler for specific components or files.
```jsx
function MyComponent() {
  'use no memo';
  return <Text>Will not be optimized</Text>;
}
```
## Usage
> To better understand how React Compiler works, check out the [React Playground](https://playground.react.dev/).
Improvements are primarily automatic. You can remove instances of `useCallback`, `useMemo`, and `React.memo` in favor of the automatic memoization. Class components will not be optimized. Instead, migrate to function components.
Expo's implementation of the React Compiler will only run on application code (no node modules), and only when bundling for the client (disabled in server rendering).
## Configuration
You can pass additional settings to the React Compiler Babel plugin by using the `react-compiler` object in the Babel configuration:
```js babel.config.js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      [
        'babel-preset-expo',
        {
          'react-compiler': {
            // Passed directly to the React Compiler Babel plugin.
            compilationMode: 'all',
            panicThreshold: 'all_errors',
          },
          web: {
            'react-compiler': {
              // Web-only settings...
            },
          },
        },
      ],
    ],
  };
};
```


# Existing React Native apps

## Overview of using Expo with existing React Native apps

Learn how to use Expo tools and services with existing React Native apps.

If you have a React Native app that doesn't use any Expo tools, you might be wondering what Expo can provide for you, why you might want to use Expo tools and services, and how to get started.
**All tools and services provided by Expo work great in any React Native app**.
You can use [EAS](/eas) to get quickly set up with a professional CI/CD workflow for building, reviewing, deploying, and updating your apps. [Expo CLI](/more/expo-cli/) provides the best command-line experience for working with React Native. The [Expo SDK](/versions/latest/) is an extended standard library for React Native. It gives developers high-quality, well-maintained native libraries that use consistent API conventions to make them easier to learn and use.
If you've ever written a native module for React Native, you'll be surprised how much easier it is to build and maintain modules with the idiomatic Swift and Kotlin DSL provided by the [Expo Modules API](/modules/overview/).
There's so much more to explore, and the links below will help you to explore the options available to you.
## Incremental adoption steps
Below are four suggested phases of incremental adoption. These phases generally progress from quick changes to improve developer experience, to more significant workflow and codebase optimizations.
Only the first phase &mdash; prerequisites &mdash; is required by other phases. After following its instructions, you can skip to the tools and services that are most relevant to your goals in adopting Expo.
### Prerequisites
These first steps are required to later adopt Expo tools and services:
  }
  href="/bare/installing-expo-modules"
/>
  }
  href="/bare/using-expo-cli/"
/>
### Quick wins
The following helps improving development experience and requires configuration:
  }
  Icon={BookOpen02Icon}
  href="/bare/install-dev-builds-in-bare/"
/>
### New workflows
Once your app has `expo` package installed, you can submit your app to app stores with a single command or update configure `expo-updates` library to manage remote updates to you app's code:
  }
  href="/bare/installing-updates/"
/>
### New mindsets
The following helps with your project's long term maintainability, native code maintenance, and easier upgrades:
## Common questions
Note: How long will it take to adopt Expo in my existing React Native project?
---
Adopting Expo doesn't have to be done in one step. You can start with the _quick wins_ and then move on to more complex parts. You can also pick and choose which features you want to adopt based on what is most helpful for your project.
---
Note: What will I gain from using Expo in my React Native app?
---
Adopting Expo tools in your existing React Native app can help you develop faster with the [Expo SDK](/versions/latest/), streamline native code maintenance and upgrades with [CNG](/workflow/continuous-native-generation/), deploy faster with [EAS Update](/eas-update/introduction/), and more.
---
Note: Who uses Expo?
---
Expo is used by top companies worldwide that serve millions of end users. For more information, see our [Expo showcase](https://expo.dev/customers).
---
Note: What impact will adopting Expo have on my app's size?
---
The `expo` package has a small footprint since it only includes a minimal set of modules required in every app with autolinking infrastructure and other Expo SDK libraries that are built-in. For more information on how to determine the actual size of your app, see [Understanding app size](/distribution/app-size/).
---
Note: Why did React Native recommend using Expo?
---
Most React Native developers solve common problems when building an app, such as implementing navigation, accessing Native APIs, upgrading to new versions, and more. This requires using a specific set of tools and libraries to build and maintain your app &mdash; which means you are creating your own framework.
Expo solves these problems by providing a set of primitives and helping you (the developer) to focus on building your app. It also offers tools to iterate faster in development. For more information, see [Why React Native recommends using a framework](https://reactnative.dev/blog/2024/06/25/use-a-framework-to-build-react-native-apps).
---
Note: Do I have to get rid of my native projects to use Expo?
---
By default, Expo projects created with `create-expo-app` use [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) and do not contain **android** and **ios** native directories. If you incrementally adopt Expo in your existing React Native app, you don't have to remove these directories. You can use `npx expo run:[android|ios]` as an alternative to commands offered by `@react-native-community/cli` to compile your app locally and keep the configuration of your native projects.
---
Note: I use CodePush. Can I continue using it with Expo?
---
CodePush will be retired in March 2025 and is incompatible with React Native's New Architecture, so, in the long run, we recommend switching to EAS Update to manage remote updates to your app's code. However, you can start using Expo tools in your CodePush enabled app today, including the Expo SDK, Expo CLI, EAS Build, and more.
---
Note: Do I have to build with EAS?
---
[Expo Application Services (EAS)](/eas/) are deeply integrated cloud services for Expo and React Native apps that provide tools to build, test, and deploy your app.
Although we recommend using EAS for a smooth collaboration with your teammates and fast distribution, you can compile your app locally, on your CI, or any other way you prefer.
---
Note: Can I install third-party native libraries in my code?
---
Yes, you can install and use third-party libraries that require native projects (**android** and **ios**) configuration or provides a [config plugin](/config-plugins/introduction/) with [development builds](/workflow/overview/#development-builds). See [Using Third-Party libraries](/workflow/using-libraries/#third-party-libraries) for more information.
---
Note: I use React Navigation. Do I have to use Expo Router?
---
You can continue using any navigation library in your project. However, we recommend using Expo Router for all the benefits [described here](/router/introduction).
---


## Install Expo modules in an existing React Native project

Learn how to prepare your existing React Native project to install and use any Expo module.

To use Expo modules in your app, you will need to install and configure the `expo` package.
The `expo` package has a small footprint; it includes only a minimal set of packages that are needed in nearly every app and the module and autolinking infrastructure that other Expo SDK packages are built with. Once the `expo` package is installed and configured in your project, you can use `npx expo install` to add any other Expo module from the SDK.
Depending on how you [initialized the project](/bare/overview/), there are two ways you can install the Expo modules: [automatically](#automatic-installation) or [manually](#manual-installation).
## Automatic installation
To install and use Expo modules, the easiest way to get up and running is with the `install-expo-modules` command.
<InstallSection
  packageName="expo"
  cmd={[
    '# Install and configure the expo package automatically',
    '$ npx install-expo-modules@latest',
  ]}
  hideBareInstructions
/>
- <YesIcon small /> **When the command succeeds**, you will be able to add any Expo module in your
  app! Proceed to [Usage](#usage) for more information.
- <NoIcon small /> **If the command fails**, follow the manual installation instructions. Updating
  code programmatically can be tricky, and if your project deviates significantly from a default
  React Native project, then you need to perform manual installation and adapt the instructions here
  to your codebase.
## Manual installation
The following instructions apply to installing the latest version of Expo modules in React Native 0.81. For previous versions, check the [native upgrade helper](/bare/upgrade) to see how these files are customized.
<InstallSection packageName="expo" cmd={['$ npm install expo']} hideBareInstructions />
Once installation is complete, apply the changes from the following diffs to configure Expo modules in your project. This is expected to take about five minutes, and you may need to adapt it slightly depending on how customized your project is.
### Configuration for Android
<DiffBlock source="/static/diffs/expo-android.diff" />
### Configuration for iOS
<DiffBlock source="/static/diffs/expo-ios.diff" />
Optionally, you can also add additional delegate methods to your **AppDelegate.swift**. Some libraries may require them, so unless you have a good reason to leave them out, it is recommended to add them. [See delegate methods in AppDelegate.swift](https://github.com/expo/expo/blob/sdk-54/templates/expo-template-bare-minimum/ios/HelloWorld/AppDelegate.swift#L24-L42).
Save all of your changes and update your iOS Deployment Target in Xcode to `iOS 15.1`:
- Open **your-project-name.xcworkspace** in Xcode, select your project in the left sidebar.
- Select **Targets** > **your-project-name** > **Build Settings** > **iOS Deployment Target** and set it to `iOS 15.1`.
The last step is to install the project's CocoaPods again to pull in Expo modules that are detected by `use_expo_modules!` directive that we added to the **Podfile**:
<InstallSection
  packageName="expo"
  cmd={[
    '# Install pods',
    '$ npx pod-install',
    '',
    '# Alternatively, the run command will install them for you',
    '$ npx expo run:ios',
  ]}
  hideBareInstructions
/>
### Configure Expo CLI for bundling on Android and iOS
We recommend using Expo CLI and related tooling configurations to bundle your app JavaScript code and assets. This adds support for using the `"main"` field in **package.json** to use [Expo Router](/router/introduction/) library. Not using Expo CLI for bundling may result in unexpected behavior. [Learn more about Expo CLI](/bare/using-expo-cli/).
Note: Use babel-preset-expo in your babel.config.js
---
  <DiffBlock source="/static/diffs/babel-config.diff" />
---
Note: Extend expo/metro-config in your metro.config.js
---
  <DiffBlock source="/static/diffs/metro-config.diff" />
---
Note: Configure Android project to bundle with Expo CLI
---
  <DiffBlock source="/static/diffs/expo-cli-android.diff" />
---
Note: Configure iOS project to bundle with Expo CLI
---
Replace the shell script under **Build Phases** > **Bundle React Native code and images** in Xcode with the following:
```sh /bin/sh
if [[ -f "$PODS_ROOT/../.xcode.env" ]]; then
  source "$PODS_ROOT/../.xcode.env"
fi
if [[ -f "$PODS_ROOT/../.xcode.env.local" ]]; then
  source "$PODS_ROOT/../.xcode.env.local"
fi
# The project root by default is one level up from the ios directory
export PROJECT_ROOT="$PROJECT_DIR"/..
if [[ "$CONFIGURATION" = *Debug* ]]; then
  export SKIP_BUNDLING=1
fi
if [[ -z "$ENTRY_FILE" ]]; then
  # Set the entry JS file using the bundler's entry resolution.
  export ENTRY_FILE="$("$NODE_BINARY" -e "require('expo/scripts/resolveAppEntry')" "$PROJECT_ROOT" ios relative | tail -n 1)"
fi
if [[ -z "$CLI_PATH" ]]; then
  # Use Expo CLI
  export CLI_PATH="$("$NODE_BINARY" --print "require.resolve('@expo/cli')")"
fi
if [[ -z "$BUNDLE_COMMAND" ]]; then
  # Default Expo CLI command for bundling
  export BUNDLE_COMMAND="export:embed"
fi
`"$NODE_BINARY" --print "require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'"`
```
And add support the `"main"` field in **package.json** by making the following change to **AppDelegate.swift**:
```diff
diff --git a/ios/AppDelegate.swift b/ios/AppDelegate.swift
index 0000000..1111111 100644
--- a/ios/AppDelegate.swift
+++ b/ios/AppDelegate.swift
@@ -1,7 +1,7 @@
   override func bundleURL() -> URL? {
 #if DEBUG
-    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
+    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
 #else
     Bundle.main.url(forResource: "main", withExtension: "jsbundle")
 #endif
   }
```
---
## Usage
### Verifying installation
You can verify that the installation was successful by logging a value from [`expo-constants`](/versions/latest/sdk/constants).
- Run `npx expo install expo-constants`
- Then, run `npx expo run` and modify your app JavaScript code to add the following:
```js
import Constants from 'expo-constants';
console.log(Constants.systemFonts);
```
### Using Expo SDK packages
Once the `expo` package is installed and configured in your project, you can use `npx expo install` to add any other Expo module from the SDK. See [Using Libraries](/workflow/using-libraries) for more information.
### Expo modules included in the `expo` package
The following Expo modules are brought in as dependencies of the `expo` package:
- [`expo-asset`](/versions/latest/sdk/asset) - A JavaScript-only package that builds around `expo-file-system` and provides a common foundation for assets across all Expo modules.
- [`expo-constants`](/versions/latest/sdk/constants) - Provides access to the manifest.
- [`expo-file-system`](/versions/latest/sdk/filesystem) - Interact with the device file system. Used by `expo-asset` and many other Expo modules. Commonly used directly by developers in application code.
- [`expo-font`](/versions/latest/sdk/font) - Load fonts at runtime. This module is optional and can be safely removed, however; it is recommended if you use `expo-dev-client` for development and it is required by `@expo/vector-icons`.
- [`expo-keep-awake`](/versions/latest/sdk/keep-awake) - Prevents your device from going to sleep while developing your app. This module is optional and can be safely removed.
To exclude any of these modules, refer to the following guide on [excluding modules from autolinking](#excluding-specific-modules-from-autolinking).
### Excluding specific modules from autolinking
If you need to exclude native code from Expo modules you are not using, but were installed by other dependencies, you can use the [`expo.autolinking.exclude`](/modules/autolinking/#exclude) property in **package.json**:
```json package.json
{
  "name": "...",
  "dependencies": {},
  "expo": {
    "autolinking": {
      "exclude": ["expo-keep-awake"]
    }
  }
}
```


## Migrate from React Native CLI to Expo CLI

Learn how to migrate from React Native CLI (@react-native-community/cli) to Expo CLI for any React Native project.

To migrate from React Native CLI (`npx @react-native-community/cli@latest init`) to Expo CLI, you'll need to install the `expo` package, which includes the Expo Modules API and Expo CLI. This guide covers the installation step, the benefits of using Expo CLI, and how to compile and run your project after migrating to Expo CLI.
It is strongly recommended to use Expo CLI when using other Expo tools. It is required for many tools, such as EAS Update, Expo Router, and expo-dev-client, and other features may not work as well without it.
## Install the `expo` package
In most cases, executing the following command in a project directory to install the package is all you need to do:
```sh
$ npx install-expo-modules@latest
```
For a detailed installation guide, see [Install Expo modules](/bare/installing-expo-modules).
> **info** After installing the `expo` package, you'll need to configure your project to use Expo CLI. This includes setting up Metro config, Babel preset, and native project configurations. See the [Configure Expo CLI for bundling on Android and iOS](/bare/installing-expo-modules/#configure-expo-cli-for-bundling-on-android-and-ios) section for the complete setup instructions.
## Why Expo CLI instead of React Native CLI
Expo CLI commands provide several benefits over the similar commands in `@react-native-community/cli`, which includes:
- Instant access to Hermes debugger with <kbd>j</kbd> keystroke.
- The debugger ships with [React Native DevTools](/debugging/tools/#debugging-with-react-native-devtools).
- [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) support with [`expo prebuild`](/workflow/prebuild/) for upgrades, white-labeling, easy third-party package setup, and better maintainability of the codebase (by reducing the surface area).
- Support for file-based routing with [`expo-router`](/router/introduction/).
  - [Async bundling](/router/web/async-routes) in development.
- Built-in [environment variable support](/guides/environment-variables) and **.env** file integration.
- View native logs directly in the terminal alongside JavaScript logs.
- Improved native build log formatting using Expo CLI's `xcpretty`-style tool built specifically for React Native apps. For example, when compiling a Pod, you can see which Node module included it.
- [First-class TypeScript support](/guides/typescript).
- Support for **tsconfig.json** aliases with `paths` and `baseUrl` [built-in to Metro](/guides/typescript/#path-aliases-optional).
- [Web support](/guides/customizing-metro/#adding-web-support-to-metro) with Metro. Fully typed for React Native Web.
- Modern [CSS support](/versions/latest/config/metro#css) with Tailwind, PostCSS, CSS Modules, SASS, and more.
- Static site generation with Expo Router and Metro web.
- Out of the box [support for monorepos](/guides/monorepos).
- Support for Expo tooling such as [`expo-dev-client`](/develop/development-builds/introduction), the [Expo Updates protocol](/technical-specs/expo-updates-1) and [EAS Update](/eas-update/introduction).
- Automated `pod install` execution when using `npx expo run:ios`.
- `npx expo install` selects compatible dependency versions for well-known packages.
- Automatic port detection when running `npx expo run:[android|ios]` and `npx expo start`. If another app is running on the default port, a different port is used.
- Android or iOS device launch selection shortcuts using <kbd>Shift</kbd> + <kbd>a</kbd> or <kbd>Shift</kbd> + <kbd>i</kbd> from the interactive prompt.
- Built-in support for serving your app over an [ngrok tunnel](/develop/development-builds/development-workflows/#tunnel-urls).
- Develop on any port with any entry JavaScript file.
We recommend Expo CLI for most React Native projects that target Android, iOS, and/or web. It does not yet have built-in support for the most popular out-of-tree platforms, such as
Windows and macOS. If building for these platforms, you can utilize Expo CLI for the supported platforms and `@react-native-community/cli` for the others.
## Compile and run your app
After installing the `expo` package, you can use the following commands which are alternatives to `npx react-native run-android` and `npx react-native run-ios`:
```sh
$ npx expo run:android
$ npx expo run:ios
```
When building your project, you can choose a device or simulator by using the `--device` flag. This also applies to any iOS device that is connected to your computer.
## Start the bundler independently
`npx expo run:[android|ios]` automatically starts the bundler/development server. If you want to independently start the bundler with `npx expo start` command, pass the `--no-bundler` to the `npx expo run:[android|ios]` command.
## Common questions
Note: Can I use Expo CLI without installing the Expo Modules API?
---
Expo Modules API is also installed when you install the `expo` package with `npx install-expo-modules`. If you want to try out Expo CLI for now without installing Expo Modules API, install the `expo` package with `npm install` and then configure the **react-native.config.js** to exclude the package from autolinking:
```js react-native.config.js
module.exports = {
  dependencies: {
    expo: {
      platforms: {
        android: null,
        ios: null,
        macos: null,
      },
    },
  },
};
```
> **Note:** Without Expo API Modules installed, certain features such as `expo-dev-client` or `expo-router` are unavailable.
---
Note: Can I use prebuild for out-of-tree platforms, such as macOS or Windows?
---
Yes! Refer to the [Customized Prebuild Example repository](https://github.com/byCedric/custom-prebuild-example) for more information.
---
## Next steps
Now, with the `expo` package installed and configured in your project, you can start using all features from Expo CLI and SDK. Here are some recommended next steps to dive deep:


## Install expo-updates in an existing React Native project

Learn how to install and configure expo-updates in your existing React Native project.

`expo-updates` is a library that enables your app to manage remote updates to your application code. It communicates with the configured remote update service to get information about available updates. This guide explains how to set up a bare React Native project for use with [EAS Update](/eas-update/introduction), a hosted remote update service that includes tools to simplify installation and configuration of the `expo-updates` library.
Note: Do you use Continuous Native Generation (CNG) in your project?
---
You may be reading the wrong guide. To use `expo-updates` in a project that uses [CNG](/workflow/continuous-native-generation/), see [EAS Update "Get started"](/eas-update/getting-started/).
---
## Prerequisites
**The `expo` package must be installed and configured.** If you created your project with `npx @react-native-community/cli@latest init` and do not have any other Expo libraries installed, you will need to [install Expo modules](/bare/installing-expo-modules) before proceeding.
## Installation
To get started, install `expo-updates`:
```sh
$ npx expo install expo-updates
```
Then, install pods for iOS:
```sh
$ npx pod-install
```
## Configuring expo-updates library
Apply the changes from the diffs from the following sections to configure `expo-updates` in your project.
### JavaScript and JSON
Run `eas update:configure` to set the `updates` URL and `projectId` in **app.json**.
```sh
$ eas update:configure
```
Modify the `expo` section of **app.json**. If you created your project using `npx @react-native-community/cli@latest init`, you will need to add the following changes including the [`updates` URL](/versions/latest/config/app/#url).
> The example `updates` URL and `projectId` shown below are used with EAS Update. The EAS CLI sets this URL correctly for the EAS Update service when running `eas update:configure`.
<DiffBlock source="/static/diffs/expo-updates-app-json.diff" />
If you want to set up a [custom `expo-updates` server](https://github.com/expo/custom-expo-updates-server) instead, add your URL to `updates.url` in **app.json**.
```diff
diff --git a/app.json b/app.json
index 0000000..1111111 100644
--- a/app.json
+++ b/app.json
@@ -1,7 +1,7 @@
   "expo": {
     "name": "MyApp",
-    "updates": {
-      "url": "https://u.expo.dev/[your-project-id]"
-    }
+    "updates": {
+      "url": "http://localhost:3000/api/manifest"
+    }
   }
 }
```
### Android
Modify **android/app/build.gradle** to check for the JS engine configuration (JSC or Hermes) in Expo files:
<DiffBlock source="/static/diffs/expo-updates-android-build-gradle.diff" />
Modify **android/app/src/main/AndroidManifest.xml** to add the `expo-updates` configuration XML so that it matches the contents of **app.json**:
<DiffBlock source="/static/diffs/expo-updates-android-manifest.diff" />
If using the updates server URL (a custom non-HTTPS update server running on the same machine), you will need to modify **android/app/src/main/AndroidManifest.xml** to add the update server URL and enable `usesCleartextTraffic`:
<DiffBlock source="/static/diffs/expo-updates-android-manifest-cleartext.diff" />
Add the Expo runtime version string key to **android/app/src/main/res/values/strings.xml**:
<DiffBlock source="/static/diffs/expo-updates-strings-xml.diff" />
### iOS
Add the file **Podfile.properties.json** to the **ios** directory:
```json ios/Podfile.properties.json
{
  "expo.jsEngine": "hermes"
}
```
Modify **ios/Podfile** to check for the JS engine configuration (JSC or Hermes) in Expo files:
<DiffBlock source="/static/diffs/expo-updates-ios-podfile.diff" />
Using Xcode, add **Expo.plist** file to **ios/your-project/Supporting** with the following content to match the contents of **app.json**:
```xml Expo.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>EXUpdatesCheckOnLaunch</key>
    <string>ALWAYS</string>
    <key>EXUpdatesEnabled</key>
    <true/>
    <key>EXUpdatesLaunchWaitMs</key>
    <integer>0</integer>
    <key>EXUpdatesRuntimeVersion</key>
    <string>1.0.0</string>
    <key>EXUpdatesURL</key>
    <string>http://localhost:3000/api/manifest</string>
  </dict>
</plist>
```
## Next steps
- To start using EAS Update with EAS Build, see the EAS Update [Get started](/eas-update/getting-started/).
- See [`expo-updates` API reference](/versions/latest/sdk/updates/) for more information on how to use the library.
- See how to use [EAS Update with a local build directly](/eas-update/standalone-service/).
- It is also possible to use `expo-updates` with a custom server that implements the [Expo Updates protocol](/technical-specs/expo-updates-1/). See [`custom-expo-updates-server` README](https://github.com/expo/custom-expo-updates-server#readme).


## Install expo-dev-client in an existing React Native project

Learn how to install and configure expo-dev-client in your existing React Native project.

The following guide explains how to install and configure `expo-dev-client` in an existing React Native project.
Note: Do you need to create a new project?
---
If you're starting with a new project, create it using the `with-dev-client` template:
```sh
$ npx create-expo-app -e with-dev-client
```
---
Note: Do you use Continuous Native Generation (CNG) in your project?
---
To use `expo-dev-client` in a project that uses [CNG](/workflow/continuous-native-generation/), see [Create a development build](/develop/development-builds/create-a-build/).
---
## Prerequisites
**The `expo` package must be installed and configured.** If you created your project with `npx @react-native-community/cli@latest init` and do not have any other Expo libraries installed, you will need to [install Expo modules](/bare/installing-expo-modules) before proceeding.
Step 1: 
## Install expo-dev-client
Add the `expo-dev-client` library to your **package.json**:
```sh
$ npx expo install expo-dev-client
```
If your project has an **ios** directory on disk, run the following command to fully install the native code for `expo-dev-client`:
```sh
$ npx pod-install
```
If your project doesn't have an **ios** directory, you can skip this step.
Step 2: 
## Configure deep links
Expo CLI uses a deep link to launch your project, and it's also useful if you use plan to [use `expo-dev-client` for launching preview updates](/eas-update/getting-started/) if you have added a custom deep link scheme to your project.
If you haven't configured a `scheme` for your app yet to support deep linking, then use `uri-scheme` library to do this for you.
```sh
$ npx uri-scheme list
$ npx uri-scheme add your-scheme
```
For more information, see the [`uri-scheme` library](https://www.npmjs.com/package/uri-scheme).
Step 3: 
## Build and install the app
Create a debug build of your app using the tools of your choice. For example, you can do this [locally with Expo CLI](/guides/local-app-development/) or [in the cloud with EAS Build](/develop/development-builds/create-a-build/).


## Native project upgrade helper

View file-by-file diffs of all the changes you need to make to your native projects to upgrade them to the next Expo SDK version.

If you manage your native projects (previously known as bare workflow), to [upgrade to the latest Expo SDK](/workflow/upgrading-expo-sdk-walkthrough/), you have to make changes to your native projects. It can be a complex process to find which native file changes and what to update in which file.
The following guide provides diffs to compare native project files between your project's current SDK version and the target SDK version you want to upgrade. You can use them to make changes to your project depending on the `expo` package version your project uses. The tools on this page are similar to [React Native Upgrade Helper](https://react-native-community.github.io/upgrade-helper/). However, they are oriented around projects that use Expo modules and related tooling.
> Interested in avoiding upgrading native code altogether? See [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) to learn how Expo Prebuild can generate your native projects before a build.
## Upgrade native project files
Once you have [upgraded your Expo SDK version and related dependencies](/workflow//upgrading-expo-sdk-walkthrough/#how-to-upgrade-to-the-latest-sdk-version), use the diff tool below to learn about changes you need to make to your native project and bring them up to date with the current Expo SDK version.
Choose your **from SDK version** and **to SDK version** to see the generated diff. Then, apply those changes to your native projects by copying and pasting or manually making changes to the project files.
<TemplateBareMinimumDiffViewer />


# Existing native apps

## Integrating Expo tools into existing native apps

An overview of how you can integrate Expo tools into existing native apps ("brownfield" apps).

An existing native app that was built using another technology, whose main entry point is _not_ a React Native view, is commonly referred to as a "brownfield" app. For example, if your app was built using UIKit and Swift, and you want to use React Native for a single screen then that is considered an "existing native app" and "brownfield".
In contrast, "greenfield" apps are created using Expo or React Native from the start or where React Native is the entry point and where all other UI branches off from.
By these definitions, if you have an "existing native app" for Android or iOS and you want to learn how to use Expo and React Native in your project (perhaps on a single screen or even a single feature), then this guide is for you.
## Compatibility with existing native apps
> **info** Support for integrating Expo modules into existing native projects is in alpha. If you encounter issues, [create an issue on GitHub](https://github.com/expo/expo/issues). Not all features of the tools and services below will be available when used in the context of an existing native app.
Expo is primarily built with greenfield apps in mind, but we are increasingly investing in brownfield scenarios. Not all Expo tools and services are compatible with existing native projects yet. Additionally, comprehensive documentation for brownfield integrations may not yet available, and you may need to adapt other related documentation to your context.
| Tool/Service                                                                                         | Supports brownfield? |
| ---------------------------------------------------------------------------------------------------- | -------------------- |
| [Expo SDK](/versions/latest/) - an extended standard library for React Native                        | Yes                  |
| [Expo Modules API](/modules/overview/) - build native extensions using an idiomatic Swift/Kotlin API | Yes                  |
| [Expo Router](/router/introduction/) - file-based routing and navigation                             | No                   |
| [Expo CLI](/more/expo-cli/) - tools to run and develop your app from your terminal                   | Yes                  |
| [Expo Dev Client](/versions/latest/sdk/dev-client/) - adds in-app developer tooling to Debug builds  | No                   |
| [EAS Build](/build/introduction/) - a CI/CD service built specifically for Expo/React Native         | Yes                  |
| [EAS Submit](/submit/introduction/) - a hosted service that uploads your app to stores               | Yes                  |
| [EAS Update](/eas-update/introduction/) - instant updates of your app JavaScript and assets          | Yes                  |
## Next steps


## How to add Expo to an existing native (brownfield) app

A guide for adding Expo and React Native to existing native apps and adding a first view component.

React Native and Expo are flexible and can be adopted incrementally, one screen (or even one view) at a time. You might even find that using Expo in this way is the best fit for your particular application, or you may end up slowly adopting it across more surfaces in your app. Either way, this flexibility allows enables developers to adopt modern, cross-platform tools in their native apps immediately instead of risking a complete rewrite.
This guide will walk you through the steps to add a React Native view into an existing native app. The approach covered here is what we call the "integrated" approach, because React Native and Expo are integrated in the same way that you would any other library.
Another popular technique is what we call the "isolated" approach, where your Expo app is packaged as a library and treated as a black box by the main existing application. A guide for the isolated approach will be available shortly. Now, back to using the "integrated" approach in your existing native app.
## Prerequisites
To integrate React Native into your existing application, you'll need to set up a JavaScript development environment. This includes installing Node.js to run Expo CLI and Yarn to manage the project's JavaScript dependencies.
- [Node.js (LTS)](https://nodejs.org/en/): The runtime to execute JavaScript code and Expo CLI.
- [Yarn](https://yarnpkg.com/): A package manager for installing and managing JavaScript dependencies.
- <PlatformTag platform="ios" /> [CocoaPods](https://cocoapods.org/): one of the dependency
  management system available for iOS. CocoaPods is a Ruby
  [gem](https://en.wikipedia.org/wiki/RubyGems). You can install CocoaPods using the version of Ruby
  that ships with the latest version of macOS.
Learn more from the [Set up environment guide](/get-started/set-up-your-environment/).
## Create an Expo project
First, create an Expo project inside your existing native project's root directory.
```sh
$ npx create-expo-app my-project
```
This command creates a new directory named **my-project** that contains your new Expo project. While you can name the project anything, this guide uses **my-project** for consistency. The new project includes an example TypeScript application to help you get started.
## Set up your project structure
A standard React Native project places native code in **android** and **ios** directories. The specifics of how to do this depend on your project, but it could be as simple as creating the directories and moving your projects there. For example:
For Android: 
```sh
$ mkdir my-project/android
$ mv /path/to/your/android-project my-project/android/
```
For iOS: 
```sh
$ mkdir my-project/ios
$ mv /path/to/your/ios-project my-project/ios/
```
Note: Can't move your native projects to android and ios directories?
---
### Set up a monorepo
Monorepos, or "monolithic repositories", are single repositories containing multiple apps or packages. [Learn more](/guides/monorepos/).
Setting up a monorepo will ensure that Android and iOS scripts will be able to invoke commands from Node libraries even with a custom folder structure. To set up a Yarn monorepo, create a **package.json** file at the root of your project and add the following content:
```json package.json
{
  "version": "1.0.0",
  "private": true,
  "workspaces": ["my-project"]
}
```
Then run `yarn install` to install the dependencies. This will ensure **node_modules** are installed at the root of your project, and that native scripts can interact with React Native code. Make sure to change `["my-project"]` to the name of the Expo project you created in the previous step.
> **info** Opting for a monorepo requires you to configure a custom project root, in Gradle/CocoaPods. This will be covered in the next sections.
---
## Configuring your native project
To integrate React Native on Android, you need to configure the native project by modifying the following files:
- **Gradle files**: **settings.gradle**, top-level **build.gradle**, **app/build.gradle**, and **gradle.properties** to add the React Native Gradle Plugin (RNGP) and other properties.
- **AndroidManifest.xml**: To add necessary permissions. ([Learn more](#configuring-your-manifest))
- **MainActivity**: To load your React Native application.
### Configuring Gradle
Step 1: 
Start by editing your **settings.gradle** file and add the following lines (Use the [bare minimum template](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/settings.gradle) as a reference):
```groovy settings.gradle
// Configures the React Native Gradle Settings plugin used for autolinking
pluginManagement {
  def reactNativeGradlePlugin = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('@react-native/gradle-plugin/package.json', { paths: [require.resolve('react-native/package.json')] })")
    }.standardOutput.asText.get().trim()
  ).getParentFile().absolutePath
  includeBuild(reactNativeGradlePlugin)
  def expoPluginsPath = new File(
    providers.exec {
      workingDir(rootDir)
      commandLine("node", "--print", "require.resolve('expo-modules-autolinking/package.json', { paths: [require.resolve('expo/package.json')] })")
    }.standardOutput.asText.get().trim(),
    "../android/expo-gradle-plugin"
  ).absolutePath
  includeBuild(expoPluginsPath)
}
plugins {
  id("com.facebook.react.settings")
  id("expo-autolinking-settings")
}
extensions.configure(com.facebook.react.ReactSettingsExtension) { ex ->
  ex.autolinkLibrariesFromCommand(expoAutolinking.rnConfigCommand)
}
expoAutolinking.useExpoModules()
// rootProject.name = 'HelloWorld'
expoAutolinking.useExpoVersionCatalog()
includeBuild(expoAutolinking.reactNativeGradlePlugin)
// Include your existing Gradle modules here.
// include(":app")
```
Note: Using a custom folder structure?
---
If you're using a custom folder structure, you need to explicitly set your project root in **settings.gradle** for autolinking to work. Modify the following lines:
<DiffBlock source="/static/diffs/brownfield/android/settings-gradle-custom-root.diff" />
---
Step 2: 
Then open your top-level **build.gradle** and include this line (as suggested from the [bare minimum template](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/build.gradle)):
<DiffBlock source="/static/diffs/brownfield/android/build-gradle.diff" />
This makes sure the React Native Gradle and the Expo plugins are available and applied inside your project.
Step 3: 
Add the following lines inside your app's **build.gradle** file (usually **app/build.gradle** &mdash; you can use the [bare minimum template file as reference](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/app/build.gradle)):
<DiffBlock source="/static/diffs/brownfield/android/app-build-gradle.diff" />
Note: Using a custom folder structure?
---
If you're using a custom folder structure, you need to adjust the `projectRoot` value to point to root of your Expo project in **app/build.gradle**. Modify the following lines:
<DiffBlock source="/static/diffs/brownfield/android/app-build-gradle-custom-root.diff" />
---
Step 4: 
Finally, open your app's **gradle.properties** file and add the following lines (use the [bare minimum template file as reference](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/gradle.properties)):
```properties gradle.properties
reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64
newArchEnabled=true
hermesEnabled=true
```
### Configuring your manifest
Step 1: 
First, make sure you have the `INTERNET` permission in your **AndroidManifest.xml**:
<DiffBlock source="/static/diffs/brownfield/android/android-manifest-internet-permission.diff" />
Step 2: 
Now in your **debug** **AndroidManifest.xml**, enable [cleartext traffic](https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted):
<DiffBlock source="/static/diffs/brownfield/android/android-manifest-cleartext-traffic.diff" />
This is necessary for your app to communicate with your local [Metro bundler](https://metrobundler.dev/) via HTTP. You can use the **AndroidManifest.xml** files from the bare minimum template as a reference: [main](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/app/src/main/AndroidManifest.xml) and [debug](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/app/src/debug/AndroidManifest.xml)
### Integrating with your code
Now, you need to add some native code to start the React Native runtime and tell it to render your React components.
#### Updating your `Application` class
Start by updating your `Application` class to initialize React Native. You can use **MainApplication.kt** from the [bare minimum template](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/app/src/main/java/com/helloworld/MainApplication.kt) as a reference:
<DiffBlock source="/static/diffs/brownfield/android/main-application.diff" />
#### Creating a `ReactActivity`
Create a new `Activity` that will extend `ReactActivity` and host the React Native code. This activity will be responsible for starting the React Native runtime and rendering the React component. You can use the [**MainActivity.kt** from bare minimum template file](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/android/app/src/main/java/com/helloworld/MainActivity.kt) as a reference:
```kotlin MyReactActivity.kt
// package <your-package-here>
import android.os.Build
import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate
import expo.modules.ReactActivityDelegateWrapper
class MyReactActivity : ReactActivity() {
  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "main"
  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate {
    return ReactActivityDelegateWrapper(
          this,
          BuildConfig.IS_NEW_ARCHITECTURE_ENABLED,
          object : DefaultReactActivityDelegate(
              this,
              mainComponentName,
              fabricEnabled
          ){})
  }
}
```
Add the new Activity to your **AndroidManifest.xml** file, make sure to set the theme of `MyReactActivity` to `Theme.AppCompat.Light.NoActionBar` (or to any non-ActionBar theme) to avoid your application rendering an `ActionBar` on top of the React Native screen:
<DiffBlock source="/static/diffs/brownfield/android/android-manifest-add-activity.diff" />
Now your activity is ready to run some JavaScript code.
To integrate React Native on iOS, you need to configure the native iOS project by modifying the following files:
- **Podfile**: To add the React Native dependencies.
- **Xcode project**: To add a build phase for bundling JavaScript code.
- **Info.plist**: To configure app settings required by React Native.
### Configuring CocoaPods
If your project does not have a **Podfile**, you can create one using the [bare minimum template](https://github.com/expo/expo/blob/main/templates/expo-template-bare-minimum/ios/Podfile) as a reference:
```rb Podfile
require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")
require 'json'
platform :ios, '15.1'
install! 'cocoapods',
  :deterministic_uuids => false
prepare_react_native_project!
target 'HelloWorld' do
  use_expo_modules!
  config_command = [
    'npx',
    'expo-modules-autolinking',
    'react-native-config',
    '--json',
    '--platform',
    'ios'
  ]
  config = use_native_modules!(config_command)
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']
  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => true,
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => true,
  )
  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
    )
  end
end
```
If your project already has a **Podfile**, you'll need to manually merge the React Native dependencies into your existing **Podfile**.
Note: Using a custom folder structure?
---
If you're using a custom folder structure, you need to explicitly set your project root in **Podfile** for autolinking to work. Modify the following lines in your **Podfile**:
<DiffBlock source="/static/diffs/brownfield/ios/podfile-custom-root.diff" />
---
Now, run the following command:
```sh
$ pod install
```
Running the `pod` command will integrate the React Native code into your app, allowing your iOS files to import the React Native headers.
### Configuring your Xcode project
Step 1: 
After the `pod install` command, CocoaPods will create an Xcode workspace **\{Project\}.xcworkspace**, you will need to open the **xcworkspace** project than the traditional **xcodeproj** project. Alternatively, you can use the following command to open the project:
```sh
$ xed my-project/ios
```
In the Xcode project navigator, select your project and then select
your app target under `TARGETS`. In **Build Settings**, using the search bar, search for
`ENABLE_USER_SCRIPT_SANDBOXING`. If it is not already, set its value to `No`. This is needed to
properly switch between the Debug and Release versions of the [Hermes
engine](https://github.com/facebook/hermes/blob/main/README.md) that is shipped with React Native.
Step 2: 
Now switch to the **Build Phases** tab and add a new `Run Script Phase` before the `[CP] Embed Pods Frameworks` phase. This script will bundle your JavaScript code and assets into the iOS application.
```sh Build React Native code and image
if [[ -f "$PODS_ROOT/../.xcode.env" ]]; then
  source "$PODS_ROOT/../.xcode.env"
fi
if [[ -f "$PODS_ROOT/../.xcode.env.local" ]]; then
  source "$PODS_ROOT/../.xcode.env.local"
fi
# The project root by default is one level up from the ios directory
export PROJECT_ROOT="$PROJECT_DIR"/..
if [[ "$CONFIGURATION" = *Debug* ]]; then
  export SKIP_BUNDLING=1
fi
if [[ -z "$ENTRY_FILE" ]]; then
  # Set the entry JS file using the bundler's entry resolution.
  export ENTRY_FILE="$("$NODE_BINARY" -e "require('expo/scripts/resolveAppEntry')" "$PROJECT_ROOT" ios absolute | tail -n 1)"
fi
if [[ -z "$CLI_PATH" ]]; then
  # Use Expo CLI
  export CLI_PATH="$("$NODE_BINARY" --print "require.resolve('@expo/cli', { paths: [require.resolve('expo/package.json')] })")"
fi
if [[ -z "$BUNDLE_COMMAND" ]]; then
  # Default Expo CLI command for bundling
  export BUNDLE_COMMAND="export:embed"
fi
# Source .xcode.env.updates if it exists to allow
# SKIP_BUNDLING to be unset if needed
if [[ -f "$PODS_ROOT/../.xcode.env.updates" ]]; then
  source "$PODS_ROOT/../.xcode.env.updates"
fi
# Source local changes to allow overrides
# if needed
if [[ -f "$PODS_ROOT/../.xcode.env.local" ]]; then
  source "$PODS_ROOT/../.xcode.env.local"
fi
`"$NODE_BINARY" --print "require('path').dirname(require.resolve('react-native/package.json')) + '/scripts/react-native-xcode.sh'"`
```
Next time, when you build your app for Release, the React Native code will be bundled using Expo CLI and embedded into the app.
Step 3: 
Edit your **Info.plist** file and make sure to add the `UIViewControllerBasedStatusBarAppearance` key with a value of `NO`, this is needed to ensure that the status bar is properly managed by React Native.
<DiffBlock source="/static/diffs/brownfield/ios/info-plist.diff" />
### Integrating with your code
Now, you need to add some native code to start the React Native runtime and tell it to render your React components.
#### Create the ReactViewController
Create a new file called **ReactViewController.swift**, this will be the `ViewController` that loads a React Native view as its `view`.
```swift ReactViewController.swift
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
class ReactNativeViewController: UIViewController {
  var reactNativeFactory: RCTReactNativeFactory?
  var reactNativeFactoryDelegate: RCTReactNativeFactoryDelegate?
  override func viewDidLoad() {
    super.viewDidLoad()
    reactNativeFactoryDelegate = ReactNativeDelegate()
    reactNativeFactoryDelegate!.dependencyProvider = RCTAppDependencyProvider()
    reactNativeFactory = RCTReactNativeFactory(delegate: reactNativeFactoryDelegate!)
    view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld")
  }
}
class ReactNativeDelegate: RCTDefaultReactNativeFactoryDelegate {
    override func sourceURL(for bridge: RCTBridge) -> URL? {
      self.bundleURL()
    }
    override func bundleURL() -> URL? {
      #if DEBUG
      RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: ".expo/.virtual-metro-entry")
      #else
      Bundle.main.url(forResource: "main", withExtension: "jsbundle")
      #endif
    }
}
```
#### Presenting a React Native view in a rootViewController
Finally, you can present your React Native view. To do so, you need a new View Controller that can host a view in which we can load the JS content. You already have the initial `ViewController`, and you can make it present the `ReactViewController`. There are several ways to do so, depending on your app. For this example, let's assume that you have a button that presents React Native modally.
```swift ViewController.swift
import UIKit
class ViewController: UIViewController {
  var reactViewController: ReactViewController?
  override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.
    self.view.backgroundColor = .systemBackground
    let button = UIButton()
    button.setTitle("Open React Native", for: .normal)
    button.setTitleColor(.systemBlue, for: .normal)
    button.setTitleColor(.blue, for: .highlighted)
    button.addAction(UIAction { [weak self] _ in
      guard let self else { return }
      if reactViewController == nil {
       reactViewController = ReactViewController()
      }
      present(reactViewController!, animated: true)
    }, for: .touchUpInside)
    self.view.addSubview(button)
    button.translatesAutoresizingMaskIntoConstraints = false
    NSLayoutConstraint.activate([
      button.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),
      button.trailingAnchor.constraint(equalTo: self.view.trailingAnchor),
      button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor),
      button.centerYAnchor.constraint(equalTo: self.view.centerYAnchor),
    ])
  }
}
```
## Test your integration
You have completed all the basic steps to integrate React Native with your application. Now run the following command in the React Native directory to start the [Metro bundler](https://metrobundler.dev/)
```sh
$ yarn start
```
Metro builds your TypeScript application code into a bundle, serves it through its HTTP server, and shares the bundle from `localhost` on your developer environment to a simulator or device, allowing for [hot reloading](https://reactnative.dev/blog/2016/03/24/introducing-hot-reloading). Now you can build and run your app as normal. Once you reach your React-powered Activity inside the app, it should load the JavaScript code from the development server.


## Configuring lifecycle listeners

Learn about the mechanism that allows the Expo Modules API to hook into the lifecycle of your app.

Some Expo libraries need to handle system events such as deep links, push notifications, and configuration changes by implementing `Activity`/`Application` or `AppDelegate` lifecycle callbacks.
The Expo Modules API provides an easy way to manage such callbacks:
- <PlatformTag platform="android" /> `ApplicationLifecycleDispatcher` and `ReactActivityHandler`
  forward `Application` and `Activity` lifecycle events to registered listeners. Modules can provide
  `ReactActivityLifecycleListener` and `ApplicationLifecycleListener` implementations through a
  `Package` class to register callbacks.
- <PlatformTag platform="ios" /> `ExpoAppDelegate` forwards `AppDelegate` calls to registered
  subscribers. Modules can provide an `ExpoAppDelegateSubscriber` implementation to register
  callbacks.
Using these mechanisms allows modules to register behavior without requiring you to edit native entry points repeatedly.
## Configure your native project
### Android
To integrate `Application` lifecycle listeners on Android, forward the `onCreate()` and `onConfigurationChanged()` calls from your `Application` class to `ApplicationLifecycleDispatcher`:
<DiffBlock source="/static/diffs/brownfield/lifecycle-listeners/application-lifecycle-dispatcher.diff" />
### iOS
To integrate `AppDelegate` subscribers on iOS, forward the relevant calls to `ExpoAppDelegateSubscriberManager` in your existing `AppDelegate` implementation so that subscribers can respond to them:
<DiffBlock source="/static/diffs/brownfield/lifecycle-listeners/expo-app-delegate-subscriber-manager.diff" />
Alternatively, if your `AppDelegate` doesn't already extend another class, you can simplify the setup by inheriting from `ExpoAppDelegate`, which handles the forwarding automatically:
<DiffBlock source="/static/diffs/brownfield/lifecycle-listeners/expo-app-delegate.diff" />
> **Note:** Not all `UIApplicationDelegate` methods that could cause significant side effects are supported. See the Expo source (**ExpoAppDelegate.swift**) for the full list of forwarded methods if you need to rely on a specific delegate.
## Test your integration
To test if the callbacks are working correctly, install a module that relies on them. Install `expo-linking`, which uses lifecycle listeners to handle deep links:
```sh
$ npx expo install expo-linking
```
Add a listener for deep links in your code and observe the console when opening a deep link:
```jsx
import * as Linking from 'expo-linking';
import { useEffect } from 'react';
useEffect(() => {
  const listener = Linking.addEventListener('url', ({ url }) => {
    console.log('Received deep link:', url);
  });
  return listener.remove;
}, []);
```
Run the following command to open a deep link to your app:
```sh
$ npx uri-scheme open com.example.app://somepath/details --android
$ npx uri-scheme open myapp://somepath/details --ios
```


# Expo Router

## Introduction to Expo Router

Expo Router is an open-source routing library for Universal React Native applications built with Expo.

Expo Router is a file-based router for React Native and web applications. It allows you to manage navigation between screens in your app, allowing users to move seamlessly between different parts of your app's UI, using the same components on multiple platforms (Android, iOS, and web).
It brings the best file-system routing concepts from the web to a universal application &mdash; allowing your routing to work across every platform. When a file is added to the **app** directory, the file automatically becomes a route in your navigation.
You can also see the following playlist to get started with Expo Router:
## Features
- **Native**: Built on top of our powerful [React Navigation suite](https://reactnavigation.org/), Expo Router navigation is truly native and platform-optimized by default.
- **Shareable**: Every screen in your app is automatically deep linkable. Making any route in your app shareable with links.
- **Offline-first**: Apps are cached and run offline-first, with automatic updates when you publish a new version. Handles all incoming native URLs without a network connection or server.
- **Optimized**: Routes are automatically optimized with lazy-evaluation in production, and deferred bundling in development.
- **Iteration**: Universal Fast Refresh across Android, iOS, and web, along with artifact memoization in the bundler to keep you moving fast at scale.
- **Universal**: Android, iOS, and web share a unified navigation structure, with the ability to drop-down to platform-specific APIs at the route level.
- **Discoverable**: Expo Router enables build-time static rendering on web, and universal linking to native. Meaning your app content can be indexed by search engines.
### Using a different navigation library
You can use any other navigation library, like [React Navigation](https://reactnavigation.org/docs/getting-started#installation), in your Expo project. However, if you are building a new app, **we recommend using Expo Router for all the features described above**. With other navigation libraries, you might have to implement your own strategies for some of these features, such as shareable links or handling web and native navigation in the same project.
If you are looking to use [React Native Navigation by Wix](https://github.com/wix/react-native-navigation), it is not available in Expo Go and is not yet compatible with `expo-dev-client`. We recommend using [`createNativeStackNavigator`](https://reactnavigation.org/docs/native-stack-navigator) from React Navigation to use Android and iOS native navigation APIs.
## Common questions
Note: Expo Router versus Expo versus React Native CLI
---
Historically, React Native has been non prescriptive about how apps should be built which is similar to using React without a modern web framework. Expo Router is an opinionated framework for React Native, similar to how Remix and Next.js are opinionated frameworks for web-only React.
Expo Router is designed to bring the best architectural patterns to everyone, to ensure React Native is leveraged to its fullest. For example, Expo Router's [Async Routes](/router/web/async-routes) feature enables lazy bundling for everyone. Previously, lazy bundling was only used at Meta to build the Facebook app.
---
Note: Can I use Expo Router in my existing React Native app?
---
Yes, Expo Router is the framework for universal React Native apps. Due to the deep connection between the router and the bundler, Expo Router is only available in Expo CLI projects with Metro. Luckily, you can [use Expo CLI in any React Native project](/bare/using-expo-cli/) too!
---
Note: What are the benefits of file-based routing?
---
- The file system is a well-known and well-understood concept. The simpler mental model makes it easier to educate new team members and scale your application.
- The fastest way to onboard new users is by having them open a universal link that opens the app or website to the correct screen depending on if they have the app installed or not. This technique is so advanced that it's usually only available to large companies that can afford to make and maintain the parity between platforms. But with Expo's file-based routing, you can have this feature out of the box!
- Refactoring is easier to do because you can move files around without having to update any imports or routing components.
- Expo Router has the ability to statically type routes automatically. This ensures you can only link to valid routes and that you can't link to a route that doesn't exist. Typed Routes also improve refactoring as you'll get type errors if links are broken.
- Async Routes (bundle splitting) improve development speed, especially in larger projects. They also make upgrades easier as errors are isolated to a single route, meaning you can incrementally update or refactor your app page-by-page rather than all at once (traditional React Native).
- Deep links always work, for every page. This makes it possible to share links to any content in the app, which is great for promoting your app, collecting bug reports, E2E testing, automating screenshots, and so on.
- Expo Head uses automatic links to enable deep-native integration. Features like Quick Notes, Handoff, Siri context, and universal links only require configuration setup, no code changes. This enables perfect vertical integration with the entire ecosystem of smart devices that a user has, leading to the types of user experiences that are only possible with universal apps (web ⇄ native).
- Expo Router has the ability to statically render each page automatically on the web, enabling real SEO and full discoverability of your app's content. This is only possible because of the file-based convention.
- **Expo CLI** can infer a lot of information about your application when it follows a known convention. For example, we could implement automatic bundle splitting per route, or automatically generate a sitemap for your website. This is impossible when your app only has a single entry point.
- Re-engagement features like notifications and home screen widgets are easier to integrate as you can simply intercept the launch and deep link, with query parameters, anywhere in the app.
- Like on the web, analytics and error reporting can easily be configured to automatically include the route name, which is useful for debugging and understanding user behavior.
---
Note: Why should I use Expo Router over React Navigation?
---
Expo Router and React Navigation are both libraries from the Expo team. We built Expo Router on top of React Navigation to enable the benefits of file-based routing. Expo Router is a superset of React Navigation, meaning you can use any React Navigation components and APIs with Expo Router.
If file-based routing isn't right for your project, you can drop down to React Navigation and set up routes, types, and links manually.
---
Note: How do I server-render my Expo Router website?
---
Basic static rendering (SSG) is supported in Expo Router. Server-side rendering currently requires custom infrastructure to set up.
---
## Next steps


## Install Expo Router

Learn how to quickly get started by creating a new project with Expo Router or adding the library to an existing project.

Find the steps below to create a new project with Expo Router library or add it to your existing project.
## Quick start
Step 1: 
We recommend creating a new Expo app using `create-expo-app` to create a project with Expo Router library already installed and configured:
```sh
$ npx create-expo-app@latest
```
Step 2: 
Now, you can start your project by running:
```sh
$ npx expo start
```
- To view your app on a mobile device, we recommend starting with [Expo Go](/get-started/set-up-your-environment/#how-would-you-like-to-develop). As your application grows in complexity and you need more control, you can create a [development build](/develop/development-builds/introduction/).
- Open the project in a web browser by pressing <kbd>w</kbd> in the Terminal UI. Press <kbd>a</kbd> for Android (Android Studio is required), or <kbd>i</kbd> for iOS (macOS with Xcode is required).
## Manual installation
Follow the steps below if you have a project that was previously created with Expo but does not have Expo Router library installed.
### Prerequisites
Make sure your computer is [set up for running an Expo app](/get-started/create-a-project/).
Step 1: 
### Install dependencies
You'll need to install the following dependencies:
```sh
$ npx expo install expo-router react-native-safe-area-context react-native-screens expo-linking expo-constants expo-status-bar
```
The above command will install versions of these libraries that are compatible with the Expo SDK version your project is using.
Step 2: 
### Setup entry point
For the property `main`, use the `expo-router/entry` as its value in the **package.json**. The initial client file is [**app/\_layout.tsx**](/router/basics/layout/#root-layout).
```json package.json
{
  "main": "expo-router/entry"
}
```
Note: Custom entry point to initialize and load side-effects
---
You can create a custom entry point in your Expo Router project to initialize and load side-effects before your app loads the root layout (**app/\_layout.tsx**). Below are some of the common cases for a custom entry point:
- Initializing global services like analytics, error reporting, and so on.
- Setting up polyfills
- Ignoring specific logs using `LogBox` from `react-native`
1. Create a new file in the root of your project, such as **index.js**. After creating this file, the project structure should look like this:
   ```
├── app/
│   └── _layout.tsx
├── index.js
├── package.json
└── Other project files
```
2. Import or add your custom configuration to the file. Then, import `expo-router/entry` to register the app entry. Remember to always import it last to ensure all configurations are properly set up before the app renders.
   ```js index.js
   // Import side effects first and services
   // Initialize services
   // Register app entry through Expo Router
   import 'expo-router/entry';
   ```
3. Update the `main` property in **package.json** to point to the new entry file.
   ```json package.json
   {
     "main": "index.js"
   }
   ```
---
Step 3: 
### Modify project configuration
Add a deep linking `scheme` in your [app config](/workflow/configuration/):
```json app.json
{
  "scheme": "your-app-scheme"
}
```
If you are developing your app for web, install the following dependencies:
```sh
$ npx expo install react-native-web react-dom
```
Then, enable [Metro web](/guides/customizing-metro/#adding-web-support-to-metro) support by adding the following to your [app config](/workflow/configuration/):
```json app.json
{
  "web": {
    "bundler": "metro"
  }
}
```
Step 4: 
### Modify babel.config.js
Ensure you use `babel-preset-expo` as the `preset`, in the **babel.config.js** file or delete the file:
```js babel.config.js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};
```
Step 5: 
### Clear bundler cache
After updating the Babel config file, run the following command to clear the bundler cache:
```sh
$ npx expo start --clear
```
Step 6: 
### Update resolutions
If you're upgrading from an older version of Expo Router, ensure you remove all outdated Yarn resolutions or npm overrides in your **package.json**. Specifically, remove `metro`, `metro-resolver`, `react-refresh` resolutions from your **package.json**.


# Router 101

## Core concepts of file-based routing in Expo Router

Learn the ground rules of Expo Router and how it relates to the rest of your code.

Before diving into how to construct your app's navigation tree with Expo Router, let's first understand the core concepts that make up the foundation of file-based routing in Expo Router, and how an Expo Router project might differ in structure from other React Native projects.
## The rules of Expo Router
### 1. All screens/pages are files inside of app directory
All navigation routes in your app are defined by the files and sub-directories inside the **app** directory. Every file inside the **app** directory has a default export that defines a distinct page in your app (except for the special **\_layout** files).
Accordingly, directories inside **app** define groups of related screens together as stacks, tabs, or in other arrangements.
### 2. All pages have a URL
All pages have a URL path that matches the file's location in the **app** directory, which can be used to navigate to that page in the address bar on the web, or as an app-specific deep link in a native mobile app. This is what is meant by Expo Router supporting "universal deep-linking". All pages in your app can be navigated to with a URL, regardless of the platform.
### 3. First index.tsx is the initial route
With Expo Router, you do not define an initial route or first screen in code. Rather, when you open your app, Expo Router will look for the first **index.tsx** file matching the `/` URL. This could be an **app/index.tsx** file, but it doesn't have to be. If the user should start by default in a deeper part of your navigation tree, you can use a [route group](/router/basics/notation/#parentheses) (a directory where the name is surrounded in parenthesis), and that will not count as part of the URL. If you want your first screen to be a group of tabs, you might put all of the tab pages inside the **app/(tabs)** directory and define the default tab as **index.tsx**. With this arrangement, the `/` URL will take the user directly to **app/(tabs)/index.tsx** file.
### 4. Root \_layout.tsx replaces App.jsx/tsx
Every project should have a **\_layout.tsx** file directly inside the **app** directory. This file is rendered before any other route in your app and is where you would put the initialization code that may have previously gone inside an **App.jsx** file, such as loading fonts or interacting with the splash screen.
### 5. Non-navigation components live outside of app directory
In Expo Router, the **app** directory is exclusively for defining your app's routes. Other parts of your app, like components, hooks, utilities, and so on, should be placed in other top-level directories. If you put a non-route inside of the **app** directory, Expo Router will attempt to treat it like a route.
Alternatively, you can create a [top-level **src** directory](/router/reference/src-directory/) and put your routes inside the **src/app** directory, with non-route components going in folders like **src/components**, **src/utils**, and so on. This is the only other directory structure that Expo Router will recognize.
### 6. It's still React Navigation under the hood
While this may sound quite a bit different from React Navigation, Expo Router is actually built on top of React Navigation. You can think of Expo Router as an Expo CLI optimization that translates your file structure into React Navigation components that you previously defined in your own code.
This also means that you can often refer to React Navigation documentation for how to style or configure navigation, as the default stack and tab navigators use the exact same options.
## The rules of Expo Router applied
Let's apply these foundational rules of Expo Router to quickly identify key elements of the following project file structure:
```
├── app/
│   ├── index.tsx
│   ├── home.tsx
│   ├── _layout.tsx
│   └── profile/
│       └── friends.tsx
└── components/
    ├── TextField.tsx
    └── Toolbar.tsx
```
- **app/index.tsx** is the initial route, and will appear first when you open the app or navigate to your web app's root URL.
- **app/home.tsx** is a page with the route `/home`, so you can navigate to it with a URL like `yourapp.com/home` in the browser, or `myapp://home` in a native app.
- **app/\_layout.tsx** is the root layout. Any initialization code you may have previously put in **App.jsx** should go here.
- **app/profile/friends.tsx** is a page with the route `/profile/friends`.
- **TextField.tsx** and **Toolbar.tsx** are not in the **app** directory, so they will not be considered pages. They will not have a URL, and they cannot be the target of a navigation action. However, they can be used as components in the pages inside of the **app** directory.


## Expo Router notation

Learn how to use special filenames and notation to expressively define your app's navigation tree within your project's file structure.

When you look inside the **app** directory in a typical Expo Router project, you'll see a lot more than some simple file and directory names. What do the parentheses and brackets mean? Let's learn the significance of file-based routing notation and how it allows you to define complex navigation patterns.
## Types of route notation
### Simple names/no notation
```
└── app/
    ├── home.tsx
    └── feed/
        └── favorites.tsx
```
Regular file and directory names without any notation signify _static routes_. Their URL matches exactly as they appear in your file tree. So, a file named **favorites.tsx** inside the **feed** directory will have a URL of `/feed/favorites`.
### Square brackets
```
└── app/
    ├── [userName].tsx
    └── products/
        └── [productId]/
            └── index.tsx
```
If you see square brackets in a file or directory name, you are looking at a _dynamic route_. The name of the route includes a parameter that can be used when rendering the page. The parameter could be either in a directory name or a file name. For example, a file named **[userName].tsx** will match `/evanbacon`, `/expo`, or another username. Then, you can access that parameter with the `useLocalSearchParams` hook inside the page, using that to load the data for that specific user.
### Parentheses
```
└── app/
    └── (tabs)/
        ├── index.tsx
        └── settings.tsx
```
A directory with its name surrounded in parentheses indicates a _route group_. These directories are useful for grouping routes together without affecting the URL. For example, a file named **app/(tabs)/settings.tsx** will have `/settings` for its URL, even though it is not directly in the **app** directory.
Route groups can be useful for simple organization purposes, but often become more important for defining complex relationships between routes.
### index.tsx files
```
└── app/
    ├── (tabs)/
    │   └── index.tsx
    └── profile/
        └── index.tsx
```
Just like on the web, an **index.tsx** file indicates the default route for a directory. For example, a file named **profile/index.tsx** will match `/profile`. A file named **(tabs)/index.tsx** will match `/`, effectively becoming the default route for your entire app.
### \_layout.tsx files
```
└── app/
    ├── _layout.tsx
    ├── (tabs)/
    │   └── _layout.tsx
    └── feed/
        └── _layout.tsx
```
**\_layout.tsx** files are special files that are not pages themselves but define how groups of routes inside a directory relate to each other. If a directory of routes is arranged as a stack or tabs, the layout route is where you would define that relationship by using a stack navigator or tab navigator component.
Layout routes are rendered before the actual page routes inside their directory. This means that the **\_layout.tsx** directly inside the **app** directory is rendered before anything else in the app, and is where you would put the initialization code that may have previously gone inside an **App.jsx** file.
### Plus sign
```
└── app/
    ├── +not-found.tsx
    ├── +html.tsx
    ├── +native-intent.tsx
    └── +middleware.ts
```
Routes that include a `+` have special significance to Expo Router, and are used for specific purposes. A few examples:
- [`+not-found`](/router/error-handling/#unmatched-routes), which catches any requests that don't match a route in your app.
- [`+html`](/router/web/static-rendering/#root-html) is used to customize the HTML boilerplate used by your app on web.
- [`+native-intent`](/router/advanced/native-intent/) is used to handle deep links into your app that don't match a specific route, such as links generated by third-party services.
- [`+middleware`](/router/web/middleware/) is used to run code before a route is rendered, allowing you to perform tasks like authentication or redirection for every request.
## Route notation applied
Consider the following project file structure to identify the different types of routes represented:
```
└── app/
    ├── (tabs)/
    │   ├── _layout.tsx
    │   ├── index.tsx
    │   ├── feed.tsx
    │   └── profile.tsx
    ├── _layout.tsx
    ├── users/
    │   └── [userId].tsx
    ├── +not-found.tsx
    └── about.tsx
```
- **app/about.tsx** is a static route that matches `/about`.
- **app/users/[userId].tsx** is a dynamic route that matches `/users/123`, `/users/456`, and so on.
- **app/(tabs)** is a route group. It will not factor into the URL, so `/feed` will match **app/(tabs)/feed.tsx**.
- **app/(tabs)/index.tsx** is the default route for the **(tabs)** directory, so it will be the initially-focused tab, and will match the `/` URL.
- **app/(tabs)/\_layout.tsx** is a layout file defining how the three pages inside **app/(tabs)/** relate to each other. If you use a tab navigator component inside of this file, then those screens will be arranged as tabs.
- **app/\_layout.tsx** is the root layout file, and is rendered before any other route in the app.
- **+not-found.tsx** is a special route that will be displayed if the user navigates to a route that doesn't exist in your app.


## Navigation layouts in Expo Router

Learn how to construct different relationships between pages by using directories and layout files.

<VideoBoxLink
  videoId="Yh6Qlg2CYwQ"
  title="Introduction to Expo Router Layout Files"
  description="What are layout files, how to navigate between screens, and block access using redirects."
  className="mb-6"
/>
Each directory within the **app** directory (including **app** itself) can define a layout in the form of a **\_layout.tsx** file inside that directory. This file defines how all the pages within that directory are arranged. This is where you would define a stack navigator, tab navigator, drawer navigator, or any other layout that you want to use for the pages in that directory. The layout file exports a default component that is rendered before whatever page you are navigating to within that directory.
Let's look at a few common layout scenarios.
## Root layout
Virtually every app will have a **\_layout.tsx** file directly inside the **app** directory. This is the root layout and represents the entry point for your navigation. In addition to describing the top-level navigator for your app, this file is where you would put initialization code that may have previously gone inside an **App.jsx** file, such as loading fonts, interacting with the splash screen, or adding context providers.
Here's an example root layout:
```tsx app/_layout.tsx
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import * as SplashScreen from 'expo-splash-screen';
import { useEffect } from 'react';
SplashScreen.preventAutoHideAsync();
export default function RootLayout() {
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });
  useEffect(() => {
    if (loaded) {
      SplashScreen.hide();
    }
  }, [loaded]);
  if (!loaded) {
    return null;
  }
  return <Stack />;
}
```
The above example shows the splash screen initially and then renders a stack navigator once the fonts are loaded, which will cause your app to proceed to the initial route.
## Stacks
You can implement a stack navigator in your root layout, as shown above, or in any other layout file inside a directory. Let's suppose you have a file structure with a stack inside of a directory:
```
└── app/
    └── products/
        ├── _layout.tsx
        ├── index.tsx
        ├── [productId].tsx
        └── accessories/
            └── index.tsx
```
If you want everything inside of the **app/products** directory to be arranged in a stack relationship, inside the **\_layout.tsx** file, return a `Stack` component:
```tsx app/products/_layout.tsx
import { Stack } from 'expo-router';
export default function StackLayout() {
  return <Stack />;
}
```
When you navigate to `/products`, it will first go to the default route, which is **products/index.tsx**. If you navigate to `/products/123`, then that page will be pushed onto the stack. By default, the stack will render a back button in the header that will pop the current page off the stack, returning the user to the previous page. Even when a page isn't visible, if it is still pushed onto the stack, it is still being rendered.
The `Stack` component implements [React Navigation's native stack](https://reactnavigation.org/docs/native-stack-navigator/) and can use the same screen options. However, you do not have to define the pages specifically inside the navigator. The files inside the directory will be automatically treated as eligible routes in the stack. However, if you want to define screen options, you can add a `Stack.Screen` component inside the `Stack` component. The `name` prop should match the route name, but you do not need to supply a `component` prop; Expo Router will map this automatically:
```tsx app/products/_layout.tsx
import { Stack } from 'expo-router';
export default function StackLayout() {
  return (
    <Stack>
      <Stack.Screen name="[productId]" options={{ headerShown: false }} />
    </Stack>
  );
}
```
While it is possible to nest navigators, be sure to only do so when it is truly needed. In the above example, if you want to push **products/accessories/index.tsx** onto the stack, it's not necessary to have an additional **\_layout.tsx** in the **accessories** directory with a `Stack` navigator. That would define another stack inside the first one. It is fine to add directories that only affect the URL, otherwise, use the same navigator as the parent directory.
## Tabs
Much like a stack, you can implement a tab navigator in your layout file, and all the routes directly inside that directory will be treated as tabs. Consider the following file structure:
```
└── app/
    └── (tabs)/
        ├── _layout.tsx
        ├── index.tsx
        ├── feed.tsx
        └── profile.tsx
```
In the **\_layout.tsx** file, return a `Tabs` component:
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <MaterialIcons size={28} name="house.fill" color={color} />,
        }}
      />
      <!-- Add more tabs here -->
    </Tabs>
  );
}
```
This will cause the **index.tsx**, **feed.tsx**, and **profile.tsx** files to appear together in the same bottom tabs navigator. This `Tabs` component uses [React Navigation's native bottom tabs](https://reactnavigation.org/docs/bottom-tab-navigator/) and supports the same options.
In the case of `Tabs`, you will likely want to define the tabs in the navigator, as this influences the order in which tabs appear, the title, and the icon inside the tab. The index route will be the default selected tab.
## Slot
In some cases, you may want a layout without a navigator. This is helpful for adding a header or footer around the current route, or for displaying a modal over any route inside a directory. In this case, you can use the `Slot` component, which serves as a placeholder for the current child route.
Consider the following file structure:
```
└── app/
    └── social/
        ├── _layout.tsx
        ├── index.tsx
        ├── feed.tsx
        └── profile.tsx
```
For example, you may want to wrap any route inside the **social** directory with a header and footer, but you want navigating between the pages to simply replace the current page rather than pushing new pages onto a stack, which can then later be popped off with a "back" navigation action. In the **\_layout.tsx** file, return a `Slot` component surrounded by your header and footer:
```tsx app/social/_layout.tsx
import { Slot } from 'expo-router';
export default function Layout() {
  return (
    <>
      <Header />
      <Slot />
      <Footer />
    </>
  );
}
```
## Other layouts
These are just a few examples of common layouts to give you an idea of how it works. There's much more you can do with layout:
- Implement a [Drawer navigator](/router/advanced/drawer)
- Replace the default tabs with [fully customized tabs](/router/advanced/custom-tabs)
- Use a [modal](/router/advanced/modals) to display a page with transparency, such that the parent navigator is still visible underneath
- [Adapt any navigator that is compatible with React Navigation](/versions/latest/sdk/router/#withlayoutcontextnav-processor), including top tabs, bottom sheets, and more


## Navigating between pages in Expo Router

Learn the different ways to link to and navigate to pages in Expo Router.

Once you have a few pages in your app and their layouts setup, it's time to start navigating between them. Navigation in Expo Router works a lot like React Navigation, but with all pages having a URL by default, we can create links and use these URLs to move about our app using familiar web patterns.
## Native navigation basics with `useRouter`
Like in React Navigation, you can call a function from an `onPress` handler to navigate to another page. In Expo Router, you can use the `useRouter` hook to access navigation functions:
```tsx
import { useRouter } from 'expo-router';
import { Button } from 'react-native';
export default function Home() {
  const router = useRouter();
  return <Button title="Go to About" onPress={() => router.navigate('/about')} />;
}
```
Expo Router apps default to stack navigation, where navigating to a new route pushes a screen onto a stack, and backing out of that route pops it off the stack. Usually, you would want to use the `router.navigate` function. This will either push a new page onto the stack or unwind to an existing route on the stack. However, you can also call `router.push` to explicitly push a new page onto the stack, `router.back` to go back to the previous page, or `router.replace` to replace the current page on the stack.
With Expo Router, you refer to pages by their URL, or their position relative to the **app** directory. Check out the following file structure and how you would navigate to each page:
```
└── app/
    ├── index.tsx  # router.navigate("/")
    ├── about.tsx  # router.navigate("/about")
    └── profile/
        ├── index.tsx  # router.navigate("/profile")
        └── friends.tsx  # router.navigate("/profile/friends")
```
## Links and buttons
The typical way to link to a page in Expo Router is to use links like web apps. Expo Router has a `Link` component for navigating between pages, where the `href` is the same route you would use in `router.navigate`:
```tsx app/index.tsx
import { View } from 'react-native';
import { Link } from 'expo-router';
export default function Page() {
  return (
    <View>
      <Link href="/about">About</Link>
    </View>
  );
}
```
By default, Links can only wrap `Text` components. You can use `Pressable` or other components that support `onPress` and `onClick` props inside a link with the `asChild` prop:
```tsx
import { Pressable, Text } from 'react-native';
import { Link } from 'expo-router';
export default function Page() {
  return (
    <Link href="/other" asChild>
      <Pressable>
        <Text>Home</Text>
      </Pressable>
    </Link>
  );
}
```
## Relative routes
You don't always have to use the absolute path to a route. Using paths that start with `./` (for the current directory) or `../` (for the parent directory) will navigate relative to the current route.
A relative URL is a URL prefix with `./`, such as `./article`, or `./article/`. Relative URLs are resolved relative to the current rendered screen.
```tsx
<Link href="./article">Go to article</Link>
```
```ts
router.navigate('./article');
```
## Dynamic routes and URL parameters
<VideoBoxLink
  videoId="izZv6a99Roo"
  time={350}
  title="Using dynamic routes with Expo Router"
  description="Learn how to make a segment of a route dynamic."
  className="mb-6"
/>
Dynamic routes can be linked to with their full URL, or by passing a `params` object.
Consider the following file structure:
```
└── app/
    └── user/
        └── [id].tsx
```
Each of these links will navigate to the same page:
```tsx app/index.tsx
import { Link, router } from 'expo-router';
import { View, Pressable, Text } from 'react-native';
export default function Page() {
  return (
    <View>
      <Link
        href="/user/bacon">
        View user (id inline)
      </Link>
      <Link
        href={{
          pathname: '/user/[id]',
          params: { id: 'bacon' }
        }}
      >
        View user (id in params in href)
      </Link>
      <Pressable
        onPress={() =>
          router.navigate({
            pathname: '/user/[id]',
            params: { id: 'bacon' }
          })
        }
      >
        <Text>View user (imperative)</Text>
      </Pressable>
    </View>
  );
}
```
> **info** Some parameters are reserved for internal use by Expo Router and React Navigation. You can find them in the [Using URL parameters guide](/router/reference/url-parameters/#reserved-parameters).
### Passing query parameters
You can specify query parameters in the link URL itself, or as additional parameters in the `params` object. Any parameters that don't match the name of the dynamic route variable are equivalent to query parameters.
```tsx
<Link href="/users?limit=20">View users</Link>
<Link
  href={{
    pathname: '/users',
    params: { limit: 20 }
  }}>
  View users
</Link>
```
### Using dynamic route variables and query parameters in the destination page
All variables in the link URL are accessible to the receiving page via the `useLocalSearchParams` hook. This hook returns an object with all the URL parameters, including those passed as `params`.
For example, if you have a link like this:
```tsx
<Link href="/users?limit=20">View users</Link>
```
Then you can read the parameters on the other end like this:
```tsx
import { useLocalSearchParams } from 'expo-router';
import { View, Text } from 'react-native';
export default function Users() {
  const { id, limit } = useLocalSearchParams();
  return (
    <View>
      <Text>User ID: {id}</Text>
      <Text>Limit: {limit}</Text>
    </View>
  );
}
```
### Updating query parameters without navigating
Query parameters can be updated without navigating to a new page. This can be done with a `Link` that uses the same URL as the current page, but with updated query parameters, or imperatively.
```tsx
<Link href="/users?limit=50">View more users</Link>
<Pressable onPress={() => router.setParams({ limit: 50 })}>
  <Text>View more users</Text>
</Pressable>
```
## Redirects
You can immediately redirect to another route from a page or layout with the `Redirect` component. This functions like the `replace` imperative navigation function. A redirect will navigate to the new route without rendering the current page.
```tsx
import { Redirect } from 'expo-router';
export default function Page() {
  return <Redirect href="/about" />;
}
```
## Prefetching
The `prefetch` prop on a `<Link />` component enables prefetching of the target screen when the component is rendered. This allows for faster navigation by preparing the screen in advance.
```tsx
import { Link } from 'expo-router';
export default function Page() {
  return <Link href="/about" prefetch />;
}
```
When `prefetch` is set, Expo Router will attempt to render the target screen off-screen. The exact behavior depends on the type of navigator used:
- **Expo Router Navigators**: Render the target screen off-screen to enable preloading.
- **Custom Navigators**: May implement prefetching differently or not support it at all.
When a screen is preloaded in a stack navigator, it will have a few limitations:
- It cannot use the imperative `router` API.
- It cannot update options with `useNavigation().setOptions()`
- It cannot listen to events from the navigator (for example focus, tabPress, and so on).
The navigation object will be updated once you navigate to the screen. So if you have an event listener in a useEffect hook, and have a dependency on navigation, it will add any listeners when the screen is navigated to:
```tsx
const navigation = useNavigation();
useEffect(() => {
  const unsubscribe = navigation.addListener('tabPress', () => {
    // do something
  });
  return () => {
    unsubscribe();
  };
}, [navigation]);
```
Similarly, for dispatching actions or updating options, you can check if the screen is focused before doing so:
```tsx
const navigation = useNavigation();
if (navigation.isFocused()) {
  navigation.setOptions({ title: 'Updated title' });
}
```
For more information, refer to the [React Navigation preload docs](https://reactnavigation.org/docs/navigation-object/#preload)
## Deep links
Deep linking is when a URL opens a specific page in your app. Expo Router supports deep linking by default, so you can link to any page in your app with a URL from outside of your app, as you would inside your app with `Link`. This is especially useful for sharing links to specific pages in your app.
On web, deep linking is as simple as navigating to that specific URL in your web browser. On mobile, you define a `scheme` in your [app config](/workflow/configuration/) file, and this becomes the prefix for deep links into your app.
Assuming your `scheme` is `myapp`, here are some examples of how you would link to a page in your app from a web page or another app:
```
└── app/
    ├── about.tsx  # myapp://about
    ├── profile/
    │   └── index.tsx  # myapp://profile
    └── users/
        └── [username].tsx  # myapp://users/evanbacon
```
With app links and universal links, you can also link to your app with an `https` URL. For more information, see [Universal linking](/linking/overview/#universal-linking).
## Initial routes
When opening a deep link to a page in your app, you will likely want back navigation to work as if the user navigated to the page from your home page. To do this, you can specify an `initialRouteName` configuration, which defines the page in a layout that should be loaded before the deep linked page.
Consider the following file structure:
```
└── app/
    ├── index.tsx
    └── stack/
        ├── index.tsx
        ├── second.tsx
        └── _layout.tsx
```
`stack` is a stack navigator, and `/stack/index` is always the first route in the stack.
To ensure that `/stack/index` is always loaded first, even if the user deep links to `/stack/second`, you can set the `initialRouteName` in **app/stack/\_layout.tsx**:
```tsx
export const unstable_settings = {
  // Ensure any route can link back to `/`
  initialRouteName: 'index',
};
```
By default, the `initialRouteName` is only considered when deep linking and not during navigation within your app. However, you can use the `withAnchor` prop on `Link` to force the initial route to be loaded when navigating directly into another stack inside your app.
So, if **app/index.tsx** contained a link to `/stack/second`, add the `withAnchor` prop to ensure that `/stack/index` is loaded first, which will cause the user to go back to `/stack/index` when they press the back button from `/stack/second`:
```tsx
<Link href="/stack/second" withAnchor>
  Go to second
</Link>
```
> **info** If you are missing a back button when testing deep links, this can often be fixed by setting an `initialRouteName`.


## Common navigation patterns in Expo Router

Apply Expo Router basics to real-life navigation patterns you could use in your app.

Now that you know the basics of how files and directories are named and arranged in Expo Router, let's apply that knowledge, looking at some real-life navigation patterns you might use in your app.
## Stacks inside tabs: nested navigators
If the typical starting point for your app is a set of tabs, but one or more tabs may have more than one screen associated with it, nesting a stack navigator inside of a tab is often the way to go. This pattern often results in intuitive URLs and scales well to desktop web apps, where the primary tabs are often always visible.
Consider the following navigation tree:
```
└── app/
    └── (tabs)/
        ├── _layout.tsx
        ├── index.tsx  # single page tab
        ├── feed/
        │   ├── _layout.tsx  # tab with a stack inside
        │   ├── index.tsx
        │   └── [postId].tsx
        └── settings.tsx  # single page tab
```
In the **app/(tabs)/\_layout.tsx** file, return a `Tabs` component:
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs screenOptions={{ headerShown: false }}>
      <Tabs.Screen name="index" options={{ title: 'Home' }} />
      <Tabs.Screen name="feed" options={{ title: 'Feed' }} />
      <Tabs.Screen name="settings" options={{ title: 'Settings' }} />
    </Tabs>
  );
}
```
In the **app/(tabs)/feed/\_layout.tsx** file, return a `Stack` component:
```tsx app/(tabs)/feed/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  initialRouteName: 'index',
};
export default function FeedLayout() {
  return <Stack />;
}
```
Now, within the **app/(tabs)/feed** directory, you can have `Link` components that point to different posts (for example, `/feed/123`). Those links will push the `feed/[postId]` route onto the stack, leaving the tab navigator visible.
You can also navigate from any other tab to a post in the feed tab with the same URL. Use `withAnchor` in conjunction with `initialRouteName` to ensure that the `feed/index` route is always the first screen in the stack:
```tsx app/(tabs)/feed/index.tsx
<Link href="/feed/123" withAnchor>
  Go to post
</Link>
```
You can also nest tabs inside of an outer stack navigator. That is often more useful for displaying modals over the tabs.
## One screen, two tabs: sharing routes
Route groups can be used to share a single screen between two different tabs. Consider a navigation tree that has a Feed tab and a Search tab, and they both share pages for viewing a user profile:
```
└── app/
    └── (tabs)/
        ├── _layout.tsx
        ├── (feed)/
        │   └── index.tsx  # default route
        ├── (search)/
        │   └── search.tsx
        └── (feed,search)/
            ├── _layout.tsx  # layout shared between the two tabs
            └── users/
                └── [username].tsx  # shared user profile page
```
Each of the tabs is put in a group so you can define a third directory that shares routes between two groups (**app/(tabs)/(feed,search)/**). Even with the extra layer, **app/(tabs)/(feed)/index.tsx** is still the nearest index, so it will be the default route.
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen name="(feed)" options={{ title: 'Feed' }} />
      <Tabs.Screen name="(search)" options={{ title: 'Search' }} />
    </Tabs>
  );
}
```
Both the `(feed)` and `(search)` route groups contain stacks, so they can also share a single layout:
```tsx app/(tabs)/(feed,search)/_layout.tsx
import { Stack } from 'expo-router';
export default function SharedLayout() {
  return <Stack />;
}
```
It's also possible for shared groups to only contain the shared pages, with each distinct group having its own layout file.
Now, both tabs can navigate to `/users/evanbacon` and see the same user profile page.
When you're already focused on a tab and navigating to a user, you will stay in that current tab's group. But when deep-linking directly to a user profile page from outside the app, Expo Router has to pick one of the two groups, so it will pick the first group alphabetically. Therefore, deep-linking to `/users/evanbacon` will show the user profile in the Feed tab.
## Authenticated users only: protected routes
For mobile apps requiring authentication, you will likely have a set of routes that should only be accessible to authenticated users.
For example, consider the following navigation tree in which you have a bottom tabs layout, a sign-in page, a create account page, and a modal that should only be visible to authenticated users:
```
└── app/
    ├── _layout.tsx  # Root layout
    ├── (tabs)/
    │   ├── _layout.tsx
    │   ├── index.tsx  # Protected
    │   └── settings.tsx  # Protected
    ├── sign-in.tsx
    ├── create-account.tsx
    └── modal.tsx  # Protected
```
When your app is first launched, the router will try to open the root index, **app/(tabs)/index.tsx**. If you wrap this screen in a `Stack.Protected` with the `guard={false}`, the screen will become inaccessible and the next available screen will be opened instead. In this example, the `sign-in` screen will be opened, since it is the next available route.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
import { useAuthState } from '@/utils/authState';
export default function RootLayout() {
  const { isLoggedIn } = useAuthState();
  return (
    <Stack>
      <Stack.Protected guard={isLoggedIn}>
        <Stack.Screen name="(tabs)" />
        <Stack.Screen name="modal" />
      </Stack.Protected>
      <Stack.Protected guard={!isLoggedIn}>
        <Stack.Screen name="sign-in" />
        <Stack.Screen name="create-account" />
      </Stack.Protected>
    </Stack>
  );
}
```
This way, you can fetch your auth state from a store and show the appropriate screens. If the auth state changes, the layout will re-render, so if `isLoggedIn` changes from `false` to `true`, the app will automatically navigate to the root of the `(tabs)` group.
Another benefit of protected routes is that they are checked even if you deep link into a page directly. For example, if an unauthenticated user deep links into the modal screen above, they will be redirected to the sign-in page.
Protected routes can also be used to conditionally show bottom tabs. In this example, the `vip` tab will only be shown to authenticated users who are VIP members:
```tsx app/(tabs)/_layout.tsx
import { Stack } from 'expo-router';
import { useAuthState } from '@/utils/authState';
export default function TabsLayout() {
  const { isVip } = useAuthState();
  return (
    <Tabs>
      <Tabs.Screen name="index" />
      <Tabs.Protected guard={isVip}>
        <Tabs.Screen name="vip" />
      </Tabs.Protected>
      <Tabs.Screen name="settings" />
    </Tabs>
  );
}
```
## Sometimes the best route isn't a route at all
Separating your navigation states into distinct routes is meant to serve you and your app. Sometimes the best pattern for the job will not involve navigating to another route at all. Since layout files are just React components, you can use them to display all sorts of UI around, besides, or instead of a navigator.
Thinking back to authentication, the protected route setup works great if the user should simply not be able to visit certain pages without logging in. But what about when unauthenticated users can browse an app in read-only mode? In that case, you might want to show a login modal over the app, rather than redirecting the user to a login page:
```tsx app/(logged-in)/_layout.tsx
import { Modal } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Stack } from 'expo-router';
export default function Layout() {
  const isAuthenticated = /* check for valid auth token / session */
  return (
    <SafeAreaView>
      <Stack />
      <Modal visible={!isAuthenticated}>{/* login UX */}</Modal>
    </SafeAreaView>
  );
}
```


# Navigation patterns

## Stack

Learn how to use the Stack navigator in Expo Router.

<VideoBoxLink
  videoId="izZv6a99Roo"
  title="Using a Stack Navigator with Expo Router"
  description="Navigate between screens, pass params between screens, create dynamic routes, and configure the screen titles and animations."
  className="mb-6"
/>
A stack navigator is the foundational way of navigating between routes in an app. On Android, a stacked route animates on top of the current screen. On iOS, a stacked route animates from the right. Expo Router provides a `Stack` navigation component that creates a navigation stack and allows you to add new routes in your app.
This guide provides information on how you can create a `Stack` navigator in your project and customize an individual route's options and header.
## Get started
You can use file-based routing to create a stack navigator. Here's an example file structure:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── details.tsx
```
This file structure produces a layout where the `index` route is the first route in the stack, and the `details` route is pushed on top of the `index` route when navigated.
You can use the **app/\_layout.tsx** file to define your app's `Stack` navigator with these two routes:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function Layout() {
  return <Stack />;
}
```
## Screen options and header configuration
### Statically configure route options
You can use the `<Stack.Screen name={routeName} />` component in the layout component route to statically configure a route's options. This is also useful for [tabs](/router/advanced/tabs/) or [drawers](/router/advanced/drawer/) as they need an icon defined ahead of time.
```tsx app/_layout.tsx|collapseHeight=440
import { Stack } from 'expo-router';
export default function Layout() {
  return (
    <Stack
      screenOptions={{
        headerStyle: {
          backgroundColor: '#f4511e',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}>
      {/* Optionally configure static options outside the route.*/}
      <Stack.Screen name="home" options={{}} />
    </Stack>
  );
}
```
As an alternative to the `<Stack.Screen>` component, you can use [`navigation.setOptions()`](https://reactnavigation.org/docs/navigation-object/#setoptions) to configure a route's options from within the route's component file.
```tsx app/index.tsx
import { Stack, useNavigation } from 'expo-router';
import { Text, View } from 'react-native';
import { useEffect } from 'react';
export default function Home() {
  const navigation = useNavigation();
  useEffect(() => {
    navigation.setOptions({ headerShown: false });
  }, [navigation]);
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Home Screen</Text>
    </View>
  );
}
```
### Configure header bar
You can configure the header bar for all routes in a `Stack` navigator by using the `screenOptions` prop. This is useful for setting a common header style across all routes.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function Layout() {
  return (
    <Stack
      screenOptions={{
        headerStyle: {
          backgroundColor: '#f4511e',
        },
        headerTintColor: '#fff',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
      }}
    />
  );
}
```
To configure the header bar dynamically for an individual route, use that navigator's `<Stack.Screen>` component in the routes's file. This is useful for interactions that change the UI.
```tsx app/index.tsx
import { Link, Stack } from 'expo-router';
import { Image, Text, View, StyleSheet } from 'react-native';
function LogoTitle() {
  return (
    <Image style={styles.image} source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }} />
  );
}
export default function Home() {
  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: 'My home',
          headerStyle: { backgroundColor: '#f4511e' },
          headerTintColor: '#fff',
          headerTitleStyle: {
            fontWeight: 'bold',
          },
          headerTitle: props => <LogoTitle {...props} />,
        }}
      />
      <Text>Home Screen</Text>
      <Link href={{ pathname: 'details', params: { name: 'Bacon' } }}>Go to Details</Link>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  image: {
    width: 50,
    height: 50,
  },
});
```
### Available header options
The `Stack` navigator supports comprehensive header configuration options. Below are all the header-related options available:
<ReactNavigationOptions category="header" />
For additional details and navigator-specific examples, see [React Navigation's Native Stack Navigator documentation](https://reactnavigation.org/docs/native-stack-navigator).
### Set screen options dynamically
To configure a route's option dynamically, you can always use the `<Stack.Screen>` component in that route's file.
As an alternative, you can also use the [imperative API's `router.setParams()`](/versions/latest/sdk/router/#router) function to configure the route dynamically.
```tsx app/details.tsx
import { Stack, useLocalSearchParams, useRouter } from 'expo-router';
import { View, Text, StyleSheet } from 'react-native';
export default function Details() {
  const router = useRouter();
  const params = useLocalSearchParams();
  return (
    <View style={styles.container}>
      <Stack.Screen
        options={{
          title: params.name,
        }}
      />
      <Text
        onPress={() => {
          router.setParams({ name: 'Updated' });
        }}>
        Update the title
      </Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
### Header buttons
You can add buttons to the header by using the `headerLeft` and `headerRight` options. These options accept a React component that renders in the header.
```tsx app/index.tsx
import { Stack } from 'expo-router';
import { Button, Text, Image, StyleSheet } from 'react-native';
import { useState } from 'react';
function LogoTitle() {
  return (
    <Image style={styles.image} source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }} />
  );
}
export default function Home() {
  const [count, setCount] = useState(0);
  return (
    <>
      <Stack.Screen
        options={{
          headerTitle: props => <LogoTitle {...props} />,
          headerRight: () => <Button onPress={() => setCount(c => c + 1)} title="Update count" />,
        }}
      />
      <Text>Count: {count}</Text>
    </>
  );
}
const styles = StyleSheet.create({
  image: {
    width: 50,
    height: 50,
  },
});
```
### Other screen options
For a complete list of all available other screen options including animations, gestures, and other configurations:
<ReactNavigationOptions excludeCategories={['header']} />
For additional details and navigator-specific examples, see [React Navigation's Native Stack Navigator documentation](https://reactnavigation.org/docs/native-stack-navigator).
## Custom push behavior
By default, the `Stack` navigator removes duplicate screens when pushing a route that is already in the stack. For example, if you push the same screen twice, the second push will be ignored. You can change this push behavior by providing a custom `getId()` function to the `<Stack.Screen>`.
For example, the `index` route in the following layout structure shows a list of different user profiles in the app. Let's make the `[details]` route a [dynamic route](/router/basics/notation/#square-brackets) so that the app user can navigate to see a profile's details.
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── [details].tsx  # matches dynamic paths like '/details1'
```
The `Stack` navigator will push a new screen every time the app user navigates to a different profile but will fail. If you provide a `getId()` function that returns a new ID every time, the `Stack` will push a new screen every time the app user navigates to a profile.
You can use the `<Stack.Screen name="[profile]" getId={}>` component in the layout component route to modify the push behavior:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen
        name="[profile]"
        getId={
          ({ params }) => String(Date.now())
        }
      />
    </Stack>
  );
}
```
## Removing stack screens
There are different actions you can use to dismiss and remove one or many routes from a stack.
### `dismiss` action
Dismisses the last screen in the closest stack. If the current screen is the only route in the stack, it will dismiss the entire stack.
You can optionally pass a positive number to dismiss up to that specified number of screens.
Dismiss is different from `back` as it targets the closest stack and not the current navigator. If you have nested navigators, calling `dismiss` will take you back multiple screens.
```tsx app/settings.tsx
import { Button, View } from 'react-native';
import { useRouter } from 'expo-router';
export default function Settings() {
  const router = useRouter();
  const handleDismiss = (count: number) => {
    router.dismiss(count)
  };
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button title="Go to first screen" onPress={() => handleDismiss(3)} />
    </View>
  );
}
```
### `dismissTo` action
> `dismissTo` was added in Expo Router `4.0.8`. It operates similarly to the `navigation` function in Expo Router v3.
Dismisses screens in the current `<Stack />` until the specified `Href` is reached. If the `Href` is absent in the history, a `push` action will be performed instead.
For example, consider the history of `/one`, `/two`, `/three` routes, where `/three` is the current route. The action `router.dismissTo('/one')` will cause the history to go back twice, while `router.dismissTo('/four')` will `push` the history forward to the `/four` route.
```tsx app/settings.tsx
import { Button, View, Text } from 'react-native';
import { useRouter } from 'expo-router';
export default function Settings() {
  const router = useRouter();
  const handleDismissAll = () => {
    router.dismissTo('/')
  };
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button title="Go to first screen" onPress={handleDismissAll} />
    </View>
  );
}
```
### `dismissAll` action
To return to the first screen in the closest stack. This is similar to [`popToTop`](https://reactnavigation.org/docs/stack-actions/#poptotop) stack action.
For example, the `home` route is the first screen, and the `settings` is the last. To go from `settings` to `home` route you'll have to go back to `details`. However, using the `dismissAll` action, you can go from `settings` to `home` and dismiss any screen in between.
```tsx app/settings.tsx
import { Button, View, Text } from 'react-native';
import { useRouter } from 'expo-router';
export default function Settings() {
  const router = useRouter();
  const handleDismissAll = () => {
    router.dismissAll()
  };
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button title="Go to first screen" onPress={handleDismissAll} />
    </View>
  );
}
```
### `canDismiss` action
To check if it is possible to dismiss the current screen. Returns `true` if the router is within a stack with more than one screen in the stack's history.
```tsx app/settings.tsx|collapseHeight=410
import { Button, View } from 'react-native';
import { useRouter } from 'expo-router';
export default function Settings() {
  const router = useRouter();
  const handleDismiss = (count: number) => {
    if (router.canDismiss()) {
      router.dismiss(count)
    }
  };
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Button title="Maybe dismiss" onPress={() => handleDismiss()} />
    </View>
  );
}
```
## Relation with Native Stack Navigator
The `Stack` navigator in Expo Router wraps the [Native Stack Navigator](https://reactnavigation.org/docs/native-stack-navigator) from React Navigation. Options available in the Native Stack Navigator are all available in the `Stack` navigator in Expo Router.
### JavaScript stack with @react-navigation/stack
You can also use the JavaScript-powered `@react-navigation/stack` library to create a custom layout component by wrapping this library with the `withLayoutContext`.
In the following example, `JsStack` component is defined using `@react-navigation/stack` library:
```tsx layouts/js-stack.tsx
import { ParamListBase, StackNavigationState } from '@react-navigation/native';
import {
  createStackNavigator,
  StackNavigationEventMap,
  StackNavigationOptions,
} from '@react-navigation/stack';
import { withLayoutContext } from 'expo-router';
const { Navigator } = createStackNavigator();
export const JsStack = withLayoutContext<
  StackNavigationOptions,
  typeof Navigator,
  StackNavigationState<ParamListBase>,
  StackNavigationEventMap
>(Navigator);
```
After defining the `JsStack` component, you can use it in your app:
```tsx app/_layout.tsx
import { JsStack } from '../layouts/js-stack';
export default function Layout() {
  return (
    <JsStack
      screenOptions={
        {
        }
      }
    />
  );
}
```
For more information on available options, see [`@react-navigation/stack` documentation](https://reactnavigation.org/docs/stack-navigator).
## iOS 26 Liquid Glass headers
Starting from iOS 26, navigation headers adopt the system's "Liquid Glass" effect by default. It cannot be disabled per screen, so you need to opt out using a global configuration.
### Method 1: Use `UIDesignRequiresCompatibility`
> **Note**: Not supported in Expo Go.This method is a temporary workaround. From iOS 27, this option will be removed by Apple and you cannot opt out of the Liquid Glass effect.
Create a [development build](/develop/development-builds/create-a-build/#prerequisites) and set the [`UIDesignRequiresCompatibility`](https://developer.apple.com/documentation/BundleResources/Information-Property-List/UIDesignRequiresCompatibility) property to `true` in [app config](/workflow/configuration/):
```json app.json
{
  "ios": {
    "infoPlist": {
      "UIDesignRequiresCompatibility": true
    }
  }
}
```
### Method 2: Use JavaScript-based navigation stack
Switch from native navigation library ([`@react-navigation/native`](https://reactnavigation.org/docs/native-stack-navigator/)) to a JavaScript-based stack navigator library such as [`@react-navigation/stack`](https://reactnavigation.org/docs/stack-navigator/), which gives you full control over the header UI but at the cost of performance benefits of using the highly optimized iOS navigation views/controllers.
For more information, see [JavaScript stack with `@react-navigation/stack`](#javascript-stack-with-react-navigationstack).


## JavaScript tabs

Learn how to use the JavaScript tabs layout (React Navigation bottom tabs) in Expo Router.

<VideoBoxLink
  videoId="BElPB4Ai3j0"
  title="Using a JavaScript Tab Navigator with Expo Router"
  description="Configure the tab icons, nest navigators, and manage navigation history."
  className="mb-6"
/>
Tabs are a common way to navigate between different sections of an app. Expo Router provides a tabs layout to help you create a tab bar at the bottom of your app. The fastest way to get started is to use a template. See the [quick start installation](/router/installation/#quick-start) to get started.
## Multiple tab layouts
Expo Router offers three types of tab navigators:
- **JavaScript tabs**: It is implemented with React Navigation's bottom tabs and offers familiar API if you have already used React Navigation.
- **Native tabs**: It uses a platform's native tab bar and offers native look and feel.
- **Custom tabs**: It provides headless tab components from `expo-router/ui` to build a fully custom tab layout to achieve complex UI patterns.
This guide covers the **JavaScript tabs** layout. For other tab layouts see:
## Get started with JavaScript tabs
You can use file-based routing to create a tabs layout. Here's an example file structure:
```
└── app/
    ├── _layout.tsx
    └── (tabs)/
        ├── _layout.tsx
        ├── index.tsx
        └── settings.tsx
```
This file structure produces a layout with a tab bar at the bottom of the screen. The tab bar will have two tabs: **Home** and **Settings**:
You can use the **app/\_layout.tsx** file to define your app's root layout:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
    </Stack>
  );
}
```
The **(tabs)** directory is a special directory name that tells Expo Router to use the `Tabs` layout.
From the file structure, the **(tabs)** directory has three files. The first is **(tabs)/\_layout.tsx**. This file is the main layout file for the tab bar and each tab. Inside it, you can control how the tab bar and each tab button look and behave.
```tsx app/(tabs)/_layout.tsx
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs screenOptions={{ tabBarActiveTintColor: 'blue' }}>
      <Tabs.Screen
        name="index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <FontAwesome size={28} name="home" color={color} />,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color }) => <FontAwesome size={28} name="cog" color={color} />,
        }}
      />
    </Tabs>
  );
}
```
Finally, you have the two tab files that make up the content of the tabs: **app/(tabs)/index.tsx** and **app/(tabs)/settings.tsx**.
```tsx app/(tabs)/index.tsx & app/(tabs)/settings.tsx
import { View, Text, StyleSheet } from 'react-native';
export default function Tab() {
  return (
    <View style={styles.container}>
      <Text>Tab [Home|Settings]</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```
The tab file named **index.tsx** is the default tab when the app loads. The second tab file **settings.tsx** shows how you can add more tabs to the tab bar.
## Tab bar options
The JavaScript tabs in Expo Router extend the [Bottom Tabs Navigator](https://reactnavigation.org/docs/bottom-tab-navigator) from React Navigation. The specific APIs available depend on your versions. For example, Expo Router v6 extends Bottom Tabs Navigator v7. Check your versions to ensure compatibility, then you can use the same configuration props to customize the bottom tab bar and individual tabs. For example:
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs
      screenOptions={
        {
          // Here to apply for all tabs
        }
      }>
      <Tabs.Screen
        name="index"
        options={
          {
            // Or here to apply for one tab
          }
        }
      />
    </Tabs>
  );
}
```
The supported tab bar options are listed below:
<ReactNavigationOptions category="tabBar" />
For additional details and navigator-specific examples, see [React Navigation's Bottom Tabs Navigator documentation](https://reactnavigation.org/docs/bottom-tab-navigator/#options).
## Advanced
### Hiding a tab
Sometimes you want a route to exist but not show up in the tab bar. You can pass `href: null` to disable the button:
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen
        name="index"
        options={{
          href: null,
        }}
      />
    </Tabs>
  );
}
```
### Dynamic routes
You can use a dynamic route in a tab bar. For example, you have a `[user]` tab that shows a user's profile. You can use the `href` option to link to a specific user's profile.
```tsx app/(tabs)/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen
        // Name of the dynamic route.
        name="[user]"
        options={{
          // Ensure the tab always links to the same href.
          href: '/evanbacon',
          // OR you can use the href object.
          href: {
            pathname: '/[user]',
            params: {
              user: 'evanbacon',
            },
          },
        }}
      />
    </Tabs>
  );
}
```
> **Note**: When adding a dynamic route in your tab layout, ensure that the dynamic route defined is unique. You cannot have two screens for the same dynamic route. For example, you cannot have two `[user]` tabs. If you need to have multiple dynamic routes, create a custom navigator.


## Native tabs

Learn how to use the native tabs layout in Expo Router.

<VideoBoxLink
  videoId="QqNZXdGFl44"
  title="Liquid Glass Tabs with Expo Router"
  description="Learn how to use native tabs to create liquid glass tabs on iOS with Expo Router."
  className="mb-6"
/>
> **important** Native tabs is in alpha and is available in SDK 54 and later. Its API is subject to change.
Tabs are a common way to navigate between different sections of an app. In Expo Router, you can use different tab layouts, depending on your needs. This guide covers the native tabs. Unlike the [other tabs layout](/router/advanced/tabs/#multiple-tab-layouts), native tabs use the native system tab bar.
For other tab layouts see:
## Get started
You can use file-based routing to create a tabs layout. Here's an example file structure:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── settings.tsx
```
The above file structure produces a layout with a tab bar at the bottom of the screen. The tab bar will have two tabs: **Home** and **Settings**.
You can use the **app/\_layout.tsx** file to define your app's root layout using tabs. This file is the main layout file for the tab bar and each tab. Inside it, you can control how the tab bar and each tab item look and behave.
```tsx app/_layout.tsx
import { NativeTabs, Icon, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
        <Icon sf="house.fill" drawable="custom_android_drawable" />
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Icon sf="gear" drawable="custom_settings_drawable" />
        <Label>Settings</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
Finally, you have the two tab files that make up the content of the tabs: **app/index.tsx** and **app/settings.tsx**.
```tsx app/index.tsx and app/settings.tsx
import { View, Text, StyleSheet } from 'react-native';
export default function Tab() {
  return (
    <View style={styles.container}>
      <Text>Tab [Home|Settings]</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```
The tab file named **index.tsx** is the default tab when the app loads. The second tab file **settings.tsx** shows how you can add more tabs to the tab bar.
> **info** In contrast to the Stack navigator, tabs are not automatically added to the tab bar. You need to explicitly add them in your layout file using the `NativeTabs.Trigger`.
## Customizing tab bar items
When you want to customize the tab bar item, we recommend using the components API designed for this purpose. Currently, you can customize:
- **Icon**: The icon displayed in the tab bar item.
- **Label**: The label displayed in the tab bar item.
- **Badge**: The badge displayed in the tab bar item.
### Icon
You can use the `Icon` component to customize the icon displayed in the tab bar item. The `Icon` component accepts a `drawable` prop for Android drawables, a `sf` prop for Apple's SF Symbols icons, or a `src` prop for custom images.
Alternatively, you can pass `{default: ..., selected: ...}` to either the `sf` or `src` prop to specify different icons for the default and selected states.
> To use `drawable` props on Android, you can use [built-in drawables](https://developer.android.com/reference/android/R.drawable) or add [custom drawables](https://developer.android.com/studio/write/resource-manager).
```tsx app/_layout.tsx
import { NativeTabs, Icon } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Icon sf={{ default: 'house', selected: 'house.fill' }} drawable="custom_home_drawable" />
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Icon src={require('../../../assets/setting_icon.png')} />
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
Liquid glass on iOS automatically changes colors based on if the background color is light or dark. There is no callback for this, so you need to use a `PlatformColor` to set the color of the icon.
```tsx app/_layout.tsx
import { DynamicColorIOS } from 'react-native';
import { NativeTabs, Icon } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs
      labelStyle={{
        // For the text color
        color: DynamicColorIOS({
          dark: 'white',
          light: 'black',
        }),
      }}
      // For the selected icon color
      tintColor={DynamicColorIOS({
        dark: 'white',
        light: 'black',
      })}>
      <NativeTabs.Trigger name="index">
        <Icon sf={{ default: 'house', selected: 'house.fill' }} drawable="custom_home_drawable" />
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Icon
          src={{
            default: require('../../../assets/setting_icon.png'),
            selected: require('../../../assets/selected_setting_icon.png'),
          }}
        />
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### Label
You can use the `Label` component to customize the label displayed in the tab bar item. The `Label` component accepts a string label passed as a child. If no label is provided, the tab bar item will use the route name as the label.
If you don't want to display a label, you can use the `hidden` prop to hide the label.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Label hidden />
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### Badge
You can use the `Badge` component to customize the badge displayed for the tab bar item. The badge is an additional mark on top of the tab and useful for showing notification or unread message counts.
```tsx app/_layout.tsx
import { NativeTabs, Badge } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="messages">
        <Badge>9+</Badge>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Badge />
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
## Customizing the tab bar
Since the native tab layout's appearance varies by platform, the customization options are also different. For all customization options, see the [API reference for `NativeTabs`](/versions/latest/sdk/router-native-tabs/).
## Advanced
### Hide a tab conditionally
If you want to hide a tab based on a condition, you can either remove the trigger or pass the `hidden` prop to the `NativeTabs.Trigger` component.
```tsx app/_layout.tsx
import { NativeTabs } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  const shouldHideMessagesTab = true; // Replace with your condition
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="messages" hidden={shouldHideMessagesTab} />
    </NativeTabs>
  );
}
```
> **info** **Note**: Marking a tab as `hidden` means it cannot be navigated to in any way.
### Dismiss behavior
> **info** Currently this is an iOS-only feature, but we plan to add it to Android in the future.
By default, tapping a tab that is already active closes all screens in that tab's stack and returns to the root screen. You can disable this by setting the `disablePopToTop` prop on the `NativeTabs.Trigger` component.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index" disablePopToTop>
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Label>Settings</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### Scroll to top
> **info** Currently this is an iOS-only feature, but we plan to add it to Android in the future.
By default, tapping a tab that is already active and showing its root screen scrolls the content back to the top. You can disable this by setting the `disableScrollToTop` prop on the `NativeTabs.Trigger` component.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index" disableScrollToTop>
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="settings">
        <Label>Settings</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### iOS 26 features
> **info** To use features described in this section, compile your app with Xcode 26 or higher.
#### Separate search tab
To add a separate search tab, assign the `role` with its value set to `search` to the native tab you want to display separately.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="search" role="search">
        <Label>Search</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
#### Tabbar search input
To add a search field to the tab bar, wrap the screen in a Stack navigator and configure `headerSearchBarOptions`.
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── search/
        ├── _layout.tsx
        └── index.tsx
```
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs>
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="search" role="search">
        <Label>Search</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
```tsx app/search/_layout.tsx
import { Stack } from 'expo-router';
export default function SearchLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="index"
        options={{
          title: 'Search',
          headerSearchBarOptions: {
            placement: 'automatic',
            placeholder: 'Search',
            onChangeText: () => {},
          },
        }}
      />
    </Stack>
  );
}
```
```tsx app/search/index.tsx
import { ScrollView } from 'react-native';
export default function SearchIndex() {
  return <ScrollView>{/* Screen content */}</ScrollView>;
}
```
#### Tab bar minimize behavior
To implement the minimized behavior on the tab bar, you can use
[`minimizeBehavior`](/versions/latest/sdk/router-native-tabs/#minimizebehavior) prop on
`NativeTabs`. In the example below, the tab bar is minimized when scrolling down.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs minimizeBehavior="onScrollDown">
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
      </NativeTabs.Trigger>
      <NativeTabs.Trigger name="tab-1">
        <Label>Tab 1</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### Integration with `@expo/vector-icons`
> **info** **Recommended**: Use [SF Symbols on iOS](#icon). They offer a more native platform feeling compared to vector icons.
To use icons from `@expo/vector-icons`, you can use `VectorIcon` component.
```tsx app/_layout.tsx|collapseHeight=480
import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { NativeTabs, Icon, VectorIcon } from 'expo-router/unstable-native-tabs';
import { Platform } from 'react-native';
export default function TabLayout() {
  return (
    <NativeTabs minimizeBehavior="onScrollDown">
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
        {Platform.select({
          ios: <Icon sf="house.fill" />,
          android: <Icon src={<VectorIcon family={MaterialIcons} name="home" />} />,
        })}
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```
### Disabling keyboard avoidance on Android
By default, when the keyboard is displayed on Android, the native tabs automatically adjust to avoid being obscured. You can disable this behavior by changing the [`android.softwareKeyboardLayoutMode`](/versions/latest/config/app/#softwarekeyboardlayoutmode) property to `pan` in your app config file:
```json app.json
{
  "expo": {
    "android": {
      "softwareKeyboardLayoutMode": "pan"
    }
  }
}
```
## Migrating from JavaScript tabs
Native tabs are not designed to be a drop-in replacement for [JavaScript tabs](/router/advanced/tabs/). The native tabs are constrained to the native platform behavior, whereas the JavaScript tabs can be customized more freely. If you aren't interested in the native platform behavior, you can continue using the JavaScript tabs.
### Use `Trigger` instead of `Screen`
`NativeTabs` introduces the concept of a `Trigger` for adding routes to a layout. Unlike a `Screen`, which styles routes that are added automatically, the `Trigger` system gives you better control for hiding and removing tabs from the tab bar.
### Use React components instead of props
`NativeTabs` has a React-first API that opts to use components for defining UI in favor of props objects.
<DiffBlock source="/static/diffs/router/native-tabs/trigger-icon-component.diff" />
### Use Stacks inside tabs
The JavaScript `` have a mock stack header which is not present in the native tabs. Instead, you should nest a native `<Stack />` layout inside the native tabs to support both headers and pushing screens.
## Known limitations
### A limit of 5 tabs on Android
On Android, there is a limitation of having a maximum of 5 tabs in the tab bar. This restriction comes from the platform's Material Tabs component.
### Cannot measure the tab bar height
The tabs move around, sometimes being on top of the screen when rendering on iPad, sometimes on the side of the screen when running on Apple Vision Pro, and so on. We're working on a layout function to provide more detailed layout info in the future.
### No support for nested native tabs
Native tabs cannot be nested inside other native tabs. You can still nest [JavaScript tabs](/router/advanced/tabs/) inside native tabs.
### Limited support for FlatList
[FlatList](https://reactnative.dev/docs/flatlist) integration with native tabs has limitations. Features like scroll-to-top and minimize-on-scroll aren't supported. Additionally, detecting scroll edges may fail, causing the tab bar to appear transparent. To fix this, use the [`disableTransparentOnScrollEdge`](/versions/latest/sdk/router-native-tabs/#disabletransparentonscrolledge) prop.
```tsx app/_layout.tsx
import { NativeTabs, Label } from 'expo-router/unstable-native-tabs';
export default function TabLayout() {
  return (
    <NativeTabs disableTransparentOnScrollEdge>
      <NativeTabs.Trigger name="index">
        <Label>Home</Label>
      </NativeTabs.Trigger>
    </NativeTabs>
  );
}
```


## Drawer

Learn how to use the Drawer layout in Expo Router.

A navigation drawer is a common pattern in mobile apps, it allows users to swipe open a menu from a side of their screen to expose navigation options. This menu is also typically toggleable through a button in the app's header.
## Installation
For SDK 54 and later: 
To use [drawer navigator](https://reactnavigation.org/docs/drawer-based-navigation) you'll need to install some additional dependencies if you do not have them already. On Android and iOS, the drawer navigator requires `react-native-reanimated` and `react-native-worklets` to drive its animations. On web, this is handled by CSS animations.
```sh
$ npx expo install @react-navigation/drawer react-native-reanimated react-native-worklets
```
For SDK 53 and earlier: 
To use [drawer navigator](https://reactnavigation.org/docs/drawer-based-navigation) you'll need to install some additional dependencies if you do not have them already. On Android and iOS, the drawer navigator requires `react-native-reanimated` and `react-native-gesture-handler` to drive its animations. On web, this is handled by CSS animations.
```sh
$ npx expo install @react-navigation/drawer react-native-reanimated react-native-gesture-handler
```
## Usage
Now you can use the `Drawer` layout to create a drawer navigator.
```tsx app/_layout.tsx
import { Drawer } from 'expo-router/drawer';
export default function Layout() {
  return <Drawer />;
}
```
To edit the drawer navigation menu labels, titles and screen options specific screens are required as follows:
```tsx app/_layout.tsx
import { Drawer } from 'expo-router/drawer';
export default function Layout() {
  return (
    <Drawer>
      <Drawer.Screen
        name="index" // This is the name of the page and must match the url from root
        options={{
          drawerLabel: 'Home',
          title: 'overview',
        }}
      />
      <Drawer.Screen
        name="user/[id]" // This is the name of the page and must match the url from root
        options={{
          drawerLabel: 'User',
          title: 'overview',
        }}
      />
    </Drawer>
  );
}
```


## Authentication in Expo Router

How to implement authentication and protect routes with Expo Router.

> **info** **Note:** This guide requires SDK 53 and later. For the previous version of this guide see [Authentication (redirects)](/router/advanced/authentication-rewrites/).
With Expo Router, all routes are always defined and accessible. You can use runtime logic to redirect users away from specific screens depending on whether they are authenticated. There are two different techniques for authenticating users within routes. This guide provides an example that demonstrates the functionality of standard native apps.
## Using Protected Routes
[Protected routes](/router/advanced/protected/) allow you to prevent users from accessing certain routes using client-side navigation. If a user tries to navigate to a protected screen, or if a screen becomes protected while it is active, they will be redirected to the anchor route (usually the index screen) or the first available screen in the stack. Consider the following project structure that has a `/sign-in` route that is always accessible and a `(app)` group that requires authentication:
```
└── app/
    ├── _layout.tsx  # Controls what is protected
    ├── sign-in.tsx  # Always accessible
    └── (app)/
        ├── _layout.tsx  # Requires authorization
        └── index.tsx  # Should be protected by the (app)/_layout
```
Step 1: 
To follow the above example, set up a [React Context provider](https://react.dev/reference/react/createContext) that can expose an authentication session to the entire app. You can implement your custom authentication session provider or use the one from the **Example authentication context** below.
Note: Example authentication context
---
This provider uses a mock implementation. You can replace it with your own [authentication provider](/guides/authentication/).
```tsx ctx.tsx
import { use, createContext, type PropsWithChildren } from 'react';
import { useStorageState } from './useStorageState';
const AuthContext = createContext<{
  signIn: () => void;
  signOut: () => void;
  session?: string | null;
  isLoading: boolean;
}>({
  signIn: () => null,
  signOut: () => null,
  session: null,
  isLoading: false,
});
// Use this hook to access the user info.
export function useSession() {
  const value = use(AuthContext);
  if (!value) {
    throw new Error('useSession must be wrapped in a <SessionProvider />');
  }
  return value;
}
export function SessionProvider({ children }: PropsWithChildren) {
  const [[isLoading, session], setSession] = useStorageState('session');
  return (
    <AuthContext.Provider
      value={{
        signIn: () => {
          // Perform sign-in logic here
          setSession('xxx');
        },
        signOut: () => {
          setSession(null);
        },
        session,
        isLoading,
      }}>
      {children}
    </AuthContext.Provider>
  );
}
```
The following code snippet is a basic hook that persists tokens securely on native with [`expo-secure-store`](/versions/latest/sdk/securestore) and in local storage on web.
```tsx useStorageState.ts
import  { useEffect, useCallback, useReducer } from 'react';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
type UseStateHook<T> = [[boolean, T | null], (value: T | null) => void];
function useAsyncState<T>(
  initialValue: [boolean, T | null] = [true, null],
): UseStateHook<T> {
  return useReducer(
    (state: [boolean, T | null], action: T | null = null): [boolean, T | null] => [false, action],
    initialValue
  ) as UseStateHook<T>;
}
export async function setStorageItemAsync(key: string, value: string | null) {
  if (Platform.OS === 'web') {
    try {
      if (value === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, value);
      }
    } catch (e) {
      console.error('Local storage is unavailable:', e);
    }
  } else {
    if (value == null) {
      await SecureStore.deleteItemAsync(key);
    } else {
      await SecureStore.setItemAsync(key, value);
    }
  }
}
export function useStorageState(key: string): UseStateHook<string> {
  // Public
  const [state, setState] = useAsyncState<string>();
  // Get
  useEffect(() => {
    if (Platform.OS === 'web') {
      try {
        if (typeof localStorage !== 'undefined') {
          setState(localStorage.getItem(key));
        }
      } catch (e) {
        console.error('Local storage is unavailable:', e);
      }
    } else {
      SecureStore.getItemAsync(key).then((value: string | null) => {
        setState(value);
      });
    }
  }, [key]);
  // Set
  const setValue = useCallback(
    (value: string | null) => {
      setState(value);
      setStorageItemAsync(key, value);
    },
    [key]
  );
  return [state, setValue];
}
```
---
Step 2: 
Create a **SplashScreenController** to manage the splash screen. Authentication loading is asynchronous, so keep the splash screen visible until authentication loads.
```tsx splash.tsx
import { SplashScreen } from 'expo-router';
import { useSession } from './ctx';
SplashScreen.preventAutoHideAsync();
export function SplashScreenController() {
  const { isLoading } = useSession();
  if (!isLoading) {
    SplashScreen.hide();
  }
  return null;
}
```
Step 3: 
Add the `SessionProvider` to your root layout. This gives your entire app access to the authentication context. Ensure the `SplashScreenController` is inside the `SessionProvider`.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
import { SessionProvider } from '../ctx';
import { SplashScreenController } from '../splash';
export default function Root() {
  // Set up the auth context and render your layout inside of it.
  return (
    <SessionProvider>
      <SplashScreenController />
      <RootNavigator />
    </SessionProvider>
  );
}
// Create a new component that can access the SessionProvider context later.
function RootNavigator() {
  return <Stack />;
}
```
Step 4: 
Create the `/sign-in` screen. This screen toggles authentication using `signIn()`. Since this screen is outside the `(app)` group, the group's layout and authentication check do not run when rendering this screen. This lets logged-out users access this screen.
```tsx app/sign-in.tsx|collapseHeight=480
import { router } from 'expo-router';
import { Text, View } from 'react-native';
import { useSession } from '../ctx';
export default function SignIn() {
  const { signIn } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          signIn();
          // Navigate after signing in. You may want to tweak this to ensure sign-in is successful before navigating.
          router.replace('/');
        }}>
        Sign In
      </Text>
    </View>
  );
}
```
Step 5: 
Now modify the `RootNavigator` to protect routes based on your `SessionProvider`.
```tsx app/_layout.tsx|collapseHeight=400
// All import statements remain the same except you need to import `useSession` from your `ctx.tsx` file.
import { SessionProvider, useSession } from '../ctx';
// All of the above code remains unchanged. Update the `RootNavigator` to protect routes based on your `SessionProvider` below.
function RootNavigator() {
  const { session } = useSession();
  return (
    <Stack>
      <Stack.Protected guard={!!session}>
        <Stack.Screen name="(app)" />
      </Stack.Protected>
      <Stack.Protected guard={!session}>
        <Stack.Screen name="sign-in" />
      </Stack.Protected>
    </Stack>
  );
}
```
Step 6: 
Implement an authenticated screen that lets users sign out.
```tsx app/(app)/index.tsx|collapseHeight=480
import { Text, View } from 'react-native';
import { useSession } from '../../ctx';
export default function Index() {
  const { signOut } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          // The guard in `RootNavigator` redirects back to the sign-in screen.
          signOut();
        }}>
        Sign Out
      </Text>
    </View>
  );
}
```
Step 7: 
Create the **app/(app)/\_layout.tsx**:
```tsx app/(app)/_layout.tsx
import { Stack } from 'expo-router';
export default function AppLayout() {
  // This renders the navigation stack for all authenticated app routes.
  return <Stack />;
}
```
You now have an app that will present the splash screen until the initial authentication state has loaded and will redirects to the sign-in screen if the user is not authenticated. If a user visits a deep link to any routes with the authentication check, they'll be redirected to the sign-in screen.
## Modals and per-route authentication
Another common pattern is to render a sign-in modal over the top of the app. This enables you to dismiss and partially preserve deep links when the authentication is complete. However, this pattern requires routes to be rendered in the background as these routes require handling data loading without authentication.
```
└── app/
    ├── _layout.tsx  # Declares global session context
    └── (app)/
        ├── _layout.tsx
        ├── sign-in.tsx  # Modal presented over the root
        └── (root)/
            ├── _layout.tsx  # Protects child routes
            └── index.tsx  # Requires authorization
```
```tsx app/(app)/_layout.tsx|collapseHeight=480
import { Stack } from 'expo-router';
export const unstable_settings = {
  initialRouteName: '(root)',
};
export default function AppLayout() {
  return (
    <Stack>
      <Stack.Screen name="(root)" />
      <Stack.Screen
        name="sign-in"
        options={{
          presentation: 'modal',
        }}
      />
    </Stack>
  );
}
```
## More information
For more information, read the [Protected routes documentation](/router/advanced/protected/) to learn more about patterns.
Video Tutorial: [How to use Protected Routes in Expo Router version 5 and later for smooth authentication](https://www.youtube.com/watch?v=XCTaMu0qnFY)
## Middleware
Traditionally, websites may leverage some form of server-side redirection to protect routes. Expo Router on the web currently only supports build-time static generation and has no support for custom middleware or serving. This can be added in the future to provide a more optimal web experience. In the meantime, authentication can be implemented by using client-side redirects and a loading state.


## Authentication in Expo Router using redirects

How to implement authentication and protect routes with Expo Router.

> **info** SDK 53 introduced [Protected routes](/router/advanced/protected/), a more powerful method of handling authentication. Please follow this guide if you are using SDK 52 and earlier.
<VideoBoxLink
  videoId="yNaOaR2kIa0"
  title="Building an Auth Flow with Expo Router"
  description="Learn how to implement an auth flow in your Expo Router project."
  className="mb-6"
/>
With Expo Router, all routes are always defined and accessible. You can use runtime logic to redirect users away from specific screens depending on whether they are authenticated. There are two different techniques for authenticating users within routes. This guide provides an example that demonstrates the functionality of standard native apps.
## Using React Context and Route Groups
It's common to restrict specific routes to users who are not authenticated. This is achievable in an organized way by using React Context and Route Groups. Consider the following project structure that has a `/sign-in` route that is always accessible and a `(app)` group that requires authentication:
```
└── app/
    ├── _layout.tsx
    ├── sign-in.tsx  # Always accessible
    └── (app)/
        ├── _layout.tsx  # Protects child routes
        └── index.tsx  # Requires authorization
```
Step 1: 
To follow the above example, set up a [React Context provider](https://react.dev/reference/react/createContext) that can expose an authentication session to the entire app. You can implement your custom authentication session provider or use the one from the **Example authentication context** below.
Note: Example authentication context
---
This provider uses a mock implementation. You can replace it with your own [authentication provider](/guides/authentication/).
```tsx ctx.tsx
import { useContext, createContext, type PropsWithChildren } from 'react';
import { useStorageState } from './useStorageState';
const AuthContext = createContext<{
  signIn: () => void;
  signOut: () => void;
  session?: string | null;
  isLoading: boolean;
}>({
  signIn: () => null,
  signOut: () => null,
  session: null,
  isLoading: false,
});
// This hook can be used to access the user info.
export function useSession() {
  const value = useContext(AuthContext);
  if (!value) {
    throw new Error('useSession must be wrapped in a <SessionProvider />');
  }
  return value;
}
export function SessionProvider({ children }: PropsWithChildren) {
  const [[isLoading, session], setSession] = useStorageState('session');
  return (
    <AuthContext.Provider
      value={{
        signIn: () => {
          // Perform sign-in logic here
          setSession('xxx');
        },
        signOut: () => {
          setSession(null);
        },
        session,
        isLoading,
      }}>
      {children}
    </AuthContext.Provider>
  );
}
```
The following code snippet is a basic hook that persists tokens securely on native with [`expo-secure-store`](/versions/latest/sdk/securestore) and in local storage on web.
```tsx useStorageState.ts
import  { useEffect, useCallback, useReducer } from 'react';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
type UseStateHook<T> = [[boolean, T | null], (value: T | null) => void];
function useAsyncState<T>(
  initialValue: [boolean, T | null] = [true, null],
): UseStateHook<T> {
  return useReducer(
    (state: [boolean, T | null], action: T | null = null): [boolean, T | null] => [false, action],
    initialValue
  ) as UseStateHook<T>;
}
export async function setStorageItemAsync(key: string, value: string | null) {
  if (process.env.EXPO_OS === 'web') {
    if (value === null) {
      localStorage.removeItem(key);
    } else {
      localStorage.setItem(key, value);
    }
  } else {
    if (value == null) {
      await SecureStore.deleteItemAsync(key);
    } else {
      await SecureStore.setItemAsync(key, value);
    }
  }
}
export function useStorageState(key: string): UseStateHook<string> {
  // Public
  const [state, setState] = useAsyncState<string>();
  // Get
  useEffect(() => {
    if (Platform.OS === 'web') {
      try {
        if (typeof localStorage !== 'undefined') {
          setState(localStorage.getItem(key));
        }
      } catch (e) {
        console.error('Local storage is unavailable:', e);
      }
    } else {
      SecureStore.getItemAsync(key).then((value: string | null) => {
        setState(value);
      });
    }
  }, [key]);
  // Set
  const setValue = useCallback(
    (value: string | null) => {
      setState(value);
      setStorageItemAsync(key, value);
    },
    [key]
  );
  return [state, setValue];
}
```
---
Step 2: 
Use the `SessionProvider` in the root layout to provide the authentication context to the entire app. It's imperative that the `<Slot />` is mounted before any navigation events are triggered. Otherwise, a runtime error will be thrown.
```tsx app/_layout.tsx
import { Slot } from 'expo-router';
import { SessionProvider } from '../ctx';
export default function Root() {
  // Set up the auth context and render our layout inside of it.
  return (
    <SessionProvider>
      <Slot />
    </SessionProvider>
  );
}
```
Step 3: 
Create a nested [layout route](/router/basics/layout/) that checks whether users are authenticated before rendering the child route components. This layout route redirects users to the sign-in screen if they are not authenticated.
```tsx app/(app)/_layout.tsx|collapseHeight=400
import { Text } from 'react-native';
import { Redirect, Stack } from 'expo-router';
import { useSession } from '../../ctx';
export default function AppLayout() {
  const { session, isLoading } = useSession();
  // You can keep the splash screen open, or render a loading screen like we do here.
  if (isLoading) {
    return <Text>Loading...</Text>;
  }
  // Only require authentication within the (app) group's layout as users
  // need to be able to access the (auth) group and sign in again.
  if (!session) {
    // On web, static rendering will stop here as the user is not authenticated
    // in the headless Node process that the pages are rendered in.
    return <Redirect href="/sign-in" />;
  }
  // This layout can be deferred because it's not the root layout.
  return <Stack />;
}
```
Step 4: 
Create the `/sign-in` screen. It can toggle the authentication using `signIn()`. Since this screen is outside the `(app)` group, the group's layout and authentication check do not run when rendering this screen. This lets logged-out users see this screen.
```tsx app/sign-in.tsx|collapseHeight=480
import { router } from 'expo-router';
import { Text, View } from 'react-native';
import { useSession } from '../ctx';
export default function SignIn() {
  const { signIn } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          signIn();
          // Navigate after signing in. You may want to tweak this to ensure sign-in is
          // successful before navigating.
          router.replace('/');
        }}>
        Sign In
      </Text>
    </View>
  );
}
```
Step 5: 
Implement an authenticated screen that lets users sign out.
```tsx app/(app)/index.tsx|collapseHeight=480
import { Text, View } from 'react-native';
import { useSession } from '../../ctx';
export default function Index() {
  const { signOut } = useSession();
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Text
        onPress={() => {
          // The `app/(app)/_layout.tsx` will redirect to the sign-in screen.
          signOut();
        }}>
        Sign Out
      </Text>
    </View>
  );
}
```
You now have an app that can present a loading state while it checks the initial authentication state and redirects to the sign-in screen if the user is not authenticated. If a user visits a deep link to any routes with the authentication check, they'll be redirected to the sign-in screen.
## Alternative loading states
With Expo Router, something must be rendered to the screen while loading the initial auth state. In the example above, the app layout renders a loading message. Alternatively, you can make the `index` route a loading state and move the initial route to something such as `/home`, which is similar to how X works.
## Modals and per-route authentication
Another common pattern is to render a sign-in modal over the top of the app. This enables you to dismiss and partially preserve deep links when the authentication is complete. However, this pattern requires routes to be rendered in the background as these routes require handling data loading without authentication.
```
└── app/
    ├── _layout.tsx  # Declares global session context
    └── (app)/
        ├── _layout.tsx
        ├── sign-in.tsx  # Modal presented over the root
        └── (root)/
            ├── _layout.tsx  # Protects child routes
            └── index.tsx  # Requires authorization
```
```tsx app/(app)/_layout.tsx|collapseHeight=480
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: '(root)',
};
export default function AppLayout() {
  return (
    <Stack>
      <Stack.Screen name="(root)" />
      <Stack.Screen
        name="sign-in"
        options={{
          presentation: 'modal',
        }}
      />
    </Stack>
  );
}
```
## Navigating without navigation
You may encounter the following error when the app attempts to perform navigation without a navigator mounted in the [root layout](/router/basics/layout/#root-layout).
```text
Error: Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.
```
To fix this, add a group and move conditional logic down a level.
### Before
```
└── app/
    ├── _layout.tsx
    └── about.tsx
```
```tsx app/_layout.tsx
export default function RootLayout() {
  React.useEffect(() => {
    // This navigation event will trigger the error above.
    router.push('/about');
  }, []);
  // This conditional statement creates a problem since the root layout's
  // content (the Slot) must be mounted before any navigation events occur.
  if (isLoading) {
    return <Text>Loading...</Text>;
  }
  return <Slot />;
}
```
### After
```
└── app/
    ├── _layout.tsx
    └── (app)/
        ├── _layout.tsx  # Move conditional logic down a level
        └── about.tsx
```
```tsx app/_layout.tsx
export default function RootLayout() {
  return <Slot />;
}
```
```tsx app/(app)/_layout.tsx
export default function RootLayout() {
  React.useEffect(() => {
    router.push('/about');
  }, []);
  // It is OK to defer rendering this nested layout's content. We couldn't
  // defer rendering the root layout's content since a navigation event (the
  // redirect) would have been triggered before the root layout's content had
  // been mounted.
  if (isLoading) {
    return <Text>Loading...</Text>;
  }
  return <Slot />;
}
```
## Middleware
Traditionally, websites may leverage some form of server-side redirection to protect routes. Expo Router on the web currently only supports build-time static generation and has no support for custom middleware or serving. This can be added in the future to provide a more optimal web experience. In the meantime, authentication can be implemented by using client-side redirects and a loading state.


## Nesting navigators

Learn how to nest navigators in Expo Router.

> **warning** Navigation UI elements (Link, Tabs, Stack) may move out of the Expo Router library in the future.
<VideoBoxLink
  videoId="izZv6a99Roo"
  title="Using a Stack Navigator with Expo Router"
  description="Navigate between screens, pass params between screens, create dynamic routes, and configure the screen titles and animations."
  className="mb-6"
/>
Nesting navigators allow rendering a navigator inside the screen of another navigator. This guide is an extension of [React Navigation: Nesting navigators](https://reactnavigation.org/docs/nesting-navigators) to Expo Router. It provides an example of how nesting navigators work when using Expo Router.
## Example
Consider the following file structure which is used as an example:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── home/
        ├── _layout.tsx
        ├── feed.tsx
        └── messages.tsx
```
In the above example, **app/home/feed.tsx** matches `/home/feed`, and **app/home/messages.tsx** matches `/home/messages`.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default Stack;
```
Both **app/home/\_layout.tsx** and **app/index.tsx** below are nested in the **app/\_layout.tsx** layout so that it will be rendered as a stack.
```tsx app/home/_layout.tsx
import { Tabs } from 'expo-router';
export default Tabs;
```
```tsx app/index.tsx
import { Link } from 'expo-router';
export default function Root() {
  return <Link href="/home/messages">Navigate to nested route</Link>;
}
```
Both **app/home/feed.tsx** and **app/home/messages.tsx** below are nested in the **home/\_layout.tsx** layout, so it will be rendered as a tab.
```tsx app/home/feed.tsx
import { View, Text } from 'react-native';
export default function Feed() {
  return (
    <View>
      <Text>Feed screen</Text>
    </View>
  );
}
```
```tsx app/home/messages.tsx
import { View, Text } from 'react-native';
export default function Messages() {
  return (
    <View>
      <Text>Messages screen</Text>
    </View>
  );
}
```
## Navigate to a screen in a nested navigator
In React Navigation, navigating to a specific nested screen can be controlled by passing the screen name in params. This renders the specified nested screen instead of the initial screen for that nested navigator.
For example, from the initial screen inside the `root` navigator, you want to navigate to a screen called `media` inside `settings` (a nested navigator). In React Navigation, this is done as shown in the example below:
```jsx React Navigation
navigation.navigate('root', {
  screen: 'settings',
  params: {
    screen: 'media',
  },
});
```
In Expo Router, you can use `router.push()` to achieve the same result. There is no need to pass the screen name in the params explicitly.
```jsx Expo Router
router.push('/root/settings/media');
```


## Modals

Learn how to use modals in Expo Router.

<VideoBoxLink
  videoId="gNzuJVRmyDk"
  title="Using Modals with Expo Router"
  description="Learn about the different ways to display content over the rest of your app."
  className="mb-6"
/>
Modals are a common user interface pattern in mobile apps. They are used to present content on top of the existing screen and is used for different purposes, such as displaying confirmation alerts or standalone forms. You can create modals in your app using the following methods:
- Use React Native's [`Modal`](https://reactnative.dev/docs/modal) component.
- Use Expo Router's special file-based syntax to create a modal screen within the app's navigation system.
Each approach has its specific use case. Understanding when to use each method is important for creating a positive user experience.
## React Native's Modal component
The `Modal` component is part of React Native's core API. Common use cases include:
- Standalone interactions, such as self-contained tasks that don't need to be part of the navigation system.
- Temporary alerts or confirmation dialogs that are ideal for quick interactions.
Below is an example of a custom `Modal` component that overlays the current screen on different platforms:
For most use cases, you can use the `Modal` component and customize it according to your app's user interface requirements. For details on how to use the `Modal` component and its props, see the [React Native documentation](https://reactnative.dev/docs/modal).
## Modal screen using Expo Router
A modal screen is a file created inside the **app** directory and is used as a route within the existing stack. It is used for complex interactions that need to be part of the navigation system, such as multi-step forms where you can link to a specific screen after the process completes.
Below is an example of how a modal screen works on different platforms:
### Usage
To implement a modal route, create a screen called **modal.tsx** inside the **app** directory. Here's an example file structure:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── modal.tsx
```
The above file structure produces a layout where the `index` is the first route in the stack. Inside the root layout file (**app/\_layout.tsx**), you can add the `modal` route in the stack. To present it as a modal, set the `presentation` option to `modal` on the route.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'modal',
        }}
      />
    </Stack>
  );
}
```
You can use the `Link` component to navigate to the modal screen from the **index.tsx** file.
```tsx app/index.tsx|collapseHeight=350
import { Link } from 'expo-router';
import { StyleSheet, Text, View } from 'react-native';
export default function Home() {
  return (
    <View style={styles.container}>
      <Text>Home screen</Text>
      <Link href="/modal" style={styles.link}>
        Open modal
      </Link>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  link: {
    paddingTop: 20,
    fontSize: 20,
  },
});
```
The **modal.tsx** presents the contents of the modal.
```tsx app/modal.tsx|collapseHeight=250
import { StyleSheet, Text, View } from 'react-native';
export default function Modal() {
  return (
    <View style={styles.container}>
      <Text>Modal screen</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
### Modal presentation and dismiss behavior
A modal loses its previous context when it is the current screen in the navigator and is presented as a standalone screen. Its presentation and dismissal behavior are different on each platform:
- On Android, the modal slides on top of the current screen. To dismiss it, use the back button to navigate back to the previous screen.
- On iOS, the modal slides from the bottom of the current screen. To dismiss it, swipe it down from the top.
- On web, the modal is presented as a separate route, and the dismiss behavior has to be provided manually using [`router.canGoBack()`](/router/navigating-pages/#imperative-navigation). Here's an example of how to dismiss the modal:
```tsx app/modal.tsx
import { StyleSheet, Text, View } from 'react-native';
export default function Modal() {
  const isPresented = router.canGoBack();
  return (
    <View style={styles.container}>
      <Text>Modal screen</Text>
      {isPresented && <Link href="../">Dismiss modal</Link>}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
### Change status bar appearance on iOS
By default on iOS, the modal has a dark background which hides the status bar. To change the status bar appearance, you can use the `Platform` API to check if the current platform is iOS and then use the [`StatusBar`](/versions/latest/sdk/status-bar/) component to change the appearance inside the **modal.tsx** file.
```tsx app/modal.tsx|collapseHeight=250
import { StyleSheet, Text, View, Platform } from 'react-native';
import { StatusBar } from 'expo-status-bar';
export default function Modal() {
  return (
    <View style={styles.container}>
      <Text>Modal screen</Text>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```
### Handle deep-linked modals
While working with stack or nested stack navigators, modals need to be anchored to ensure correct navigation behavior. This is essential when deep-linking to modal routes. Without anchoring, the screen behind the modal will be wiped away, leaving no navigation context.
An _anchor_ serves as the base for the modal. In complex apps, when you have nested stacks, the anchor must be defined for the nested stack, and its value becomes the initial route of the stack.
You can configure an anchor by exporting `unstable_settings` from your stack's layout file:
```tsx
export const unstable_settings = {
  anchor: 'index', // Anchor to the index route
};
```
In the above example, the `anchor: 'index'` tells the Expo Router that it should maintain the specified anchor route in the background when presenting a modal.
## Additional information
### Presentation options
There are different options to present a modal screen using the `presentation` option on Android and iOS.
| Option                      | Description                                                                                                                                                                                                                      |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `card`                      | The new screen will be pushed onto a stack. The default animation on Android will vary depending on the OS version and theme. On iOS, it will slide from the side.                                                               |
| `modal`                     | The new screen will be presented modally, allowing for a nested stack to be rendered inside the screen.                                                                                                                          |
| `transparentModal`          | The new screen will be presented modally, with the previous screen remaining visible. This allows the content below to still be seen if the screen has a translucent background.                                                 |
| `containedModal`            | On Android, fallbacks to `modal`. On iOS, uses [`UIModalPresentationCurrentContext`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationcurrentcontext) modal style.                    |
| `containedTransparentModal` | On Android, fallbacks to `transparentModal`. On iOS, uses [`UIModalPresentationOverCurrentContext`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationovercurrentcontext) modal style. |
| `fullScreenModal`           | On Android, fallbacks to `modal`. On iOS, uses [`UIModalPresentationFullScreen`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationfullscreen) modal style.                            |
| `formSheet`                 | On Android, fallbacks to `modal`. On iOS, uses [`UIModalPresentationFormSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationformsheet) modal style.                              |


## Web modals

Learn how to implement and customize the behavior of a modal in your web app using Expo Router.

> **important** Web modals are in alpha and available in SDK 54 and later. To use this feature, you must set the `EXPO_UNSTABLE_WEB_MODAL=1` environment variable in your project.
Modern web apps require a flexible modal experience that adapts to different content sizes and user interactions. Expo Router provides various modal presentation patterns for modern web experiences. These patterns leverage `presentation` with `modal`, `formSheet`, `transparentModal`, or `containedTransparentModal` to present either a modal based on different screen widths, and provide customizable styling props using `webModalStyle`.
## Get started
> **info** To use the new web modal features, you must set the `EXPO_UNSTABLE_WEB_MODAL=1` environment variable for both development and [export](/deploy/web/#export-your-web-project) builds. You can do this by adding it to your **.env** file at the root of your project or by prefixing your commands, for example: `EXPO_UNSTABLE_WEB_MODAL=1 npx expo start`.
Modals in Expo Router are configured using `Stack.Screen` component with specific options. This requires the modal screen to be added to the layout file of your app's `Stack`.
Consider the following navigation tree, which includes a stack navigator defined in the layout file, a home screen where the modal is accessed, and the modal screen component:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── modal.tsx
```
In the layout file (**app/\_layout.tsx**), the modal screen component is added to the Stack navigator:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'modal', // Enables modal behavior
          sheetAllowedDetents: [0.5, 1], // Array of snap positions for screens that have a width less than 768px.
        }}
      />
    </Stack>
  );
}
```
The **modal.tsx** is used to display the contents of a modal:
```tsx app/modal.tsx
import { Text, View } from 'react-native';
export default function Modal() {
  return <View style={{ flex: 1, padding: 16 }}>{/* Modal content goes here */}</View>;
}
```
Now, to open the modal from **index.tsx**, you can use `router.push('/modal')` in your index route:
```tsx app/index.tsx
import { router } from 'expo-router';
import { Pressable, Text, View, StyleSheet } from 'react-native';
export default function Home() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home Screen</Text>
      <Pressable onPress={() => router.push('/modal')} style={styles.button}>
        <Text style={styles.buttonText}>Open Modal</Text>
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 16,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: '600',
  },
});
```
Here's the result of the above example:
## Anchors and nested stacks
When working with stack or nested stack navigators, modals need to be properly anchored to ensure correct navigation behavior, especially when deep-linking to modal routes. Without anchoring, the screen behind the modal will be wiped away, leaving no navigation context.
An _anchor_ serves as the base for the modal. In complex apps, when you have nested stacks, the anchor must be defined for the nested stack, and its value becomes the initial route of the stack.
You can configure an anchor by exporting `unable_settings` from your stack's layout file:
```tsx
export const unstable_settings = {
  anchor: 'index', // Anchor to the index route
};
```
In the above example, the `anchor: 'index'` tells the Expo Router that it should maintain the specified anchor route in the background when presenting a modal.
## Modal presentation style
The difference between the presentation of how a modal appears in your web app on a large screen (for example, a desktop) while maintaining the sheet behavior when the web app runs on a mobile device, depends on the configuration options. The following are options available for configuring a web modal's appearance that can be passed to the `options` object of a `Stack.Screen`.
| Option                | Type                                                                          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| --------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `presentation`        | `'modal'`, `'formSheet'`, `'transparentModal'`, `'containedTransparentModal'` | Modal presentation style. On screens with width more than 768px, all styles display as a centered overlay (for example, a lightbox).  On screens with width less than `768px`, `formSheet` is used to display as a bottom sheet. When set to `transparentModal`, it displays as an overlay without a completely obscure background content. Detents and sheet grabber properties are not applied. This presentation is useful when building your own custom modal.  Similar to `transparentModal`, when set to `containedTransparentModal`, it displays as an overlay without a completely obscure background content. Detents and other properties are not applied. This presentation is useful when building your own custom modal. |
| `sheetAllowedDetents` | `number[]`, `'fitToContents'`                                                 | Snap positions as percentages (0.0-1.0) or automatic fitting. Only applies to screens with less than `768px` width.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `sheetGrabberVisible` | `boolean`                                                                     | **On iOS, s**hows/hides the drag handle at the top of the sheet. Not supported on Android and web. We recommend using a custom sheet header component to imitate the grabber across all platforms.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `sheetCornerRadius`   | `number`                                                                      | Corner radius of the sheet in pixels.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `webModalStyle`       | `WebModalStyle`                                                               | Special prop that allows web-specific styling options for fine-tuning modal appearance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
## Custom modal styling with `webModalStyle`
> **info** **Note:** The `webModalStyle` properties only apply to web platforms. On mobile, the modal will automatically adapt to use sheet-like behavior for touch interaction.
You can use `webModalStyle` to customize the dimensions and appearance of your modals on web. It provides the following properties for further customization:
| Property            | Type              | Description                                                                                                                    | Default                |
| ------------------- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------ | ---------------------- |
| `width`             | `number` `string` | Override the width of the modal (px or percentage). Only applies for web platform on a desktop.                                | `83vw`                 |
| `height`            | `number` `string` | Override the height of the modal (px or percentage). Only applies for web platform on a desktop.                               | `79vh`                 |
| `minHeight`         | `number` `string` | Minimum height of the desktop modal (px or percentage). Overrides the default iOS 26 sizing.                                   | `min(586px, 79vh)`     |
| `minWidth`          | `number` `string` | Minimum width of the desktop modal (px or percentage). Overrides the default iOS 26 sizing.                                    | `min(936px, 83vw)`     |
| `border`            | `string`          | Override the border of the desktop modal (any valid CSS border value, for example, '1px solid #ccc' or 'none')                 | None                   |
| `overlayBackground` | `string`          | Override the overlay background color (any valid CSS color or rgba/hsla value).                                                | Semi-transparent black |
| `shadow`            | `string`          | Override the modal shadow filter (any valid CSS filter value, for example, 'drop-shadow(0 4px 8px rgba(0,0,0,0.1))' or 'none') | Drop-shadow filter     |
### Custom CSS properties
Expo Router uses custom CSS properties to style modals, which you can override globally using `webModalStyle`. These variables provide fine-grained control over a modal's appearance.
#### Width and height sizing variables
```css
/* Default modal width (83vw on desktop, following iOS 26 specifications) */
--expo-router-modal-width: 83vw;
/* Maximum modal width (936px max, 83vw by default, following iOS 26) */
--expo-router-modal-max-width: min(936px, 83vw);
/* Minimum modal width (auto by default) */
--expo-router-modal-min-width: auto;
/* Default modal height (79vh, following iOS 26 specifications) */
--expo-router-modal-height: 79vh;
/* Minimum modal height (586px max, 79vh by default, following iOS 26) */
--expo-router-modal-min-height: min(586px, 79vh);
```
#### Border and overlay styling variables
```css
/* Modal border (none by default) */
--expo-router-modal-border: none;
/* Modal corner radius (24px by default, following iOS 26) */
--expo-router-modal-border-radius: 24px;
/* Modal shadow filter (drop-shadow by default) */
--expo-router-modal-shadow: drop-shadow(0 10px 8px rgb(0 0 0 / 0.04))
  drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));
/* Overlay background color (25% black by default) */
--expo-router-modal-overlay-background: rgba(0, 0, 0, 0.25);
```
#### How `webModalStyle` maps to CSS variables
When you use `webModalStyle` to override any of the sizing variables, Expo Router automatically sets these CSS variables to the values you provide:
```tsx
// This webModalStyle configuration
webModalStyle: {
  width: 800,
  height: 600,
  border: '2px solid blue',
  overlayBackground: 'rgba(0, 0, 0, 0.7)',
  shadow: 'drop-shadow(0 8px 16px rgba(0,0,0,0.2))',
}
// ...automatically sets these CSS variables:
// --expo-router-modal-width: 800px
// --expo-router-modal-height: 600px
// --expo-router-modal-border: 2px solid blue
// --expo-router-modal-overlay-background: rgba(0, 0, 0, 0.7)
// --expo-router-modal-shadow: drop-shadow(0 8px 16px rgba(0,0,0,0.2))
```
## Common examples
Note: Full screen modal example
---
To create a full screen modal for content that covers maximum space, you can use `webModalStyle` property in your modal route's `Stack.Screen` options:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'modal',
          webModalStyle: {
            width: '95vw',
            height: '95vh',
            border: 'none',
          },
        }}
      />
    </Stack>
  );
}
```
Here's the result of the above example:
When running your web app on mobile devices, you can set `sheetAllowedDetents` to `fitToContents` or a custom value if you want to avoid showing a full screen modal:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'modal',
          webModalStyle: {
            width: '95vw',
            height: '95vh',
            border: 'none',
          },
          sheetAllowedDetents: 'fitToContents',
        }}
      />
    </Stack>
  );
}
```
The modal appears as a sheet on a mobile device:
---
Note: Compact modal example
---
For smaller interactions, you can create a compact modal that fits its content:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'modal',
          webModalStyle: {
            width: 400,
            height: 'auto',
            minHeight: 200,
            border: '1px solid #e5e7eb',
            overlayBackground: 'rgba(0, 0, 0, 0.3)',
          },
          sheetCornerRadius: 12,
          sheetAllowedDetents: 'fitToContents',
        }}
      />
    </Stack>
  );
}
```
Here's the result of the above example:
---
Note: Transparent modal example
---
You can set the `presentation` option to `transparentModal` when you want to display an overlay that should maintain the visual context of the underlying screen:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'transparentModal',
        }}
      />
    </Stack>
  );
}
```
Here's the result of the above example:
---
Note: Corner radius example
---
You customize the corner radius using `sheetCornerRadius`:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'formSheet',
          sheetAllowedDetents: [0.4],
          sheetCornerRadius: 32,
        }}
      />
    </Stack>
  );
}
```
Here's the result of the above example:
---
Note: Custom detents example
---
You can use `sheetAllowedDetents` to define the height at which the modal can rest:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  anchor: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'formSheet',
          sheetAllowedDetents: [0.2, 0.5, 0.8, 0.98],
        }}
      />
    </Stack>
  );
}
```
Here's the result of the above example:
---
## Global CSS customization
For your web app, if you are using a [global CSS](https://docs.expo.dev/versions/latest/config/metro/#global-css) file in your project, you can also override width, height, border, and overlay variables.
You can add custom values using the `--expo-router-*` variables in your global CSS file:
```css
/* Override default modal styling globally */
:root {
  --expo-router-modal-width: 700px;
  --expo-router-modal-min-width: auto;
  --expo-router-modal-max-width: 95vw;
  --expo-router-modal-height: 640px;
  --expo-router-modal-min-height: 640px;
  --expo-router-modal-border: none;
  --expo-router-modal-border-radius: 16px;
  --expo-router-modal-shadow: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2));
  --expo-router-modal-overlay-background: rgba(0, 0, 0, 0.5);
}
```
## Custom modal route implementation
{/* TODO (@aman): When publishing this guide, remove "Web modals implementation" from the modals.tsx file. */}
The video above demonstrates a modal window that appears over the main content of the web page. The background dims to draw focus to the modal, which contains information for the user. This is typical behavior for web modals, where users can interact with the modal or close it to return to the main page.
You can achieve the above web modal behavior by using the [`transparentModal`](https://reactnavigation.org/docs/stack-navigator/#transparent-modals) presentation mode, styling the overlay and modal content, and utilizing [`react-native-reanimated`](/versions/latest/sdk/reanimated/#installation) to animate the modal's presentation.
Modify your project's root layout (**app/\_layout.tsx**) to add an `options` object to the modal route:
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  initialRouteName: 'index',
};
export default function Layout() {
  return (
    <Stack>
      <Stack.Screen name="index" />
      <Stack.Screen
        name="modal"
        options={{
          presentation: 'transparentModal',
          animation: 'fade',
          headerShown: false,
        }}
      />
    </Stack>
  );
}
```
> **info** **Note:** `unstable_settings` currently works only with `Stack` navigators.
The above example sets the `index` screen as the [`initialRouteName`](/router/advanced/router-settings/#initialroutename) using [`unstable_settings`](/router/advanced/router-settings). This ensures that the transparent modal is always rendered on top of the current screen, even when users navigate to the modal screen via a direct link.
Style the overlay and modal content in **modal.tsx** as shown below:
```tsx app/modal.tsx|collapseHeight=250
import { Link } from 'expo-router';
import { Pressable, StyleSheet, Text } from 'react-native';
import Animated, { FadeIn, SlideInDown } from 'react-native-reanimated';
export default function Modal() {
  return (
    <Animated.View
      entering={FadeIn}
      style={{
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: '#00000040',
      }}
    >
      {/* Dismiss modal when pressing outside */}
      <Link href={'/'} asChild>
        <Pressable style={StyleSheet.absoluteFill} />
      </Link>
      <Animated.View
        entering={SlideInDown}
        style={{
          width: '90%',
          height: '80%',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: 'white',
        }}
      >
        <Text style={{ fontWeight: 'bold', marginBottom: 10 }}>Modal Screen</Text>
        <Link href="/">
          <Text>← Go back</Text>
        </Link>
      </Animated.View>
    </Animated.View>
  );
}
```
You can customize the modal's appearance as per your needs.


## Shared routes

Learn how to define shared routes or use arrays to use the same route multiple times with different layouts using Expo Router.

To match the same URL with different layouts, use [**groups**](/router/basics/notation/#parentheses) with overlapping child routes. This pattern is very common in native apps. For example, in the X app, a profile can be viewed in every tab (such as home, search, and profile). However, there is only one URL that is required to access this route.
In the example below, **app/\_layout.tsx** is the tab bar and each route has its own header. The **app/(profile)/[user].tsx** route is shared between each tab.
```
└── app/
    ├── _layout.tsx
    ├── (home)/
    │   ├── _layout.tsx
    │   └── [user].tsx
    ├── (search)/
    │   ├── _layout.tsx
    │   └── [user].tsx
    └── (profile)/
        ├── _layout.tsx
        └── [user].tsx
```
> When reloading the page, the first alphabetical match is rendered.
Shared routes can be navigated directly by including the group name in the route. For example, `/(search)/baconbrix` navigates to `/baconbrix` in the "search" layout.
## Arrays
> Array syntax is an advanced concept that is unique to native app development.
Instead of defining the same route multiple times with different layouts, use the array syntax `(,)` to duplicate the children of a group. For example, `app/(home,search)/[user].tsx` &mdash; creates `app/(home)/[user].tsx` and `app/(search)/[user].tsx` in memory.
To distinguish between the two routes use a layout's `segment` prop:
```tsx app/(home,search)/_layout.tsx
export default function DynamicLayout({ segment }) {
  if (segment === '(search)') {
    return <SearchStack />;
  }
  return <Stack />;
}
```
To enable the **array syntax**, specify the [`initialRouteName`](/router/advanced/router-settings/#initialroutename) for each group using `unstable_settings` object in the dynamic layout:
```tsx app/(home,search)/_layout.tsx
export const unstable_settings = {
  initialRouteName: 'home',
  search: {
    initialRouteName: 'search',
  },
};
export default function DynamicLayout({ segment }) {
}
```
In the above example, the `home` route is the default route for the `home` group and the app. The `search` route is the default route for the `search` group.
## Key points
- You can only provide groups for the current navigator.
- When using the array syntax, if there are two groups (for example, `(one)/(two)`), only the last group's segment is used for matching the route.
- If there are at least two group `initialRouteNames`, but a default `initialRouteName` is not provided, the first group's `initialRouteName` is used.


## Protected routes

Learn how to make screens inaccessible to client-side navigation.

> **warning** Protected routes are available in SDK 53 and later.
Video Tutorial: [Watch: Using protected routes](https://www.youtube.com/watch?v=zHZjJDTTHJg)
## Overview
Protected screens allow you to prevent users from accessing certain routes using client-side navigation. If a user tries to navigate to a protected screen, or if a screen becomes protected while it is active, they will be redirected to the anchor route (usually the index screen) or the first available screen in the stack.
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    ├── about.tsx
    ├── login.tsx  # Should only be available while not authenticated
    └── private/
        ├── _layout.tsx  # Should only be available while authenticated
        ├── index.tsx
        └── page.tsx
```
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
const isLoggedIn = false;
export function AppLayout() {
  return (
    <Stack>
      <Stack.Protected guard={!isLoggedIn}>
        <Stack.Screen name="login" />
      </Stack.Protected>
      <Stack.Protected guard={isLoggedIn}>
        <Stack.Screen name="private" />
      </Stack.Protected>
      {/* Expo Router includes all routes by default. Adding Stack.Protected creates exceptions for these screens. */}
    </Stack>
  );
}
```
In this example, the `/private` route is inaccessible because the `guard` is false. When a user attempts to access `/private`, they are redirected to the anchor route, which is the **index** screen.
Additionally, if the user is on `/private/page` and the `guard` condition changes to **false**, they will be redirected automatically.
When a screen's **guard** is changed from **true** to **false**, all of its history entries will be removed from the navigation history.
## Multiple protected screens
In Expo Router, a screen can **only exist in one active route group at a time**.
You should only declare a screen only once, in the most appropriate group or stack. If a screen's availability depends on logic, wrap it in a conditional group instead of duplicating the screen.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
const isLoggedIn = true;
const isAdmin = true;
export function AppLayout() {
  return (
    <Stack>
      <Stack.Protected guard={true}>
        <Stack.Screen name="profile" />
      </Stack.Protected>
      <Stack.Screen name="profile" /> // ❌ Not allowed: duplicate screen
    </Stack>
  );
}
```
## Nesting protected screens
Protected screens can be nested to define hierarchical access control logic.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
const isLoggedIn = true;
const isAdmin = true;
export function AppLayout() {
  return (
    <Stack>
      <Stack.Protected guard={isLoggedIn}>
        <Stack.Protected guard={isAdmin}>
          <Stack.Screen name="private" />
        </Stack.Protected>
        <Stack.Screen name="about" />
      </Stack.Protected>
    </Stack>
  );
}
```
In this case:
- `/private` is only protected if the user is logged in and is an admin.
- `/about` is protected to any logged-in user.
## Falling back to a specific screen
You can configure the navigator to fall back to a specific screen if access is denied.
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    ├── about.tsx
    ├── login.tsx
    └── private/
        ├── _layout.tsx
        ├── index.tsx
        └── page.tsx
```
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
const isLoggedIn = false;
export function AppLayout() {
  return (
    <Stack>
      <Stack.Protected guard={isLoggedIn}>
        <Stack.Screen name="index" />
        <Stack.Screen name="private" />
      </Stack.Protected>
      <Stack.Screen name="login" />
    </Stack>
  );
}
```
In the above example, since the **index** screen is protected and the `guard` is **false**, the router redirects to the first available screen &mdash; **login**.
## Tabs and Drawer
Protected routes are also available for [Tabs](/router/advanced/tabs/) and [Drawer](/router/advanced/drawer/) navigators.
```tsx app/_layout.tsx
import { Tabs } from 'expo-router';
const isLoggedIn = false;
export default function TabLayout() {
  return (
    <Tabs>
      <Tabs.Screen name="index" options={{ tabBarLabel: 'Home' }} />
      <Tabs.Protected guard={isLoggedIn}>
        <Tabs.Screen name="private" options={{ tabBarLabel: 'Private' }} />
        <Tabs.Screen name="profile" options={{ tabBarLabel: 'Profile' }} />
      </Tabs.Protected>
      <Tabs.Protected guard={!isLoggedIn}>
        <Tabs.Screen name="login" options={{ tabBarLabel: 'Login' }} />
      </Tabs.Protected>
    </Tabs>
  );
}
```
## Custom navigators
`Protected` is also available for [custom navigators](/router/migrate/from-react-navigation/#rewrite-custom-navigators) using the `withLayoutContext` hook.
## Static rendering considerations
Protected screens are evaluated on the client side only. During static site generation, no HTML files are created for protected routes. However, if users know the URLs of these routes, they can still request the corresponding HTML or JavaScript files directly. Protected screens are not a replacement for server-side authentication or access control.


# Advanced

## Platform-specific extensions and module

Learn how to switch modules based on the platform in Expo Router using platform-specific extensions and Platform module from React Native.

While building your app, you may want to show specific content based on the current platform. Platform-specific extensions and `Platform` module can make the experience more native to a given platform. The following sections describe the ways you can achieve this with Expo Router.
## Platform-specific extensions
> **warning** Platform-specific extensions were added in Expo Router `3.5.x`. If you are using an older version of the library, follow instructions from [Platform-specific modules](#platform-module).
There are two ways to use platform-specific extensions:
### Within app directory
Metro bundler's platform-specific extensions (for example, **.android.tsx**, **.ios.tsx**, **.native.tsx**, or **.web.tsx**) are supported in the **app** directory only if a **non-platform version** also exists. This ensures that routes are universal across platforms for deep linking.
Consider the following project structure:
```
└── app/
    ├── _layout.tsx
    ├── _layout.web.tsx
    ├── index.tsx
    ├── about.tsx
    └── about.web.tsx
```
In the above file structure:
- **\_layout.web.tsx** file is used as a layout on the web and **\_layout.tsx** is used on all other platforms.
- **index.tsx** file is used as the home page for all platforms.
- **about.web.tsx** file is used as the about page for the web, and the **about.tsx** file is used on all other platforms.
### Outside app directory
You can create platform-specific files with extensions (for example, **.android.tsx**, **.ios.tsx**, **.native.tsx**, or **.web.tsx**) outside the **app** directory and use them from within the **app** directory.
Consider the following project structure:
```
├── app/
│   ├── _layout.tsx
│   ├── index.tsx
│   └── about.tsx
└── components/
    ├── about.tsx
    ├── about.ios.tsx
    └── about.web.tsx
```
In the above file structure, the designs require you to build different `about` screens for each platform. In that case, you can create a component for each platform in the **components** directory using platform extensions. When imported, Metro will ensure the correct component version is used based on the current platform. You can then re-export the component as a screen in the **app** directory.
```tsx app/about.tsx
export { default } from '../components/about';
```
## Platform module
You can use the [`Platform`](https://reactnative.dev/docs/platform-specific-code#platform-module) module from React Native to detect the current platform and render the appropriate content based on the result. For example, you can render a `Tabs` layout on native and a custom layout on the web.
```tsx app/_layout.tsx
import { Platform } from 'react-native';
import { Link, Slot, Tabs } from 'expo-router';
export default function Layout() {
  if (Platform.OS === 'web') {
    // Use a basic custom layout on web.
    return (
      <div style={{ flex: 1 }}>
        <header>
          <Link href="/">Home</Link>
          <Link href="/settings">Settings</Link>
        </header>
        <Slot />
      </div>
    );
  }
  // Use a native bottom tabs layout on native platforms.
  return (
    <Tabs>
      <Tabs.Screen name="index" options={{ title: 'Home' }} />
      <Tabs.Screen name="settings" options={{ title: 'Settings' }} />
    </Tabs>
  );
}
```


## Customizing links

Learn how to perform link redirection and utilize third-party deep links with +native-intent when using Expo Router.

Expo Router uses an extended version of web standards to navigate through an app. However, native apps do not always conform to server-based routing. This can lead to misalignment when integrating any third-party service. For example, apps can be launched with arbitrary strings or intent objects instead of URLs. There are two common scenarios where you may need to customize a link:
- **App Closed**: When the app is not open, incoming deep-link URLs may require rewriting to ensure seamless navigation.
- **App Open**: When the app is already open, URL customization may be necessary based on specific business logic or user interactions. This logic can be global for the entire app, or localized to a set of routes.
## Setup linking
See the [Linking into your app](/linking/into-your-app/) guide for instructions on how to set up and test linking in your app.
## Rewrite incoming native deep links
Expo Router will always evaluate a URL with the assumption that the URL targets a specific page within the app. However, in practice, these URLs can vary in nature:
- **Unique/Referred URLs from third-party providers**: These URLs often follow a specific schema, such as `<my-scheme>://<provider-hostname>/<uuid>`, and are generated by external sources to navigate users to designated content within the app.
- **Stale URLs from previous versions**: App users might encounter URLs from older versions of the app, which could lead to outdated or non-existent content. It's crucial to handle such scenarios gracefully to ensure a smooth user experience.
In such scenarios, the URL needs to be rewritten to correctly target a route.
To facilitate this, create a special file called **+native-intent.tsx** at the top level of your project's **app** directory. This file exports a special [`redirectSystemPath`](/versions/latest/sdk/router/#nativeintent) method designed to handle URL/path processing. When invoked, it receives an `options` object with two attributes: `path` and `initial`.
```
└── app/
    └── +native-intent.tsx
```
Here's an example the applies practices on how `redirectSystemPath` is used inside **+native-intent.tsx** file. Following this example, you can ensure the stability and reliability of your app's URL processing functionality and mitigate the risk of unexpected errors and crashes.
```ts app/+native-intent.tsx
import ThirdPartyService from 'third-party-sdk';
export function redirectSystemPath({ path, initial }) {
  try {
    if (initial) {
      // While the parameter is called `path` there is no guarantee that this is a path or a valid URL
      const url = new URL(path, 'myapp://app.home');
      // Detection of third-party URLs will change based on the provider
      if (url.hostname === '<third-party-provider-hostname>') {
        return ThirdPartyService.processReferringUrl(url).catch(() => {
          // Something went wrong
          return '/unexpected-error';
        });
      }
      return path;
    }
    return path;
  } catch {
    // Do not crash inside this function! Instead you should redirect users
    // to a custom route to handle unexpected errors, where they are able to report the incident
    return '/unexpected-error';
  }
}
```
## Rewrite incoming web deep links
Handling deep links on the web differs from native platforms, as the initial routing process occurs differently. Expo Router cannot provide a direct counterpart to `+native-intent` for web, as web routing is resolved before the website's JavaScript is executed and will differ based upon deployment output and your chosen provider.
As a result, you should implement one of the following patterns that best suits your requirements:
- **Server Redirect**: Since all websites, including static pages, are hosted on a server, consider leveraging server-side redirection or middleware options provided by your deployment provider. This approach is well-suited for deployments targeting **server** or **static** outputs.
- **Client Redirect**: Alternatively, you can manage URL redirects within your app's root `_layout`. This approach is ideal for projects with a single output format targeting client-side rendering.
Choose the pattern that aligns with your deployment strategy and technical requirements to ensure seamless handling of incoming deep links on the web platform.
## Rewrite URLs
While your app is open, you can react to URL changes within your `_layout` files using the `usePathname()` hook. The location of the `_layout` dictates the scope of the subscription.
- **global**: Add the logic to your root `_layout` file
- **localized**: Add a `_layout` file to an existing directory (or create a new [group directory](/router/basics/notation/#parentheses))
```tsx app/_layout.tsx
import { Slot, Redirect } from 'expo-router';
export default function RootLayout() {
  const pathname = usePathname();
  if (pathname && !isUserAllowed(pathname)) {
    return <Redirect href="/home" />;
  }
  return <Slot />;
}
```
### Using `redirectSystemPath`
In native apps, an alternative way to rewrite a URL is to handle it within the [`redirectSystemPath`](#redirectsystempath) method. This approach can be simpler for some use cases but comes with certain drawbacks:
- **Native-only**: This method will not work on the web, as `+native-intent` is only available in native apps.
- **Lacks context**: `+native-intent` is processed outside the context of your app. This means you won't have access to additional logic, such as user authentication status or the current route's state.
## Sending navigation events to third-party services
Below is a basic example of how to send navigation events to an external service, such as an analytics or logging service. Consult with your provider for specific instructions.
```tsx app/_layout.tsx
import ThirdPartyService from 'third-party-sdk';
import { Slot, usePathname } from 'expo-router';
const thirdParty = new ThirdPartyService();
export default function RootLayout() {
  const pathname = usePathname();
  // Perform the service initiation logic
  useEffect(() => {
    thirdParty.register();
    return () => {
      thirdParty.deregister();
    };
  }, [thirdParty]);
  // Send pathname changes to the third party
  useEffect(() => {
    thirdParty.sendEvent({ pathname });
  }, [pathname]);
  return <Slot />;
}
```
## Universal Links and multiple domains
Expo Router does not require additional configuration for Universal Links and multiple domains. All URLs provided to your App will be evaluated. To customize the URL scheme(s) for your app, your should [customize the `scheme` value in your app config](/versions/latest/config/app/#scheme).
## Forcing web links
If you want a URL to be initially evaluated by the user's browser, write the address as a Fully Qualified URL (FQDN) with an `http`/`https` scheme. Using a complete URL ensures that the link is interpreted as a web URL and opened in the user's browser by default.
This approach is effective for directing users to external websites or Universal Links for other apps.
```ts
<Link href="https://my-website.com/router/introduction" />
```
## `legacy_subscribe`
> **important** `legacy_subscribe` is in alpha and is available in SDK 52.
If you're using a third-party provider that doesn't support Expo Router but does support React Navigation via the `Linking.subscribe` function for existing projects, you can use `legacy_subscribe` as an alternative API.
Using this API is not recommended for new projects or integrations. Its usage is incompatible with Server Side Routing and [Static Rendering](/router/web/static-rendering/), and can be challenging to manage while offline or in a low network connectivity environment.


## Router settings

Learn how to configure layouts with static properties in Expo Router.

> **warning** **Warning:** `unstable_settings` currently do not work with [async routes](/router/web/async-routes/) (development-only). This is why the feature is designated _unstable_.
#### initialRouteName
When deep linking to a route, you may want to provide a user with a "back" button. The `initialRouteName` sets the default screen of the stack and should match a valid filename (without the extension).
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── other.tsx
```
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
export const unstable_settings = {
  // Ensure any route can link back to `/`
  initialRouteName: 'index',
};
export default function Layout() {
  return <Stack />;
}
```
Now deep linking directly to `/other` or reloading the page will continue to show the back arrow.
When using [array syntax](/router/advanced/shared-routes/#arrays) `(foo,bar)` you can specify the name of a group in the `unstable_settings` object to target a particular segment.
```tsx other.tsx
export const unstable_settings = {
  // Used for `(foo)`
  initialRouteName: 'first',
  // Used for `(bar)`
  bar: {
    initialRouteName: 'second',
  },
};
```
The `initialRouteName` is only used when deep-linking to a route. During app navigation, the route you are navigating to will be the initial route. You can disable this behavior using the `initial` prop on the `<Link />` component or by passing the option to the imperative APIs.
```js
// If this navigates to a new _layout, don't override the initial route
<Link href="/route" initial={false} />;
router.push('/route', { overrideInitialScreen: false });
```


## Apple Handoff

Learn how to seamlessly continue app navigation across Apple devices with Expo Router and Apple Handoff.

Apple Handoff is a feature that enables users to continue browsing your app or website on another device. Expo Router automates all of the runtime routing for this feature. However, the one-time configuration must be set up manually.
In Expo Router, the underlying iOS API (`NSUserActivity`) requires a `webpageUrl` which the OS recommends as the current URL for switching to your app. The `expo-router/head` component has an optional native module that can automatically set the `webpageUrl` to the currently focused route in Expo Router.
## Setup
The following restrictions and considerations are important:
- Handoff is Apple-only.
- Handoff can not be used in the Expo Go app as it requires build-time configuration.
- Handoff requires [universal links](/linking/into-your-app/) to be configured, at least on iOS, and contain the `activitycontinuation` object.
- Handoff requires the `expo-router/head` component to be used on each page that you want to support, or in the root layout if you want all pages to be continuous.
To ensure that the **public/.well-known/apple-app-site-association** file is configured correctly, it must include the `activitycontinuation` key with an `apps` array that contains your app's bundle ID and Team ID formatted as `<APPLE_TEAM_ID>.<IOS_BUNDLE_ID>`. For example, `QQ57RJ5UTD.app.expo.acme` where `QQ57RJ5UTD` is the Team ID and `app.expo.acme` is the bundle identifier.
```json public/.well-known/apple-app-site-association
{
  "applinks": {
    "details": [
      {
        "appIDs": ["<APPLE_TEAM_ID>.<IOS_BUNDLE_ID>"],
        "components": [
          {
            "/": "*",
            "comment": "Matches all routes"
          }
        ]
      }
    ]
  },
  "activitycontinuation": {
    "apps": ["<APPLE_TEAM_ID>.<IOS_BUNDLE_ID>"]
  },
  "webcredentials": {
    "apps": ["<APPLE_TEAM_ID>.<IOS_BUNDLE_ID>"]
  }
}
```
> The `webcredentials` object is optional but recommended.
You can use the following command to generate the **apple-app-site-association** file based on your [app config](/versions/latest/config/app/):
```sh
$ npx setup-safari
```
See [Test the deep link](/linking/into-your-app/#test-the-deep-link) guide to test handoff in development.
### Expo Head setup
Ensure you set the Handoff origin in your `app.config.tsx` file using the `expo-router` config plugin. This is the URL that will be used for the `webpageUrl` when the user switches to your app.
```tsx app.config.tsx
// Be sure to change this to be unique to your project.
process.env.EXPO_TUNNEL_SUBDOMAIN = 'bacon-router-sandbox';
const ngrokUrl = `${process.env.EXPO_TUNNEL_SUBDOMAIN}.ngrok.io`;
/** @type {import('expo/config').ExpoConfig} */
module.exports = {
  // ...
  ios: {
    associatedDomains: [
      `applinks:${ngrokUrl}`,
      `activitycontinuation:${ngrokUrl}`,
      `webcredentials:${ngrokUrl}`,
      // Add additional production-URLs here.
      // `applinks:example.com`,
      // `activitycontinuation:example.com`,
      // `webcredentials:example.com`,
    ],
  },
  plugins: [
    [
      'expo-router',
      {
        // Note: The URL must start with "https://" in "headOrigin"
        headOrigin:
          process.env.NODE_ENV === 'development'
            ? `https://${ngrokUrl}`
            : 'https://my-website-example.com',
      },
    ],
  ],
};
```
> Do not use the development-only `?mode=developer` suffix when testing handoff to native.
After configuring the app config, regenerate your native project with the following command:
```sh
$ npx expo prebuild -p ios
```
In development, you must start the website **before installing the app on your device**. This is because when you install the app, the OS will trigger Apple's servers to ping your website for the **.well-known/apple-app-site-association** file. If the website is not running, the OS will not be able to find the file and handoff will not work. If this happens, rebuild the native app with `npx expo run:ios -d`.
## Usage
In any route that you want to support handoff, use the `Head` component from `expo-router/head`:
```tsx app/index.tsx
import Head from 'expo-router/head';
import { Text } from 'react-native';
export default function App() {
  return (
    <>
      <Head>
        <meta property="expo:handoff" content="true" />
      </Head>
      <Text>Hello World</Text>
    </>
  );
}
```
### Meta tags
The `expo-router/head` component supports the following meta tags:
| Meta tags                | Description                                                                                                                                                                                                                                           |
| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `expo:handoff`           | Set to `true` to enable handoff for the current route. Defaults to `false`. (iOS only)                                                                                                                                                                |
| `og:title` and `<title>` | Set the title for the `NSUserActivity` this is unused with handoff.                                                                                                                                                                                   |
| `og:description`         | Set the description for the `NSUserActivity` this is unused with handoff.                                                                                                                                                                             |
| `og:url`                 | Set the URL that should be opened when the user switches to your app. Defaults to the current URL in-app with `headOrigin` prop in the `expo-router` config plugin, as the baseURL. Passing a relative path will append the `headOrigin` to the path. |
You may want to switch the values between platforms, for that you can use **Platform.select**:
```tsx app/index.tsx
import Head from 'expo-router/head';
export default function App() {
  return (
    <Head>
      <meta
        property="og:url"
      />
    </Head>
  );
}
```
## Debugging
Ensure your Apple devices have [Handoff enabled](https://support.apple.com/en-us/HT209455). You can test this by following the steps below but substituting your app with Safari.
1. Open your native application on your device.
2. Navigate to a route in the app that supports handoff which is rendering the `<Head />` element from Expo Router.
3. To switch to your Mac and click the app's Handoff icon in the Dock.
4. To switch to your iPhone or iPad, open the App Switcher, and tap the app banner at the bottom of the screen.
If you only see the Safari icon in your iPhone's App Switcher, then handoff is not working.
## Troubleshooting
You can test the Apple App Site Association file (**public/.well-known/apple-app-site-association**) by using a validator such as, [AASA Validator](https://branch.io/resources/aasa-validator/).
If you're having issues, the best thing you can do is enable the most aggressive handoff settings in your app. This ensures that any possible route is linkable. You can do this by making sure that **public/.well-known/apple-app-site-association** file matches all routes:
```json public/.well-known/apple-app-site-association
{
  "applinks": {
    "details": [
      {
        "appIDs": ["<APPLE_TEAM_ID>.<IOS_BUNDLE_ID>"],
        "components": [
          {
            "/": "*",
            "comment": "Matches all routes"
          }
        ]
      }
    ]
  }
}
```
In the application, ensure you are not rendering the `<Head />` element conditionally (for example, in an `if/else` block), it must be rendered on every page that you want to support handoff. We recommend adding it to the [Root Layout](/router/basics/layout/#root-layout) component to ensure every route is linkable while debugging.
Ensure you can access the Ngrok URL (for example, via the browser), before installing the app on your device. If you can't access the URL, the OS will not be able to find the file and handoff will not work.
`npx expo run:ios` and Xcode will both codesign your app when associated domains is set up, this is required for handoff and universal links to work.
Handoff between your Mac and iPhone/iPad is not supported in the Expo Go app. You must build and install your app on your device.
**If you see the Safari icon in the App Switcher on your iPhone**, then it means handoff is not working.
- Ensure you are not using the `?mode=developer` suffix when testing handoff to native.
- Also be sure you're not using the local development server URL. For example, `http://localhost:8081` as this cannot be used as a valid app site association link, open the running Ngrok URL in your browser to test.
- Ensure your **public/.well-known/apple-app-site-association** file contains the `activitycontinuation` field.
- We've observed that in iOS 16.3.1 and macOS 13.0 (Ventura), bundle identifiers starting with `app.` and `io.` will sometimes not trigger the native app to show up in the iOS task switcher. Use `com.` as the first part of your bundle identifier.
Your **public/.well-known/apple-app-site-association** must be served from a secure URL (HTTPS). If you are using a development tunnel, you must use the `EXPO_TUNNEL_SUBDOMAIN` environment variable to configure the subdomain for your development tunnel. The tunnel is required for testing in development because you need SSL to use universal links, Expo CLI provides built-in support for this by running `npx expo start --tunnel`.
Check your **ios&#x2f;project&#x2f;project.entitlements** file, under the `com.apple.developer.associated-domains` key. This should contain the same domains as your web server/website. The URL cannot contain a protocol (`https://`) or additional pathname, query parameters, or fragments.
### Still stuck
> This is an important but very difficult feature to set up. Expo Router automates many of the moving parts, Expo CLI automates much of the configuration and hosting. However, hardware settings can still be misconfigured.
If all else fails, you can try to debug the issue by following the steps in the [Apple Docs](https://developer.apple.com/documentation/foundation/task_management/implementing_handoff_in_your_app). Note that:
- "Representing user activities as instances of `NSUserActivity`." is performed by the Expo Head native module.
- "Updating the activity instances as the user performs actions in your app." is performed by mounting/rendering the `<Head />` component with the meta tag `<meta property="expo:handoff" content="true" />` inside.
- "Receiving activities from Handoff in your app on other devices." is performed by an [App Delegate Subscriber](/modules/appdelegate-subscribers) in the Expo Head native module. It is used to redirect you to the correct route when you handoff to your native app.
## Known issues
Handoff from web to native does not support client-side routing. This means the URL presented in the App Switcher will be the URL of the page you were on when you clicked the link, or reloaded the page. It is a limitation of the web platform and not something that can be fixed by Expo Router.


## Custom tab layouts

Learn how to use headless tab components to create custom tab layouts in Expo Router.

> **important** Experimentally available in SDK 52 and later.
Expo Router offers a set of components to create custom tab layouts via the submodule [`expo-router/ui`](/versions/latest/sdk/router-ui/). Unlike the React Navigation styled `Tabs`, these components are unstyled and flexible. They are designed to allow you build complex UI patterns from scratch in your project.
For other tab layouts see:
## Anatomy of custom Tabs components
There are four components offered by `expo-router/ui` to create custom tab layouts:
| Component    | Description                                                                                                                     |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------- |
| `Tabs`       | Wrapper component which contains the `<View>` for the tabs.                                                                     |
| `TabList`    | The containing `<View>` for the list of `TabTrigger` components.                                                                |
| `TabTrigger` | A trigger component to switch to the specified tab. It is used to define the route using `href` prop and a `name` for each tab. |
| `TabSlot`    | A slot to render the currently selected tab.                                                                                    |
A bare minimum structure of a custom tab layout would consist of a `TabList` (containing `TabTrigger` components for each tab) and a`TabSlot`, all within the `Tabs` component, as shown here:
```tsx app/(tabs)/_layout.tsx|collapseHeight=440
import { Tabs, TabList, TabTrigger, TabSlot } from 'expo-router/ui';
import { Text } from 'react-native';
// Defining the layout of the custom tab navigator
export default function Layout() {
  return (
    <Tabs>
      <TabSlot />
      <TabList>
        <TabTrigger name="home" href="/">
          <Text>Home</Text>
        </TabTrigger>
        <TabTrigger name="article" href="/article">
          <Text>Article</Text>
        </TabTrigger>
      </TabList>
    </Tabs>
  );
}
```
## Creating routes
The `TabList` contains all the routes available within the tab navigator. It must be an immediate child of `Tabs`. Each route is defined by a `TabTrigger` within the `TabList`. A `TabTrigger` within a `TabList` must include a `name` and a `href` prop.
Typically, the `TabList` defines both the available tab routes and the appearance of the tabs, with the children of each `TabTrigger` defining the appearance of each tab button.
> **Note:** A `name` can be any `string`. This is a user-defined name for the Tab.
### Dynamic routes
Dynamic routes are allowed and can be provided with values via the `href`.
```
├── _layout.tsx
└── [slug].tsx
```
The trigger `<TabTrigger name="dynamic page" href="/hello-world" />` will create a tab for **[slug].tsx** with the params `{ slug: 'hello-world' }`. This setup can be useful for displaying an arbitrary number of tabs in the tab bar, based on end-user data, such as showing a separate tab for each user profile in an app.
### Ambiguous routes
```
├── _layout.tsx
└── (one,two)/
    └── route.tsx  # A route within a shared group
```
The `href` values provided to `TabTrigger` must always point to a single route. In the above example of a shared route, href `/route` is not allowed, as it could refer to either `/(one)/route` or `/(two)/route`. However, specifying the route group within the href would work (for example,`href="/(one)/route"`).
### Nested routes
```
├── _layout.tsx
└── (stack-one)/
    ├── _layout.tsx  # A <Stack> layout
    └── (stack-two)/
        ├── _layout.tsx  # Nested <Stack> layout
        └── route.tsx
```
A `TabTrigger` can link to a deeply nested route. `<TabTrigger name="route" href="/route" />` will show the **(stack-one)/(stack-two)/route.tsx** route. This tab will be controlled by that route's parent navigator (that is, the navigator within **stack-two_layout.tsx**). This navigation is similar to a deep link.
## Rendering routes
The `TabSlot` component renders the current route. `TabSlot` can be nested inside other components within `Tabs` but cannot be within the `TabList`.
```tsx app/_layout.tsx
<Tabs>
  <TabList>
    <TabTrigger name="home" href="/">
      <Text>Home</Text>
    </TabTrigger>
  </TabList>
  {/* Customize how `<TabSlot />` is rendered. */}
  <View>
    <View>
      <TabSlot />
    </View>
  </View>
</Tabs>
```
## Switching tabs
Tabs can be switched via a `Link` or using the imperative APIs. However, these APIs will always perform a navigation action (they will switch tabs and might change the URL). To switch tabs without performing any navigation, you should use a `TabTrigger`. A `TabTrigger` is an unstyled `<View>` that will switch tabs when pressed, much like how text and components can be wrapped in `Link` to make them pressable navigation elements.
### Resetting navigation
The `reset` prop from `TabTrigger` can be used to control when a tab resets its navigation state. The options are `always`, `onLongPress` and `never`. This is particularly useful for a stack navigator nested inside a tab. For example, `<TabTrigger name="home" reset="always" />` will return the user to the index route inside a tab's nested stack navigator.
## TabTrigger
The `TabTrigger` is used to switch tabs, but also has a dual role of defining what routes are available as a tab.
### Within TabList
When a `TabTrigger` is used as a child of `TabList`, that defines what routes are available within the tab navigator. These `TabTrigger` need to include both the `name` and `href` props, as they define the URL for that tab and a custom name that can be used to refer to the tab. If the `TabTrigger` components also contain text or other components as children, then those will also render as the tab buttons. However, you can define the `TabTrigger`'s within the `TabList` without any UI, and they can then be invoked by `TabTrigger`'s outside of the `TabList`.
### Outside TabList
An additional `TabTrigger` can be defined outside of a `TabList`, allowing you to perform the same action as the `TabTrigger` that is defined in the `TabList`. In this case, the `TabTrigger` will not have an `href` prop. Rather, it will perform the same action as the primary `TabTrigger` with the same `name` prop. This allows you to create components that can switch tabs and be agnostic to your current navigation state. Note that all `TabTrigger`'s need to at least be descendants of the `Tabs` component, or else they will be considered to be outside the tab navigator and unable to invoke it.
## Customizing appearance
All components are rendered unstyled as a `<View>`, except `TabTrigger` which renders as a `<Pressable>`. This allows you to provide a custom `style` prop to customize their appearance. Styling `TabList` is similar to customizing the tab bar in React Navigation, while styling `TabTrigger` affects the appearance of tab buttons.
If you need to change the structure of a component, you can override its underlying component by using the `asChild` props. The component then acts as a slot, and will forward its props to its immediate child.
```tsx Custom TabList
<Tabs>
  <TabSlot />
  <TabList asChild>
    {/* Render a custom TabList */}
    <CustomTabList>
      <TabTrigger name="home" href="/">
        <Text>Home</Text>
      </TabTrigger>
    </CustomTabList>
  </TabList>
</Tabs>
```
```tsx Custom Button
<Tabs>
  <TabSlot />
  <TabList asChild>
    <TabTrigger name="home" href="/" asChild>
      {/* Render a custom button */}
      <CustomButton>
        <Text>Home</Text>
      </CustomButton>
    </TabTrigger>
  </TabList>
</Tabs>
```
### Multiple tab bars
The `TabList` is both the configuration and default appearance of the `Tabs`, but it is not the only way to render a tab bar. By hiding the `TabList`, you can construct custom tab bars using `TabTrigger`.
```tsx Multiple tab bars example
<Tabs>
  <TabSlot />
  {/* A custom tab bar */}
  <View>
    <View>
      <TabTrigger name="home">
        <Text>Home</Text>
      </TabTrigger>
      <TabTrigger name="article">
        <Text>article</Text>
      </TabTrigger>
    </View>
  </View>
  <TabList style={{ display: 'none' }}>
    <TabTrigger name="home" href="/">
      <Text>Home</Text>
    </TabTrigger>
    <TabTrigger name="article" href="/article">
      <Text>article</Text>
    </TabTrigger>
  </TabList>
</Tabs>
```
`TabTrigger` will forward an `isFocused` prop, so you can create a separate tab button component that reacts to focused status.
```tsx TabButton.tsx
import FontAwesome from '@expo/vector-icons/FontAwesome';
import { TabTriggerSlotProps } from 'expo-router/ui';
import { ComponentProps, Ref } from 'react';
import { Text, Pressable, View } from 'react-native';
type Icon = ComponentProps<typeof FontAwesome>['name'];
export type TabButtonProps = TabTriggerSlotProps & {
  icon?: Icon;
  ref: Ref<View>;
};
export function TabButton({ icon, children, isFocused, ...props }: TabButtonProps) {
  return (
    <Pressable
      {...props}
      style={[
        {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          flexDirection: 'column',
          gap: 5,
          padding: 10,
        },
        isFocused ? { backgroundColor: 'white' } : undefined,
      ]}>
      <FontAwesome name={icon} />
      <Text style={[{ fontSize: 16 }, isFocused ? { color: 'white' } : undefined]}>{children}</Text>
    </Pressable>
  );
}
```
Note: Expo SDK 52 / React 18 and earlier
---
In Expo SDK 52 and earlier (React 18), use the legacy `forwardRef` function to access the `ref` handle.
<DiffBlock source="/static/diffs/router/custom-tabs/forward-ref-tab-button.diff" />
---
### Hooks
All components also have a hook version giving you control over the render tree. See the [Router UI Reference](/versions/latest/sdk/router-ui/) for a full list of the hooks available.
Using hooks is considered advanced usage of this library. For most use-cases, using the components with `asChild` should give you enough control over the render tree.
If you are developing a custom `<TabTrigger />`, you may also need to develop a custom `<TabList />` as `<TabList />` uses the [`useTabsWithChildren()`](/versions/latest/sdk/router-ui/#usetabswithchildrenoptions) which requires using the exported `<TabTrigger />` component.
### Customizing how tab screens are rendered
The `TabSlot` accepts a `renderFn` property. This function can be used to override how your screen is rendered, allowing you to implement advanced functionality such as animations or persisting/unmounting screens. See the [Router UI Reference](/versions/latest/sdk/router-ui/) for more information.
## Common questions
Note: How do I create multiple tabs for the same route?
---
```
├── _layout.tsx  # Tabs layout
└── (movie,tv)/
    └── [id].tsx
```
You should add the route to a shared group and create a separate `TabTrigger` for each group `group`.
---
Note: How do I hide a tab?
---
Not rendering the `TabTrigger` will remove that tab (and its navigation state) from your app.
---
Note: How do I create animated tabs?
---
You can provide a custom renderer to `TabSlot` to customize how it renders a screen. You can use this to detect when screen is focused an animate appropriately.
---
Note: Can I use relative hrefs?
---
```
└── directory/
    ├── _layout.tsx  # The local pathname is /directory
    ├── page.tsx  # The pathname is /directory/page
    └── profile.tsx  # The pathname is /directory/profile
```
A `TabTrigger` with a relative href is relative to the local path name `Tabs` was rendered on. This is different from normal relative hrefs which are relative to the current displayed route. For example, the `<TabTrigger href="./profile" />` will resolve to `/directory/profile`, even when the `/directory/page` route is showing. Expo recommends against using relative hrefs.
---


# Web

## API Routes

Learn how to create server endpoints with Expo Router.

Expo Router enables you to write secure server code for all platforms, right in your **app** directory.
```ts app/hello+api.ts
export function GET(request: Request) {
  return Response.json({ hello: 'world' });
}
```
Server features require a custom server, which can be deployed to EAS or most [other hosting providers](#deployment).
Video Tutorial: [Watch: Expo Router API Routes Handle Requests & Stream Data](https://www.youtube.com/watch?v=2_UzR1wdimI)
## What are API Routes
API Routes are functions that are executed on a server when a route is matched. They can be used to handle sensitive data, such as API keys securely, or implement custom server logic, such as exchanging auth codes for access tokens. API Routes should be executed in a [WinterCG](https://wintercg.org/)-compliant environment.
In Expo, API Routes are defined by creating files in the **app** directory with the `+api.ts` extension. For example, the following API route is executed when the route `/hello` is matched.
```
└── app/
    ├── index.tsx
    └── hello+api.ts  # API Route
```
## Create an API route
Step 1: 
Ensure your project is using server output, this will configure the export and production builds to generate a server bundle as well as the client bundle.
```json app.json
{
  "web": {
    "output": "server"
  }
}
```
Step 2: 
An API route is created in the **app** directory. For example, add the following route handler. It is executed when the route `/hello` is matched.
```ts app/hello+api.ts
export function GET(request: Request) {
  return Response.json({ hello: 'world' });
}
```
You can export any of the following functions `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, `HEAD`, and `OPTIONS` from a server route. The function executes when the corresponding HTTP method is matched. Unsupported methods will automatically return `405: Method not allowed`.
Step 3: 
Start the development server with Expo CLI:
```sh
$ npx expo
```
Step 4: 
You can make a network request to the route to access the data. Run the following command to test the route:
```sh
$ curl http://localhost:8081/hello
```
You can also make a request from the client code:
```tsx app/index.tsx
import { Button } from 'react-native';
async function fetchHello() {
  const response = await fetch('/hello');
  const data = await response.json();
  alert('Hello ' + data.hello);
}
export default function App() {
  return <Button onPress={() => fetchHello()} title="Fetch hello" />;
}
```
Relative fetch requests automatically fetch relative to the dev server origin in development, and can be configured in production using the `origin` field in the **app.json**:
```json app.json
{
  "plugins": [
    [
      "expo-router",
      {
        "origin": "https://evanbacon.dev/"
      }
    ]
  ]
}
```
This URL can be automatically configured during EAS Builds by setting the `EXPO_UNSTABLE_DEPLOY_SERVER=1` environment variable. This will trigger a versioned server deployment which sets the origin to a preview deploy URL automatically.
Step 5: 
Deploy the website and server to a [hosting provider](#deployment) to access the routes in production on both native and web.
> **warning** API route filenames cannot have platform-specific extensions. For example, **hello+api.web.ts** will not work.
## Requests
Requests use the global, standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.
```ts app/blog/[post]+api.ts
export async function GET(request: Request, { post }: Record<string, string>) {
  // const postId = new URL(request.url).searchParams.get('post')
  // fetch data for 'post'
  return Response.json({ ... });
}
```
### Request body
Use the `request.json()` function to access the request body. It automatically parses the body and returns the result.
```ts app/validate+api.ts
export async function POST(request: Request) {
  const body = await request.json();
  return Response.json({ ... });
}
```
### Request query parameters
Query parameters can be accessed by parsing the request URL:
```ts app/endpoint+api.ts
export async function GET(request: Request) {
  const url = new URL(request.url);
  const post = url.searchParams.get('post');
  // fetch data for 'post'
  return Response.json({ ... });
}
```
## Response
Responses use the global, standard [`Response`](https://fetch.spec.whatwg.org/#response) object.
```ts app/demo+api.ts
export function GET() {
  return Response.json({ hello: 'universe' });
}
```
### Errors
For error cases, you can create `Response`s with any status code and response body.
```ts app/blog/[post]+api.ts
export async function GET(request: Request, { post }: Record<string, string>) {
  if (!post) {
    return new Response('No post found', {
      status: 404,
      headers: {
        'Content-Type': 'text/plain',
      },
    });
  }
  // fetch data for `post`
  return Response.json({ ... });
}
```
Making requests with an undefined method will automatically return `405: Method not allowed`. If an error is thrown during the request, it will automatically return `500: Internal server error`.
## Runtime API
> **important** The server runtime API and `expo-server` are available in SDK 54 and later and require a deployed server for production use.
You can use the [`expo-server`](/versions/latest/sdk/server/) library to use several utilities and code patterns that work in any server-side Expo code. This includes utilities to get request metadata, for scheduling tasks, and for error handling.
```sh
$ npx expo install expo-server
```
Using `expo-server` is not limited to API routes and it can be used in any other server code as well, for example, in [server middleware](/router/web/middleware/).
### Error handling
You can abort a request and instead return an error `Response` by throwing a [`StatusError`](/versions/latest/sdk/server/#statuserror). This is a special `Error` instance that will be replaced with an HTTP response replacing the error itself.
```ts app/blog/[post]+api.ts
import { StatusError } from 'expo-server';
export async function GET(request: Request, { post }: Record<string, string>) {
  if (!post) {
    throw new StatusError(404, 'No post found');
  }
  // ...
}
```
When composing your own server utilities and helpers, the `StatusError` is a more convenient way to handle exceptions, since throwing them interrupts any API functions and returns an error early.
`StatusError`s accept a status code and an error message, which can also optionally be passed as a JSON, or `Error` object, and will always return a `Response` with a JSON body with an `error` key set to their error message.
This can be restrictive, and isn't suitable for all cases. Sometimes it might be beneficial to instead `throw` a `Response` object, which interrupts your logic as well, but replaces the resolved `Response` from your API route directly, without a `StatusError` wrapper. For example, this can be used to create redirect responses.
```ts app/blog/[post]+api.ts
import { StatusError } from 'expo-server';
export async function GET(request: Request, { post }: Record<string, string>) {
  if (!post) {
    throw Response.redirect('https://expo.dev', 302);
  }
  // ...
}
```
### Request metadata
Requests typically carry most metadata you'll need in their headers. However, `expo-server` provides some helper functions to retrieve common values more easily.
Helper functions from `expo-server` return values that are scoped to the current `Request`. You can only call these functions in server-side code and only during ongoing requests.
A common value that you may need to access is the request's origin URL. The origin URL, typically transmitted on a request's `Origin` header, represents the URL that a user used to access your API route. This may differ from any internal deployment URL that your server sees when the request is being proxied. You can use `expo-server`'s [`origin()`](/versions/latest/sdk/server/#origin) helper method to access this value.
```ts app/help+api.ts
import { origin } from 'expo-server';
export async function GET(request: Request) {
  const target = new URL('/help', origin() ?? request.url);
  return Response.redirect('https://expo.dev', 302);
}
```
Most runtimes that you deploy your server code to have a concept of environments, to differentiate between production or staging deployments. You can use `expo-server`'s [`environment()`](/versions/latest/sdk/server/#environment) helper to get an environment name. This value will differ depending on how you're running your server code.
```ts app/env+api.ts
import { environment } from 'expo-server';
export async function GET(request: Request) {
  const env = environment();
  if (env === 'staging') {
    return Response.json({ isStaging: true });
  } else if (!env) {
    return Response.json({ isProduction: true });
  } else {
    return Response.json({ env });
  }
}
```
### Task scheduling
In your request handlers, you may need to run asynchronous tasks in parallel to your server logic.
```ts app/tasks+api.ts
export async function GET(request: Request) {
  // This will delay the response:
  await pingAnalytics(...);
  const data = await fetchExampleData(...);
  return Response.json({ data });
}
```
In the above example, an `await`-ed function call delays the rest of the API route's execution. If we don't want to delay a `Response`, then `await`-ing this call isn't suitable. However, calling the function without `await` wouldn't guarantee that this task keeps a serverless function running.
Instead, you can use `expo-server`'s [`runTask()`](/versions/latest/sdk/server/#runtaskfn) helper function to run concurrent tasks. This is equivalent to the [`waitUntil()`](https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil) method that you see in service worker code or other serverless runtimes.
```ts app/tasks+api.ts
import { runTask } from 'expo-server';
export async function GET(request: Request) {
  // This will NOT delay the response:
  runTask(async () => {
    await pingAnalytics(...);
  });
  const data = await fetchExampleData(...);
  return Response.json({ data });
}
```
With `runTask`, you have a compromise between `await`-ing and not `await`-ing asynchronous functions. They'll be run concurrently, and don't delay the API route's response or execution, but are also making sure the runtime is aware of them, and don't quit early.
However, sometimes you may want to delay a task until after the API route has returned a `Response`. In such cases, you might prefer not to execute the task if the API has rejected it. Additionally, you may want to run a function only after a time-sensitive task has been completed to prevent concurrent code from delaying computation-heavy tasks in your API route.
You can use `expo-server`'s [`deferTask()`](/versions/latest/sdk/server/#defertaskfn) helper function to schedule tasks to run after a `Response` has been resolved by your API route.
```ts app/tasks+api.ts
import { deferTask } from 'expo-server';
export async function GET(request: Request) {
  // This will run after this entire function resolves:
  deferTask(async () => {
    await pingAnalytics(...);
  });
  const data = await fetchExampleData(...);
  return Response.json({ data });
}
```
### Response headers
When structuring and splitting server logic into separate helper functions and files, it may be necessary to modify `Response` headers before a `Response` has been created.
For example, you may need to add metadata in [server middleware](/router/web/middleware/) to a `Response` before your API route code is running.
```ts app/+middleware.ts
import { setResponseHeaders } from 'expo-server';
export default function middleware(request: Request) {
  // Rate limiters typically add a `Retry-After` header
  setResponseHeaders({ 'Retry-After': '3600' });
}
```
In the above example, a `Retry-After` header is added to a future `Response` that an API route may be creating. This can also be extended for authentication and cookies.
```ts app/+middleware.ts
import { setResponseHeaders } from 'expo-server';
export default function middleware(request: Request) {
  // Append cookie to future response
  setResponseHeaders(headers => {
    headers.append('Set-Cookie', 'token=123; Secure');
  });
}
```
## Bundling
API Routes are bundled with Expo CLI and [Metro bundler](/guides/customizing-metro). They have access to all of the language features as your client code:
- [TypeScript](/guides/typescript) &mdash; types and [**tsconfig.json** paths](/guides/typescript/#path-aliases-optional).
- [Environment variables](/guides/environment-variables) &mdash; server routes have access to all environment variables, not just the ones prefixed with `EXPO_PUBLIC_`.
- Node.js standard library &mdash; ensure that you are using the correct version of Node.js locally for your server environment.
- **babel.config.js** and **metro.config.js** support &mdash; settings work across both client and server code.
## Security
Route handlers are executed in a sandboxed environment that is isolated from the client code. It means you can safely store sensitive data in the route handlers without exposing it to the client.
- Client code that imports code with a secret is included in the client bundle. It applies to **all files** in the **app directory** even though they are not a route handler file (such as suffixed with **+api.ts**).
- If the secret is in a **&lt;...&gt;+api.ts** file, it is not included in the client bundle. It applies to all files that are imported in the route handler.
- The secret stripping takes place in `expo/metro-config` and requires it to be used in the **metro.config.js**.
## Deployment
When you're ready to deploy to production, run the following command to create the server bundle in the **dist** directory (see the [Expo CLI documentation](/more/expo-cli#exporting) for more details):
```sh
$ npx expo export --platform web
```
This server can be tested locally with `npx expo serve` (available in Expo SDK 52 and later), visit the URL in a web browser or create a native build with the `origin` set to the local server URL.
You can deploy the server for production using [EAS Hosting](/eas/hosting/get-started) or another third-party service.
If you want to export API routes and skip generating a website version of your app, you can use the following command, which will generate a **dist** directory containing only the server code of your project.
```sh
$ npx expo export --platform web --no-ssg
```
### Native deployment
> **important** This is an alpha feature starting in SDK 52 and later. The process will be more automated and have better support in future versions.
Server features (API routes, and React Server Components) in Expo Router are centered around native implementations of `window.location` and `fetch` which point to the remote server. In development, we automatically point to the dev server running with `npx expo start`, but for production native builds to work you'll need to deploy the server to a secure host and set the `origin` property of the Expo Router Config Plugin.
When configured, features like relative fetch requests `fetch('/my-endpoint')` will automatically point to the server origin.
This deployment process can experimentally be automated to ensure correct versioning during native builds with the `EXPO_UNSTABLE_DEPLOY_SERVER=1` environment variable.
Here's how to configure your native app to automatically deploy and link a versioned production server on build:
Step 1: 
Ensure the `origin` field is **NOT** set in the **app.json** or in the `expo.extra.router.origin` field. Also, ensure you aren't using **app.config.js** as this is not supported with automatically linked deployments yet.
Step 2: 
Setup [EAS Hosting](/eas/hosting/get-started) for the project by deploying once locally first.
```sh
$ npx expo export -p web
$ eas deploy
```
Step 3: 
Set the `EXPO_UNSTABLE_DEPLOY_SERVER` environment variable in your `.env` file. This will be used to enable the experimental server deployment functionality during EAS Build.
```sh .env
EXPO_UNSTABLE_DEPLOY_SERVER=1
```
Step 4: 
You're now ready to use automatic server deployment! Run the build command to start the process.
```sh
$ eas build
```
You can also run this locally with:
```sh
$ npx expo run:android --variant release
$ npx expo run:ios --configuration Release
```
Notes about automatic server deployment for native apps:
- Server failures may occur during the `Bundle JavaScript` phase of EAS Build if something was not setup correctly.
- You can manually deploy the server and set the `origin` URL before building the app if you'd like.
- Automatic deployment can be force skipped with the environment variable `EXPO_NO_DEPLOY=1`.
- Automatic deployment does not support [dynamic app config](/workflow/configuration/#dynamic-configuration) (**app.config.js** and **app.config.ts**) files yet.
- Logs from the deployment will be written to `.expo/logs/deploy.log`.
- Deployment will not run in `EXPO_OFFLINE` mode.
### Testing the native production app locally
It can often be useful to test the production build against a local dev server to ensure everything is working as expected. This can speed up the debugging process substantially.
Step 1: 
Export the production server:
```sh
$ npx expo export
```
Step 2: 
Host the production server locally:
```sh
$ npx expo serve
```
Step 3: 
Set the origin in the **app.json**'s `origin` field. Ensure no generated value is in `expo.extra.router.origin`. This should be `http://localhost:8081` (assuming `npx expo serve` is running on the default port).
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-router",
        {
          "origin": "http://localhost:8081"
        }
      ]
    ]
  }
}
```
Remember to remove this `origin` value when deploying to production.
Step 4: 
Build the app in release mode on to a simulator:
```sh
$ EXPO_NO_DEPLOY=1 npx expo run:ios --configuration Release
```
You should now see requests coming in to the local server. Use a tool like [Proxyman](https://proxyman.com/) to inspect network traffic for the simulator and gain better insight.
You can experimentally change the URL and quickly rebuild for iOS using the `--unstable-rebundle` flag. This will swap out the **app.json** and client assets for new ones, skipping the native rebuild.
For example, you can run `eas deploy` to get a new deployment URL, add it to the **app.json**, then run `npx expo run:ios --unstable-rebundle --configuration Release` to quickly rebuild the app with the new URL.
You will want to make a clean build before sending to the store to ensure no transient issues are present.
## Hosting on third-party services
> **important** The `expo-server` library was added in SDK 54. Use `@expo/server` for older SDKs instead.
Every cloud hosting provider needs a custom adapter to support the Expo server runtime. The following third-party providers have unofficial or experimental support from the Expo team.
Before deploying to these providers, it may be good to be familiar with the basics of [`npx expo export`](/more/expo-cli#exporting) command:
- **dist** is the default export directory for Expo CLI.
- Files in **public** directory are copied to **dist** on export.
- The `expo-server` package is a server-side runtime for exported Expo web and API route artifacts.
- `expo-server` does **not** inflate environment variables from **.env** files. They are expected to load either by the hosting provider or the user.
- Metro is not included in the server.
The `expo-server` library contains adapters for various providers and runtimes. Before proceeding with any of the below sections, install the `expo-server` library.
```sh
$ npx expo install expo-server
```
### Bun
Step 1: 
Export the website for production:
```sh
$ bunx expo export -p web
```
Step 2: 
Write a server entry file that serves the static files and delegates requests to the server routes:
```ts server.ts
import { createRequestHandler } from 'expo-server/adapter/bun';
const CLIENT_BUILD_DIR = `${process.cwd()}/dist/client`;
const SERVER_BUILD_DIR = `${process.cwd()}/dist/server`;
const handleRequest = createRequestHandler({ build: SERVER_BUILD_DIR });
const port = process.env.PORT || 3000;
Bun.serve({
  port: process.env.PORT || 3000,
  async fetch(req) {
    const url = new URL(req.url);
    console.log('Request URL:', url.pathname);
    const staticPath = url.pathname === '/' ? '/index.html' : url.pathname;
    const file = Bun.file(CLIENT_BUILD_DIR + staticPath);
    if (await file.exists()) return new Response(await file.arrayBuffer());
    return handleRequest(req);
  },
  websocket,
});
console.log(`Bun server running at http://localhost:${port}`);
```
Step 4: 
Start the server with `bun`:
```sh
$ bun run server.ts
```
### Express
Step 1: 
Install the required dependencies:
```sh
$ npm i -D express compression morgan
```
Step 2: 
Export the website for production:
```sh
$ npx expo export -p web
```
Step 3: 
Write a server entry file that serves the static files and delegates requests to the server routes:
```ts server.ts
#!/usr/bin/env node
const path = require('path');
const { createRequestHandler } = require('expo-server/adapter/express');
const express = require('express');
const compression = require('compression');
const morgan = require('morgan');
const CLIENT_BUILD_DIR = path.join(process.cwd(), 'dist/client');
const SERVER_BUILD_DIR = path.join(process.cwd(), 'dist/server');
const app = express();
app.use(compression());
// http://expressjs.com/en/advanced/best-practice-security.html#at-a-minimum-disable-x-powered-by-header
app.disable('x-powered-by');
process.env.NODE_ENV = 'production';
app.use(
  express.static(CLIENT_BUILD_DIR, {
    maxAge: '1h',
    extensions: ['html'],
  })
);
app.use(morgan('tiny'));
app.all(
  '/{*all}',
  createRequestHandler({
    build: SERVER_BUILD_DIR,
  })
);
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Express server listening on port ${port}`);
});
```
Step 4: 
Start the server with `node` command:
```sh
$ node server.ts
```
### Netlify
> **important** Third-party adapters are subject to breaking changes. We have no continuous tests against them.
Step 1: 
Create a server entry file. All requests will be delegated through this middleware. The exact file location is important.
```ts netlify/functions/server.ts
import path from 'node:path';
import { createRequestHandler } from 'expo-server/adapter/netlify';
export default createRequestHandler({
  build: path.join(__dirname, '../../dist/server'),
});
```
Step 2: 
Create a Netlify configuration file at the root of your project to redirect all requests to the server function.
```yaml netlify.toml
[build]
  command = "expo export -p web"
  functions = "netlify/functions"
  publish = "dist/client"
[[redirects]]
  from = "/*"
  to = "/.netlify/functions/server"
  status = 404
[functions]
  # Include everything to ensure dynamic routes can be used.
  included_files = ["dist/server/**/*"]
[[headers]]
  for = "/dist/server/_expo/functions/*"
  [headers.values]
    # Set to 60 seconds as an example.
    "Cache-Control" = "public, max-age=60, s-maxage=60"
```
Step 3: 
After you have created the configuration files, you can build the website and functions with Expo CLI:
```sh
$ npx expo export -p web
```
Step 4: 
Deploy to Netlify with the [Netlify CLI](https://docs.netlify.com/cli/get-started/).
```sh
$ npm install netlify-cli -g
$ netlify deploy
```
You can now visit your website at the URL provided by Netlify CLI. Running `netlify deploy --prod` will publish to the production URL.
Step 5: 
If you're using any environment variables or **.env** files, add them to Netlify. You can do this by going to the **Site settings** and adding them to the **Build & deploy** section.
### Vercel
> **important** Third-party adapters are subject to breaking changes. We have no continuous tests against them.
Step 1: 
Create a server entry file. All requests will be delegated through this middleware. The exact file location is important.
```ts api/index.ts
const { createRequestHandler } = require('expo-server/adapter/vercel');
module.exports = createRequestHandler({
  build: require('path').join(__dirname, '../dist/server'),
});
```
Step 2: 
Create a Vercel configuration file (**vercel.json**) at the root of your project to redirect all requests to the server function.
For vercel.json v3: 
```json vercel.json
{
  "buildCommand": "expo export -p web",
  "outputDirectory": "dist/client",
  "functions": {
    "api/index.ts": {
      "runtime": "@vercel/node@5.1.8",
      "includeFiles": "dist/server/**"
    }
  },
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/api/index"
    }
  ]
}
```
The newer version of the **vercel.json** does not use `routes` and `builds` configuration options anymore, and serves your public assets from the **dist/client** output directory automatically.
For vercel.json v2: 
```json vercel.json
{
  "version": 2,
  "outputDirectory": "dist",
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist/client"
      }
    },
    {
      "src": "api/index.ts",
      "use": "@vercel/node",
      "config": {
        "includeFiles": ["dist/server/**"]
      }
    }
  ],
  "routes": [
    {
      "handle": "filesystem"
    },
    {
      "src": "/(.*)",
      "dest": "/api/index.ts"
    }
  ]
}
```
The **legacy** version of the **vercel.json** needs a `@vercel/static-build` runtime to serve your assets from the **dist/client** output directory.
Step 3: 
> **Note:** This step only applies to users of the **legacy** version of the **vercel.json**. If you're using v3, you can skip this step.
After you have created the configuration files, add a `vercel-build` script to your **package.json** file and set it to `expo export -p web`.
Step 4: 
Deploy to Vercel with the [Vercel CLI](https://vercel.com/docs/cli).
```sh
$ npm install vercel -g
$ vercel build
$ vercel deploy --prebuilt
```
You can now visit your website at the URL provided by the Vercel CLI.
## Known limitations
Several known features are not currently supported in the API Routes beta release.
### No dynamic imports
API Routes currently work by bundling all code (minus the Node.js built-ins) into a single file. This means that you cannot use any external dependencies that are not bundled with the server. For example, a library such as `sharp`, which includes multiple platform binaries, cannot be used. This will be addressed in a future version.
### ESM not supported
The current bundling implementation opts to be more unified than flexible. This means the limitation of native not supporting ESM is carried over to API Routes. All code will be transpiled down to Common JS (`require`/`module.exports`). However, we recommend you write API Routes using ESM regardless. This will be addressed in a future version.


## Server middleware

Learn how to create middleware that runs for every request to the server in Expo Router.

> **important** Server middleware is in alpha and is available in SDK 54 and later. It requires a [deployed server](/router/web/api-routes/#deployment) for production use.
Server middleware in Expo Router allows you to run code before requests reach your routes, enabling powerful server-side functionality like authentication and logging for every request. Unlike [API routes](/router/web/api-routes) that handle specific endpoints, middleware runs for **every** request in your app, so it should run as quickly as possible to avoid slowing down your app's performance. Client-side navigation such as on native, or in a web app when using [`<Link />`](/versions/latest/sdk/router/#link), will not move through the server middleware.
## Setup
Step 1: 
### Enable server middleware in your app configuration
First, configure your app to use server output by adding the server configuration to your [app config](/versions/latest/config/app/):
```json app.json
{
  "expo": {
    "web": {
      "output": "server"
    },
    "plugins": [
      [
        "expo-router",
        {
          "unstable_useServerMiddleware": true
        }
      ]
    ]
  }
}
```
Step 2: 
### Create your middleware file
Create a **+middleware.ts** file in your **app** directory, to define your server middleware function:
```ts app/+middleware.ts
export default function middleware(request) {
  console.log(`Middleware executed for: ${request.url}`);
  // Your middleware logic goes here
}
```
The middleware function must be the default export of the file. It receives an [immutable request](#request-immutability) and can return either a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response), or nothing to let the request pass through unmodified. The request is immutable to prevent side effects; you can read headers and properties, but you cannot modify headers or consume the request body.
Step 3: 
### Start your development server
Run your development server to test the middleware:
```sh
$ npx expo start
```
Your middleware will now run for all requests to your app.
Step 4: 
### Test middleware functionality
Visit your app in a browser or make requests to test that your middleware is working. Check your console for the log messages from the middleware function.
Step 5: 
### Configure middleware matchers (optional)
By default, middleware runs on all server requests. You can add a matcher to control when your middleware executes with `unstable_settings`:
```ts app/+middleware.ts
export const unstable_settings = {
  matcher: {
    // Only run on GET requests
    methods: ['GET'],
    // Only run on API routes and specific paths
    patterns: ['/api', '/admin/[...path]'],
  },
};
export default function middleware(request) {
  console.log(`Middleware executed for: ${request.url}`);
}
```
The matcher configuration allows you to:
- **Filter by HTTP method**: Specify which methods should trigger the middleware
- **Filter by path patterns**: Define which URL patterns should match using exact paths, named parameters, or regular expressions
## How it works
Middleware functions are executed before any route handlers, allowing you to perform actions like logging, authentication, or modifying responses. It runs exclusively on the server and only for actual HTTP requests.
### Request/response flow
When a request comes to your app, Expo Router processes it in this order:
1. The middleware function runs first with an [immutable request](#request-immutability).
2. If middleware returns a `Response`, that response is sent immediately
3. If middleware returns nothing, the request continues to the matching route
4. The route handler processes the request and returns its response
### Pattern matching
Matchers support different pattern types to control when middleware runs:
```ts
export const unstable_settings = {
  matcher: {
    patterns: [
      '/api', // Exact path
      '/posts/[postId]', // Named parameter
      '/blog/[...slug]', // Catch-all parameter
      /^\/api\/v\d+\/users$/, // Regular expression
    ],
  },
};
```
- **Exact paths** match only the specified path. `/api` matches `/api` but not `/api/users`
- **Named parameters** like `[postId]` capture any single segment. `/posts/[postId]` matches `/posts/123` or `/posts/my-post`
- **Catch-all parameters** like `[...slug]` capture one or more segments. `/blog/[...slug]` matches `/blog/2024` or `/blog/2024/12/post`
- **Regular expressions** for complex patterns. `/^\/api\/v\d+\/users$/` matches `/api/v1/users` but not `/api/users`
Middleware runs if **any** pattern matches the request URL. When both `methods` and `patterns` are specified, both conditions must be met for middleware to run.
### Middleware execution order
Expo Router supports a single middleware file named **+middleware.ts** that runs for all server requests. When using matchers, middleware executes only for requests that match the specified patterns and methods, before any route matching or rendering occurs.
### When middleware runs
Middleware executes only for actual HTTP requests to your server. This means it is executed for:
- Initial page loads, like when a user first visits your site
- Full page refreshes
- Direct URL navigation
- API route calls from any client (native/web apps, external services)
- Server-side rendering requests
Middleware does not run for:
- Client-side navigation using [`<Link />`](/versions/latest/sdk/router/#link) or [`router`](/versions/latest/sdk/router/#router)
- Native app screen transitions
- Prefetched routes
- Static asset requests like images and fonts
## Examples
Note: Authentication
---
Middleware is often used to perform authorization checks before a route has loaded. You can check headers, cookies, or query parameters to determine if a user has access to certain routes:
```ts app/+middleware.ts
import { jwtVerify } from 'jose';
export default function middleware(request) {
  const token = request.headers.get('authorization');
  const decoded = jwtVerify(token, process.env.SECRET_KEY);
  if (!decoded.payload) {
    return new Response('Forbidden', { status: 403 });
  }
}
```
---
Note: Logging
---
You can use middleware to log requests for debugging or analytics purposes. This can help you track user activity or diagnose issues in your app:
```ts app/+middleware.ts
export default function middleware(request) {
  console.log(`${request.method} ${request.url}`);
}
```
---
Note: Dynamic redirects
---
Middleware can also be used to perform dynamic redirects. This allows you to control user navigation based on specific conditions:
```ts app/+middleware.ts
export default function middleware(request) {
  if (request.headers.has('specific-header')) {
    return Response.redirect('https://expo.dev');
  }
}
```
---
Note: API-only middleware
---
Use matchers to run middleware only for API routes, keeping other routes unaffected:
```ts app/+middleware.ts
export const unstable_settings = {
  matcher: {
    patterns: ['/api'],
  },
};
export default function middleware(request) {
  // Log all API requests for debugging
  console.log(`API request: ${request.method} ${request.url}`);
  // Add CORS headers for API routes
  const response = new Response();
  response.headers.set('Access-Control-Allow-Origin', '*');
  return response;
}
```
---
Note: Method-specific authentication
---
Protect write operations (POST, PUT, DELETE) while allowing public read access:
```ts app/+middleware.ts
export const unstable_settings = {
  matcher: {
    methods: ['POST', 'PUT', 'DELETE'],
    patterns: ['/api', '/admin/[...path]'],
  },
};
export default function middleware(request) {
  const token = request.headers.get('authorization');
  if (!token || !isValidToken(token)) {
    return new Response('Unauthorized', { status: 401 });
  }
}
function isValidToken(token: string): boolean {
  // Your token validation logic
  return token.startsWith('Bearer ');
}
```
---
Note: Selective logging
---
Monitor specific endpoints without logging every request:
```ts app/+middleware.ts
export const unstable_settings = {
  matcher: {
    patterns: ['/api/users/[userId]', '/admin', /^\/webhook/],
  },
};
export default function middleware(request) {
  const userAgent = request.headers.get('user-agent');
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${request.method} ${request.url} - ${userAgent}`);
}
```
---
## Additional notes
### Best practices
- Keep middleware lightweight because it runs synchronously on every server request and directly impacts response times.
- Use matchers to optimize performance by avoiding unnecessary middleware execution on routes that don't need it, especially for high-traffic applications.
- Prefer exact paths and named parameters over regex as simple patterns are faster to evaluate and easier to maintain than complex regular expressions.
- Combine method and pattern filtering for precise control over when middleware executes.
- For native apps, use API routes for secure data fetching. When native apps call API routes, those requests will pass through middleware first.
### Typed middleware
```ts app/+middleware.ts
import { MiddlewareFunction } from 'expo-router/server';
const middleware: MiddlewareFunction = request => {
  if (request.headers.has('specific-header')) {
    return Response.redirect('https://expo.dev');
  }
};
export default middleware;
```
### Limitations
- Middleware runs exclusively on the server and only for HTTP requests. It does not execute during client-side navigation, for example, with [`<Link />`](/versions/latest/sdk/router/#link) or native app screen transitions.
- The request object passed to middleware is [immutable](#request-immutability) to prevent side effects. You cannot modify headers or consume the request body, ensuring it remains available for route handlers.
- You can only have one root-level **+middleware.ts** in your app.
- The same limitations that [apply to API routes](/router/web/api-routes/#known-limitations) also apply to middleware.
### Request immutability
To prevent unintended side effects and ensure the request body remains available for route handlers, the [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) passed to middleware is immutable. This means you can:
- Read all request properties like `url`, `method`, `headers`, and so on
- Read header values using `request.headers.get()`
- Check for header existence with `request.headers.has()`
- Access URL parameters and query strings
But you won't be able to:
- Modify headers with `set()`, `append()`, `delete()`
- Consume the request body with `text()`, `json()`, `formData()`, and so on
- Access the `body` property directly


## Static Rendering

Learn how to render routes to static HTML and CSS files with Expo Router.

To enable Search Engine Optimization (SEO) on the web you must statically render your app. This guide will walk you through the process of statically rendering your Expo Router app.
## Setup
Step 1: 
Enable metro bundler and static rendering in the project's [app config](/versions/latest/config/app/):
```json app.json
{
  "expo": {
    "web": {
      "bundler": "metro",
      "output": "static"
    }
  }
}
```
Step 2: 
If you have a **metro.config.js** file in your project, ensure it extends **expo/metro-config** as shown below:
```js metro.config.js
const { getDefaultConfig } = require('expo/metro-config');
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname, {
  // Additional features...
});
module.exports = config;
```
You can also learn more about [customizing Metro](/guides/customizing-metro/) .
Step 3: 
Ensure Fast Refresh is configured. Expo Router requires at least `react-refresh@0.14.0`. Ensure you **do not** have any overrides or resolutions for `react-refresh` in your **package.json**.
Step 4: 
Start the development server:
```sh
$ npx expo start
```
## Production
To bundle your static website for production, run the universal export command:
```sh
$ npx expo export --platform web
```
This will create a **dist** directory with your statically rendered website. If you have files in a local **public** directory, these will be copied over as well.
You can test the production build locally by running the following command and opening the linked URL in your browser:
```sh
$ npx serve dist
```
This project can be deployed to almost every hosting service. Note that this is not a single-page application, nor does it contain a custom server API. This means dynamic routes (**app/[id].tsx**) will not arbitrarily work. You may need to build a serverless function to handle dynamic routes.
## Dynamic Routes
The `static` output will generate HTML files for each route. This means dynamic routes (**app/[id].tsx**) will not work out of the box. You can generate known routes ahead of time using the `generateStaticParams` function.
```tsx app/blog/[id].tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export async function generateStaticParams(): Promise<Record<string, string>[]> {
  const posts = await getPosts();
  // Return an array of params to generate static HTML files for.
  // Each entry in the array will be a new page.
  return posts.map(post => ({ id: post.id }));
}
export default function Page() {
  const { id } = useLocalSearchParams();
  return <Text>Post {id}</Text>;
}
```
This will output a file for each post in the **dist** directory. For example, if the `generateStaticParams` method returned `[{ id: "alpha" }, { id: "beta" }]`, the following files would be generated:
```
└── dist/
    └── blog/
        ├── alpha.html
        └── beta.html
```
#### generateStaticParams
A server-only function evaluated at build-time in a Node.js environment by Expo CLI. This means it has access to `__dirname`, `process.cwd()`, `process.env`, and more. It also has access to every environment variable that's available in the process. However, the values prefixed with `EXPO_PUBLIC_.generateStaticParams` do not run in a browser environment, so it cannot access browser APIs such as `localStorage` or `document`. It also cannot access native Expo APIs such as `expo-camera` or `expo-location`.
```tsx app/[id].tsx
export async function generateStaticParams(): Promise<Record<string, string>[]> {
  console.log(process.cwd());
  return [];
}
```
`generateStaticParams` cascades from nested parents down to children. The cascading parameters are passed to every dynamic child route that exports **generateStaticParams**.
```tsx app/[id]/_layout.tsx
export async function generateStaticParams(): Promise<Record<string, string>[]> {
  return [{ id: 'one' }, { id: 'two' }];
}
```
Now the dynamic child routes will be invoked twice, once with `{ id: 'one' }` and once with `{ id: 'two' }`. All variations must be accounted for.
```tsx app/[id]/[comment].tsx
export async function generateStaticParams(params: {
  id: 'one' | 'two';
}): Promise<Record<string, string>[]> {
  const comments = await getComments(params.id);
  return comments.map(comment => ({
    ...params,
    comment: comment.id,
  }));
}
```
### Read files using `process.cwd()`
Since Expo Router compiles your code into a separate directory you cannot use `__dirname` to form a path as its value will be different than expected.
Instead, use `process.cwd()`, which gives you the directory where the project is being compiled.
```tsx app/[category].tsx
import fs from 'fs/promises';
import path from 'path';
export async function generateStaticParams(params: {
  id: string;
}): Promise<Record<string, string>[]> {
  const directory = await fs.readdir(path.join(process.cwd(), './posts/', category));
  const posts = directory.filter(fileOrSubDirectory => return path.extname(fileOrSubDirectory) === '.md')
  return {
    id,
    posts,
  };
}
```
## Root HTML
By default, every page is wrapped with some small HTML boilerplate, this is known as the **root HTML**.
You can customize the root HTML file by creating an **app/+html.tsx** file in your project. This file exports a React component that only ever runs in Node.js, which means global CSS cannot be imported inside of it. The component will wrap all routes in the **app** directory. This is useful for adding global `<head>` elements or disabling body scrolling.
> **Note**: Global context providers should go in the [Root Layout](/router/basics/layout/#root-layout) component, not the Root HTML component.
```tsx app/+html.tsx
import { ScrollViewStyleReset } from 'expo-router/html';
import { type PropsWithChildren } from 'react';
// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
```
- The `children` prop comes with the root `<div id="root" />` tag included inside.
- The JavaScript scripts are appended after the static render.
- React Native web styles are statically injected automatically.
- Global CSS should not be imported into this file. Instead, use the [Root Layout](/router/basics/layout/#root-layout) component.
- Browser APIs like `window.location` are unavailable in this component as it only runs in Node.js during static rendering.
### `expo-router/html`
The exports from `expo-router/html` are related to the Root HTML component.
- `ScrollViewStyleReset`: Root style-reset for full-screen [React Native web apps](https://necolas.github.io/react-native-web/docs/setup/#root-element) with a root `<ScrollView />` should use the following styles to ensure native parity.
## Meta tags
You can add meta tags to your pages with the `<Head />` module from `expo-router`:
```tsx app/about.tsx
import Head from 'expo-router/head';
import { Text } from 'react-native';
export default function Page() {
  return (
    <>
      <Head>
        <title>My Blog Website</title>
        <meta name="description" content="This is my blog." />
      </Head>
      <Text>About my blog</Text>
    </>
  );
}
```
The head elements can be updated dynamically using the same API. However, it's useful for SEO to have static head elements rendered ahead of time.
## Static files
Expo CLI supports a root **public** directory that gets copied to the **dist** directory during static rendering. This is useful for adding static files like images, fonts, and other assets.
```
└── public/
    ├── favicon.ico
    ├── logo.png
    └── .well-known/
        └── apple-app-site-association
```
These files will be copied to the **dist** directory during static rendering:
```
└── dist/
    ├── index.html
    ├── favicon.ico
    ├── logo.png
    ├── .well-known/
    │   └── apple-app-site-association
    └── _expo/
        └── static/
            ├── js/
            │   └── index-xxx.js
            └── css/
                └── index-xxx.css
```
> **info** **Web only**: Static assets can be accessed in runtime code using relative paths. For example, the **logo.png** can be accessed at `/logo.png`:
```tsx app/index.tsx
import { Image } from 'react-native';
export default function Page() {
  return <Image source={{ uri: '/logo.png' }} />;
}
```
## Fonts
Expo Font has automatic static optimization for font loading in Expo Router. When you load a font with `expo-font`, Expo CLI will automatically extract the font resource and embed it in the page's HTML, enabling preloading, faster hydration, and reduced layout shift.
The following snippet will load Inter into the namespace and statically optimize on web:
```tsx app/home.tsx
import { Text } from 'react-native';
import { useFonts } from 'expo-font';
export default function App() {
  const [isLoaded] = useFonts({
    inter: require('@/assets/inter.ttf'),
  });
  if (!isLoaded) {
    return null;
  }
  return <Text style={{ fontFamily: 'inter' }}>Hello Universe</Text>;
}
```
This generates the following static HTML:
```html dist/home.html
<link rel="preload" href="/assets/inter.ttf" as="font" crossorigin />
<style id="expo-generated-fonts" type="text/css">
  @font-face {
    font-family: inter;
    src: url(/assets/inter.ttf);
    font-display: auto;
  }
</style>
```
- Static font optimization requires the font to be loaded synchronously. If the font isn't statically optimized, it could be because it was loaded inside a `useEffect`, deferred component, or async function.
- Static optimization is only supported with `Font.loadAsync` and `Font.useFonts` from `expo-font`. Wrapper functions are supported as long as the wrappers are synchronous.
## Common questions
### How do I add a custom server?
There is no prescriptive way to add a custom server. You can use any server you want. However, you will need to handle dynamic routes yourself. You can use the `generateStaticParams` function to generate static HTML files for known routes.
In the future, there will be a server API, and a new `web.output` mode which will generate a project that will (among other things) support dynamic routes.
## Server-side Rendering
Rendering at request-time (SSR) is not supported in `web.output: 'static'`. This will likely be added in a future version of Expo Router.
### Where can I deploy statically rendered websites?
You can deploy your statically rendered website to any static hosting service. Here are some popular options:
- [EAS Hosting](/eas/hosting/introduction/)
- [Netlify](https://www.netlify.com/)
- [Cloudflare Pages](https://pages.cloudflare.com/)
- [AWS Amplify](https://aws.amazon.com/amplify/)
- [Vercel](https://vercel.com/)
- [GitHub Pages](https://pages.github.com/)
- [Render](https://render.com/)
- [Surge](https://surge.sh/)
> **Note:** You don't need to add Single-Page Application styled redirects to your static hosting service. The static website is not a single-page application. It is a collection of static HTML files.


## Async routes

Learn how to speed up development with async bundling in Expo Router.

> **important** Async routes is in alpha.
<ContentSpotlight file="expo-router/async-routes.mp4" loop={false} />
Expo Router can automatically split your JavaScript bundle based on the route files using [React Suspense](https://react.dev/reference/react/Suspense). This enables faster development as only the routes you navigate to will be bundled or loaded into memory. This can also be useful for reducing the initial bundle size for your application.
Apps using the Hermes Engine will not benefit as much from bundle splitting as the bytecode is already memory mapped ahead of time. However, it will improve your over-the-air updates, React Server Components, and web support.
> When bundling for production **on native platforms**, all suspense boundaries **will be disabled** and there will be no loading states.
## How it works
All Routes are wrapped inside a suspense boundary and are loaded asynchronously. This means that the first time you navigate to a route, it will take a little longer to load. However, once it is loaded, it will be cached and subsequent visits will be instant.
{/* The [Suspense fallback](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading) or loading state **cannot be customized** at this time. We plan to add support in the future via a **route+loading.js** file. */}
Loading errors are handled in the parent route, via the [`ErrorBoundary`](/router/error-handling/#errorboundary) export.
Async routes cannot be statically analyzed during development, so all files will be treated as routes even if they don't export a default component. After the component is bundled and loaded, any invalid route will use a fallback warning screen.
For those familiar with advanced bundling techniques, the async routes feature is composed of [React Suspense](https://react.dev/reference/react/Suspense), [route-based bundle splitting](https://legacy.reactjs.org/docs/code-splitting.html#route-based-code-splitting) and [lazy bundling](https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0605-lazy-bundling.md) (in development).
## Setup
Enable the feature by setting the `asyncRoutes` option in the Expo Router config plugin of your [app config](/versions/latest/config/app/):
    > Set `asyncRoutes` to `true` to enable production bundle splitting.
    ```json app.json
    {
      "expo": {
        "plugins": [
          [
            "expo-router",
            {
              "origin": "https://acme.com",
              "asyncRoutes": {
                "web": true,
                "default": "development"
              }
            }
          ]
        ]
      }
    }
    ```
You can set platform-specific settings (`default`, `android`, `ios` or `web`) for `asyncRoutes` using an object:
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-router",
        {
          "origin": "https://acme.com",
          "asyncRoutes": {
            "web": true,
            "android": false,
            "default": "development"
          }
        }
      ]
    ]
  }
}
```
Then, when you are about to start your project, you can use the `--clear` flag to clear the Metro cache. This will ensure that the routes are loaded asynchronously:
```sh
$ npx expo start --clear
$ npx expo export --clear
```
## Static rendering
Static rendering is supported in production web apps by rendering all Suspense boundaries synchronously in Node.js, then linking all of async chunks together in the HTML based on all the selected routes for a given HTML file. This ensures you don't encounter a waterfall of loading states on server navigations. Subsequent navigations will recursively load any missing chunks.
To ensure a consistent first render, all layout routes leading up to the leaf route for a URL will be included in the initial server response.
All initial routes, defined with `unstable_settings = { initialRouteName: '...' }` will be included in the initial HTML file as they are required for the first render. For example, if the server request is for a modal, the screen rendered under the modal will also be included to ensure the modal is rendered correctly.
## Caveats
Async Routes represents an early preview of how we plan to support [React Server Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) in the future. As such, there are some caveats to be aware of:
- Async Routes do not support native production apps yet.
- In development, the runtime JavaScript is lazily bundled so you may encounter cases where the HTML doesn't match the available JavaScript.
- The loading state cannot be customized at this time.


# Reference

## Error handling

Learn how to handle unmatched routes and errors in your app when using Expo Router.

This guide specifies how to handle unmatched routes and errors in your app when using Expo Router.
## Unmatched routes
Native apps don't have a server so there are technically no 404s. However, if you're implementing a router universally, then it makes sense to handle missing routes. This is done automatically for each app, but you can also customize it.
```tsx app/+not-found.tsx
import { Unmatched } from 'expo-router';
export default Unmatched;
```
This will render the default `Unmatched`. You can export any component you want to render instead. We recommend having a link to `/` so users can navigate back to the home screen.
### Route priority
On web, files are served in the following order:
1. Static files in the **public** directory.
2. Standard and dynamic routes in the app directory.
3. [API routes](/router/web/api-routes) in the app directory.
4. Not-found routes will be served last with a 404 status code.
## Error handling
Expo Router enables fine-tuned error handling to enable a more opinionated data-loading strategy in the future.
You can export a nested [`ErrorBoundary`](/versions/latest/sdk/router/#errorboundary) component from any route to intercept and format component-level errors using [React Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary):
```tsx app/home.tsx
import { View, Text } from 'react-native';
import { type ErrorBoundaryProps } from 'expo-router';
export function ErrorBoundary({ error, retry }: ErrorBoundaryProps) {
  return (
    <View style={{ flex: 1, backgroundColor: "red" }}>
      <Text>{error.message}</Text>
      <Text onPress={retry}>Try Again?</Text>
    </View>
  );
}
export default function Page() { ... }
```
When you export an `ErrorBoundary` the route will be wrapped with a React Error Boundary effectively:
```tsx Virtual
function Route({ ErrorBoundary, Component }) {
  return (
    <Try catch={ErrorBoundary}>
      <Component />
    </Try>
  );
}
```
When `ErrorBoundary` is not present, the error will be thrown to the nearest parent's `ErrorBoundary` and accepts [`error`](/versions/latest/sdk/router/#error) and [`retry`](/versions/latest/sdk/router/#retry) props.
### Work in progress
React Native LogBox needs to be presented less aggressively to develop with errors. Currently, it shows for `console.error` and `console.warn`. However, it should ideally only show for uncaught errors.


## Using URL parameters

Learn how to access and modify route and search parameters in your app.

URL parameters include both **route parameters** and **search parameters**. Expo Router provides hooks for accessing and modifying these parameters.
## Difference between route and search parameters
Route parameters are dynamic segments defined in a URL path, such as `/profile/[user]`, where `user` is a route parameter. They are used to match a route.
Search parameters (also known as query params) are serializable fields that can be appended to a URL, such as `/profile?extra=info`, where `extra` is a search parameter. They are commonly used to pass data between pages.
## Local versus global URL parameters
In nested apps, you'll often have **multiple pages mounted** at the same time. For example, a stack has the previous page and current page in memory when a new route is pushed. Because of this, Expo Router provides two different hooks for accessing URL parameters:
- **useLocalSearchParams**: Returns the URL parameters for the current component. It only updates when the global URL conforms to the route.
- **useGlobalSearchParams**: Returns the global URL regardless of the component. It updates on every URL param change and might cause components to update extraneously in the background.
The hooks `useGlobalSearchParams` and `useLocalSearchParams` allow you to access these parameters within your components, enabling you to retrieve and utilize both types of URL parameters.
Both hooks are typed and accessed the same way. However, the only difference is how frequently they update.
The example below demonstrates the difference between `useLocalSearchParams` and `useGlobalSearchParams`. It uses the following **app** directory structure:
```
└── app/
    ├── _layout.tsx
    ├── index.tsx
    └── [user].tsx
```
Step 1: 
    The Root Layout is a stack navigator:
    ```tsx app/_layout.tsx
    import { Stack } from 'expo-router';
    export default function Layout() {
      return <Stack />;
    }
    ```
Step 2: 
    The initial route redirects to the dynamic route **app/[user].tsx**, with **user=evanbacon**:
    ```tsx app/index.tsx
    import { Redirect } from 'expo-router';
    export default function Route() {
      return <Redirect href="/evanbacon" />;
    }
    ```
Step 3: 
    The dynamic route **app/[user]** prints out the global and local URL parameters (route parameters, in this case). It also allows for pushing new instances of the same route with different **route parameters**:
    ```tsx app/[user].tsx
    import { Text, View } from 'react-native';
    import { useLocalSearchParams, useGlobalSearchParams, Link } from 'expo-router';
    const friends = ['charlie', 'james']
    export default function Route() {
      const glob = useGlobalSearchParams();
      const local = useLocalSearchParams();
      console.log("Local:", local.user, "Global:", glob.user);
      return (
        <View>
          <Text>User: {local.user}</Text>
          {friends.map(friend => (
            <Link key={friend} href={`/${friend}`}>
              Visit {friend}
            </Link>
          ))}
        </View>
      );
    }
    ```
Step 4: 
When the app starts, the following log is printed:
```sh
Local: evanbacon Global: evanbacon
```
Pressing "Visit charlie" pushes a new instance of `/[user]` with **user=charlie**, and logs the following:
```sh
Local: charlie Global: charlie
Local: evanbacon Global: charlie
```
Pressing "Visit james" has a similar effect:
```sh
/james" screen
Local: james Global: james
Local: evanbacon Global: james
Local: charlie Global: james
```
    **Results:**
    - `useGlobalSearchParams` made the background screens re-render when the URL **route parameters** changed. It can cause performance issues if overused.
    - Global re-renders are executed in order of the stack, so the first screen is re-rendered first, then the **user=charlie** screen is re-rendered after.
    - `useLocalSearchParams` remained the same, even when the global URL **route parameters** changed. You can leverage this behavior for data fetching to ensure the previous screen's data is still available when you navigate back.
## Statically-typed URL parameters
Both the `useLocalSearchParams` and `useGlobalSearchParams` can be statically typed using a generic. The following is an example for the `user` route parameter:
```tsx app/[user].tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Route() {
  const { user } = useLocalSearchParams<{ user: string }>();
  return <Text>User: {user}</Text>;
}
// Given the URL: `/evanbacon`
// The following is returned: { user: "evanbacon" }
```
Any search parameters (for example, `?query=...`) can be typed optionally:
```tsx app/[user].tsx
const { user, query } = useLocalSearchParams<{ user: string; query?: string }>();
// Given the URL: `/evanbacon?query=hello`
// The following is returned: { user: "evanbacon", query: "hello" }
```
When used with the rest syntax (`...`), route parameters are returned as a string array:
```tsx app/[...everything].tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Route() {
  const { everything } = useLocalSearchParams<{
    everything: string[];
  }>();
  const user = everything[0];
  return <Text>User: {user}</Text>;
}
// Given the URL: `/evanbacon/123`
// The following is returned: { everything: ["evanbacon", "123"] }
```
Any search parameters will continue to be returned as individual strings:
```tsx app/[...everything].tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Route() {
  const { everything } = useLocalSearchParams<{
    everything: string[];
    query?: string;
    query2?: string;
  }>();
  const user = everything[0];
  return <Text>User: {user}</Text>;
}
// Given the URL: `/evanbacon/123?query=hello&query2=world`
// The following is returned: { everything: ["evanbacon", "123"], query: "hello", query2: "world" }
```
## Updating URL parameters
URL parameters can be updated using the **router.setParams** function from the imperative API. Updating a URL parameter will not push anything new to the history stack.
The following example uses a `<TextInput>` to update the search parameter **q**:
```tsx app/search.tsx
import { useLocalSearchParams, router } from 'expo-router';
import { useState } from 'react';
import { TextInput, View } from 'react-native';
export default function Page() {
  const params = useLocalSearchParams<{ query?: string }>();
  const [search, setSearch] = useState(params.query);
  return (
    <TextInput
      value={search}
      onChangeText={search => {
        setSearch(search);
        router.setParams({ query: search });
      }}
      placeholderTextColor="#A0A0A0"
      placeholder="Search"
      style={{
        borderRadius: 12,
        backgroundColor: '#fff',
        fontSize: 24,
        color: '#000',
        margin: 12,
        padding: 16,
      }}
    />
  );
}
```
Here is an example using an `onPress` event to update the route parameter **user**:
```tsx app/[user].tsx
import { useLocalSearchParams, router } from 'expo-router';
import { Text } from 'react-native';
export default function User() {
  const params = useLocalSearchParams<{ user: string }>();
  return (
    <>
      <Text>User: {params.user}</Text>
      <Text onPress={() => router.setParams({ user: 'evan' })}>Go to Evan</Text>
    </>
  );
}
```
## Route parameters versus search parameters
Route parameters are used to match a route, while search parameters are used to pass data between routes. Consider the following structure, where a route parameter is used to match the _user_ route:
```
└── app/
    ├── index.tsx
    └── [user].tsx  # "user" is a "route parameter"
```
When the `app/[user]` route is matched, the `user` parameter is passed to the component and never a nullish value. Both search and route parameters can be used together and are accessible with the `useLocalSearchParams` and `useGlobalSearchParams` hooks:
```tsx app/[user].tsx
import { useLocalSearchParams } from 'expo-router';
export default function User() {
  const {
    // The route parameter
    user,
    // An optional search parameter.
    tab,
  } = useLocalSearchParams<{ user: string; tab?: string }>();
  console.log({ user, tab });
  // Given the URL: `/bacon?tab=projects`, the following is printed:
  // { user: 'bacon', tab: 'projects' }
  // Given the URL: `/expo`, the following is printed:
  // { user: 'expo', tab: undefined }
}
```
Whenever a route parameter is changed, the component will re-mount.
```tsx app/[user].tsx
import { Text } from 'react-native';
import { router, useLocalSearchParams, Link } from 'expo-router';
export default function User() {
  // All three of these will change the route parameter `user`, and add a new user page.
  return (
    <>
      <Text onPress={() => router.setParams({ user: 'evan' })}>Go to Evan</Text>
      <Text onPress={() => router.push('/mark')}>Go to Mark</Text>
      <Link href="/charlie">Go to Charlie</Link>
    </>
  );
}
```
{/*
TODO: REMOVE COMMENT WHEN https://github.com/expo/expo/pull/30268 IS PUBLISHED
## Array support
URL parameters that are present multiple times will be grouped together as an array.
```tsx app/hash.tsx
import { router, useLocalSearchParams } from 'expo-router';
export default function Route() {
  // If the current URL is `/route?myParam=1&myParam=2
  const { myParam } = useLocalSearchParams();
  // myParam === ["1", "2"]
}
```
\*/}
## Hash support
The URL [hash](https://developer.mozilla.org/en-US/docs/Web/API/URL/hash) is a string that follows the `#` symbol in a URL. It is commonly used on websites to link to a specific section of a page, but it can also be used to store data. Expo Router treats the hash as a special search parameter using the name `#`. It can be accessed and modified using the same hooks and APIs from [search parameters](#local-versus-global-search-parameters).
```tsx app/hash.tsx
import { Text } from 'react-native';
import { router, useLocalSearchParams, Link } from 'expo-router';
export default function User() {
  // Access the hash
  const { '#': hash } = useLocalSearchParams<{ '#': string }>();
  return (
    <>
      <Text onPress={() => router.setParams({ '#': 'my-hash' })}>Set a new hash</Text>
      <Text onPress={() => router.push('/#my-hash')}>Push with a new hash</Text>
      <Link href="/#my-hash">Link with a hash</Link>
    </>
  );
}
```
## Reserved parameters
Certain URL parameters are reserved for internal use by Expo Router and React Navigation. Avoid using the following names for your own parameters to prevent conflicts:
- `screen`
- `params`
- `initial`
- `state`


## Sitemap

Learn how to use the sitemap to debug your app with Expo Router.

On native, you can use the [`uri-scheme`](https://www.npmjs.com/package/uri-scheme) CLI to test opening native links on a device.
For example, if you want to launch the Expo Go app on iOS to the `/form-sheet` route, run:
```sh
$ npx uri-scheme open exp://192.168.87.39:19000/--/form-sheet --ios
```
> Replace `192.168.87.39:19000` with the IP address shown when running `npx expo start`.
You can also search for links directly in a browser like Safari or Chrome to test deep linking on physical devices. Learn more about [testing deep links](https://reactnavigation.org/docs/deep-linking).
## Sitemap
Expo Router currently injects a **/\_sitemap** automatically that provides a list of all routes in the app. This is useful for debugging.
The sitemap can be removed by adding `sitemap: false` to the `expo-router` config plugin in the app config:
```json app.json
{
  "plugins": [
    [
      "expo-router",
      {
        "sitemap": false
      }
    ]
  ]
}
```


## Redirects

Learn how to redirect URLs in Expo Router.

You can redirect a request to a different URL based on some in-app criteria. Expo Router supports a number of different redirection patterns.
## Using `Redirect` component
You can immediately redirect from a particular screen by using the `Redirect` component:
```tsx
import { View, Text } from 'react-native';
import { Redirect } from 'expo-router';
export default function Page() {
  const { user } = useAuth();
  if (!user) {
    return <Redirect href="/login" />;
  }
  return (
    <View>
      <Text>Welcome Back!</Text>
    </View>
  );
}
```
## Using `useRouter` hook
You can also redirect imperatively with the `useRouter` hook:
```tsx
import { Text } from 'react-native';
import { useRouter, useFocusEffect } from 'expo-router';
function MyScreen() {
  const router = useRouter();
  useFocusEffect(() => {
    // Call the replace method to redirect to a new route without adding to the history.
    // We do this in a useFocusEffect to ensure the redirect happens every time the screen
    // is focused.
    router.replace('/profile/settings');
  });
  return <Text>My Screen</Text>;
}
```


## Link preview

Learn how to add a preview to your link on iOS when using Expo Router.

> **important** Link preview is an iOS-only feature available in SDK 54 and later.
Link preview (also known as "Peek and Pop") is a feature commonly used on iOS to show users a preview popup of the screen for a link.
This guide will show you how to add and customize a link preview for your app on iOS.
If you have a link in your app, you can add a link preview to it by replacing the link's content with a [`Link.Trigger`](/versions/latest/sdk/router/#linktrigger) and adding the [`Link.Preview`](/versions/latest/sdk/router/#linkpreview) component to it. This will create a preview of the page that the link points to.
```tsx
import { Link } from 'expo-router';
export default function Page() {
  return (
    <Link href="/about">
      <Link.Trigger>About</Link.Trigger>
      <Link.Preview />
    </Link>
  );
}
```
## Customizing the link preview
By default, the link preview is rendered as a full-sized page snapshot. There are several ways to customize this behavior.
### Custom size
You can use `width` and `height` to suggest a preferred preview size. The system will consider these preferences but may override them based on available space or platform behavior.
```tsx
<Link href="...">
  <Link.Trigger>Content</Link.Trigger>
  <Link.Preview style={{ width: 300, height: 200 }} />
</Link>
```
The following example shows a custom link preview size on iOS:
### Custom preview
If you don't want to show the default preview, you can pass custom content to the `Link.Preview` component via children. This custom content will replace the default preview of the link target.
```tsx
export default function Page() {
  const [imageSize, setImageSize] = useState({ width: 0, height: 0 });
  const { width } = useWindowDimensions();
  const previewHeight = (width / imageSize.width) * imageSize.height;
  return (
    <Link href="/about">
      <Link.Trigger>About</Link.Trigger>
      <Link.Trigger>Content</Link.Trigger>
      <Link.Preview style={{ width, height: previewHeight }}>
        <Image
          onLoad={e => setImageSize(e.nativeEvent.source)}
          source={source}
          style={{ width: '100%', height: '100%' }}
        />
      </Link.Preview>
    </Link>
  );
}
```
The following example shows a custom link preview on iOS:
## Menu
To render a context menu next to the preview, add a [`Link.Menu`](/versions/latest/sdk/router/#linkmenu) with [`Link.MenuAction`](/versions/latest/sdk/router/#linkmenuaction) children.
```tsx
<Link href="/about">
  <Link.Trigger>About</Link.Trigger>
  <Link.Menu>
    <Link.MenuAction title="Share" icon="square.and.arrow.up" onPress={handleSharePress} />
    <Link.MenuAction title="Block" icon="nosign" destructive onPress={handleBlockPress} />
  </Link.Menu>
</Link>
```
The following example shows a custom link preview on iOS:
### Icons
You can specify an icon for each menu action using [SF Symbols](https://developer.apple.com/sf-symbols/).
```tsx
<Link href="/about">
  <Link.Trigger>About</Link.Trigger>
  <Link.Menu>
    <Link.MenuAction title="Share" icon="square.and.arrow.up" onPress={handleSharePress} />
    <Link.MenuAction title="Block" icon="nosign" onPress={handleBlockPress} />
    <Link.MenuAction
      title="Follow"
      icon="person.crop.circle.badge.plus"
      onPress={handleFollowPress}
    />
    <Link.MenuAction title="Copy" icon="doc.on.doc" onPress={handleCopyPress} />
  </Link.Menu>
</Link>
```
The following example shows a context menu with four elements, each using a different icon on iOS:
### Nested menus
You can nest menus by placing a [`Link.Menu`](/versions/latest/sdk/router/#linkmenu) inside another menu:
```jsx
<Link href="...">
  <Link.Trigger>About</Link.Trigger>
  <Link.Menu>
    <Link.MenuAction title="Share" icon="square.and.arrow.up" onPress={() => {}} />
    <Link.Menu title="More" icon="ellipsis">
      <Link.MenuAction title="Copy" icon="doc.on.doc" onPress={() => {}} />
      <Link.MenuAction title="Delete" icon="trash" destructive onPress={() => {}} />
    </Link.Menu>
  </Link.Menu>
</Link>
```
The following example shows a nested context menu on iOS:
### More customization options
To explore all available customization options, see the API documentation for [`Link.MenuAction`](/versions/latest/sdk/router/#linkmenuaction).
## Detecting if component is in preview
If you're building a component that might be rendered inside a preview, you can use the [`useIsPreview()`](/versions/latest/sdk/router/#useispreview) hook to adjust its behavior accordingly:
```jsx
function MyComponent() {
  // This will be true if component/screen is being rendered inside a preview
  const isInsidePreview = useIsPreview();
  return isInsidePreview ? <Text>From within preview</Text> : <Text>I am outside of preview</Text>;
}
```
## Known limitations
### `replace` not supported
Using link previews with [`replace`](/versions/latest/sdk/router/#replace) mode is currently **not supported**. Previews can only be used with the default [`push`](/versions/latest/sdk/router/#push) navigation mode.
### JavaScript tabs and slots
When navigating within JavaScript tabs (rather than native tabs) or [`Slot`](/versions/latest/sdk/router/#slot), preview transition animations may appear clunky. This is due to React's delayed rendering while the native preview animation begins immediately. To prevent this issues use, native tabs and stack navigators.
### Missing `Link.Trigger`
If you render a `Link` with a preview or context menu, but without a `Link.Trigger`, an exception will be thrown. The same applies if you place any non-`Link.*` component directly inside `Link` when using preview mode.
### Multiple `Link.Trigger` children with `asChild` prop
When using `Link` with `asChild`, you may only specify **one** child for `Link.Trigger`. The `onPress` event will be forwarded to that child only.
### Changing href while preview is open
Changing `href` prop's path dynamically while the preview is open is **not supported**. You may only modify the query parameters dynamically.


## Typed routes

Learn how to use statically typed links and routes in Expo Router.

> Available when using TypeScript in your project. Expo Router supports standard TypeScript out of the box. See the [TypeScript](/guides/typescript/) guide for more information on how to set it up.
Expo Router supports generating TypeScript types automatically with Expo CLI. This enables `<Link>`, and the [hooks API](/router/reference/hooks) to be statically typed. This feature is currently in beta and is not enabled by default.
## Get started
### Quick start
If you created your project using the [Expo Router quick start guide](/router/installation/#quick-start) then your project is already configured to use typed routes. The Expo CLI will generate the required type file the first time you run `npx expo start`. Then, you can use autocomplete for `href` props whenever you use an Expo Router `<Link>` component in a **.tsx** file.
### Manual configuration
While the feature is in beta, you can enable it by setting `experiments.typedRoutes` to `true` in your **app.json**:
```json app.json
{
  "expo": {
    "experiments": {
      "typedRoutes": true
    }
  }
}
```
Run `npx expo customize tsconfig.json` to configure your **tsconfig.json** to add the required `includes` fields.
Then, start the development server by running `npx expo start`. You can now use autocomplete in the Expo Router `<Link>` component's `href` prop.
## Type generation
Typed routes in Expo Router are automatically generated when the development server starts. By default, these generated types are configured to be untracked by Git and will be added to the local **.gitignore** file. This ensures that autogenerated files do not clutter your version control system.
If you find yourself in a situation where you need to generate these types without initiating the development server, such as during type checking on a Continuous Integration (CI) server. To do this, run the command `npx expo customize tsconfig.json` on the CI.
## Statically typed routes
Components and functions that use `Href<T>` will now be statically typed and have a much stricter definition. For example:
```tsx
✅ <Link href="/about" />
✅ <Link href="/user/1" />
✅ <Link href={`/user/${id}`} />
✅ <Link href={("/user" + id) as Href} />
// TypeScript errors if href is not a valid route
❌ <Link href="/usser/1" />
```
> **Note**: A [`Route` type](/versions/latest/sdk/router/#route) is also made available by `expo-router`, which matches all valid routes in a project automatically.
For dynamic routes, Href's need to be objects and their parameters are strictly typed:
```tsx
✅ <Link href={{ pathname: "/user/[id]", params: { id: 1 }}} />
// TypeScript errors as href is valid, but it should be a HrefObject with params
❌ <Link href="/user/[id]" />
// TypeScript errors as params contain invalid keys
❌ <Link href={{ pathname: "/user/[id]", params: { _id: 1 }}} />
// TypeScript errors as params contain unknown keys
❌ <Link href={{ pathname: "/user/[id]", params: { id: 1, id2: 2 }}} />
```
### Relative paths
Statically typed routes do not support relative paths. You'll need to use absolute paths for all routes:
```tsx
✅ <Link href="/about" />
// Relative paths are not supported
❌ <Link href="./about" />
```
You can leverage the `useSegments()` hooks from `expo-router` to create complex relative paths. Consider the following structure:
```
├── app/
│   ├── (feed)/
│   │   ├── _layout.tsx
│   │   ├── feed.tsx
│   │   ├── search.tsx
│   │   └── profile.tsx
│   └── (search)/
│       └── profile.tsx
└── components/
    └── button.tsx
```
You can ensure that you push to the same tab by using the `useSegments()` hook to get the first segment of the current route.
```tsx button.tsx
import { Link, useSegments } from 'expo-router';
export function Button() {
  const [
    // This will be either `(feed)` or `(search)` depending on the current tab.
    first,
  ] = useSegments();
  return <Link href={`/${first}/profile`}>Push profile</Link>;
}
```
Now, you can leverage `<Button />` from both **app/(feed)/feed.tsx** and **app/(search)/search.tsx** to push `./profile` while preserving the current tab.
If you require the segments for a specific use, you can pass the full route to `useSegments`:
```tsx button.tsx
import { Link, useSegments } from 'expo-router';
export function useMySegments() {
  const segments = useSegments<'/(search)/profile'>();
  //    ^? segments = ['(search)', 'profile']
  return segments;
}
```
## Imperative navigation
You can use the typed `router` object to navigate imperatively:
```tsx
import { router } from 'expo-router';
router.push('/about');
```
Or with the typed `useRouter()` hook:
```tsx
import { useRouter } from 'expo-router';
function Page() {
  const router = useRouter();
  router.push('/about');
  // ...
}
```
## Route parameters
For strongly typed route parameters, you can pass a full href to the `useLocalSearchParams` and `useGlobalSearchParams` hooks. For example:
```tsx app/search.tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Page() {
  const {
    profile, // string
    search, // string[]
  } = useLocalSearchParams<'/(search)/[profile]/[...search]'>();
  return (
    <>
      <Text>Profile: {profile}</Text>
      <Text>Search: {search.join(',')}</Text>
    </>
  );
}
```
## Query parameters
Most query parameters will not be represented in the file system and therefore cannot be typed automatically. You can type query parameters manually by passing a generic to the `useLocalSearchParams` and `useGlobalSearchParams` hooks. For example:
```tsx app/search.tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Page() {
  const { query } = useLocalSearchParams<{ query?: string }>();
  return <Text>Search: {query ?? 'unset'}</Text>;
}
```
If you need a combination of route and query parameters, pass the route as the first generic and then the query parameters:
```tsx app/search.tsx
import { Text } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
export default function Page() {
  const { query, profile, search } = useLocalSearchParams<
    '/[profile]/[...search]',
    { query?: string }
  >();
  return <Text>Search: {query ?? 'unset'}</Text>;
}
```
## Changes made to the environment
When typed routes is enabled, Expo CLI will generate a git ignored **expo-env.d.ts** file in your project's root directory, update the **.gitignore** to ignore the new root **expo-env.d.ts** file, and modify the **tsconfig.json** to include the new **expo-env.d.ts** file.
The `includes` field in your **tsconfig.json** gets updated to include **expo-env.d.ts** and a hidden **.expo** directory. These entries are required and should not be removed from the file.
The generated **expo-env.d.ts** should not be removed or changed at any time. It should not be committed and should be ignored by version control.
### Global types
Expo CLI will add the following global types to your project when typed routes is enabled:
- Sets `process.env.NODE_ENV = "development" | "production" | "test"`
- Allows the importing of `.[css|sass|scss]` files
- Sets the exports of `*.module.[css|sass|scss]` to be `Record<string, string>`
- Add types for Metro's `require.context`. This is enabled by `expo/metro-config` and used for static route generation.
### React Native Web
With typed routes enabled, Expo CLI also augments the `react-native` types to support React Native Web. The following changes are made:
- Add additional web-only styles for `ViewStyle`, `TextStyle`, `ImageStyle`
- Add `tabIndex`, `aria-level`, `lang` to `TextProps`
- Add `hovered` to Pressable's `children` and `style` state callback function
- Add `className` elements


## Screen tracking for analytics

Learn how to enable screen tracking for analytic when using Expo Router.

Unlike React Navigation, Expo Router always has access to a URL. This means screen tracking is as easy as the web.
1. Create a higher-order component that observes the currently selected URL
2. Track the URL in your analytics provider
```
└── app/
    └── _layout.tsx
```
```tsx app/_layout.tsx
import { useEffect } from 'react';
import { usePathname, useGlobalSearchParams, Slot } from 'expo-router';
export default function Layout() {
  const pathname = usePathname();
  const params = useGlobalSearchParams();
  // Track the location in your analytics provider here.
  useEffect(() => {
    analytics.track({ pathname, params });
  }, [pathname, params]);
  // Export all the children routes in the most basic way.
  return <Slot />;
}
```
Now when the user changes routes, the analytics provider will be notified.
## Migrating from React Navigation
React Navigation's [screen tracking guide](https://reactnavigation.org/docs/screen-tracking/) cannot make the same assumptions about the navigation state that Expo Router can. As a result, the implementation requires the use of `onReady` and `onStateChange` callbacks. Avoid using these methods if possible as the root `<NavigationContainer />` is not directly exposed and allows cascading in Expo Router.


## Top-level src directory

Learn how to use a top-level src directory in your Expo Router project.

As your project grows, it can be helpful to move all the directories containing application code into a single **src** directory. Expo Router supports this out of the box.
## Using a top-level src directory
Step 1: 
Move your **app** directory to **src/app**.
```
├── src/
│   ├── app/
│   │   ├── _layout.tsx
│   │   └── index.tsx
│   └── components/
│       └── button.tsx
└── package.json
```
Step 2: 
Update [TypeScript path aliases](/guides/typescript#path-aliases) in the **tsconfig.json** file to point to the **src** directory instead of the root directory. If you use the default `@/*` alias, set it to **./src/\***:
```json tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```
This keeps `@/` imports working after moving your app directory into **src**.
Step 3: 
Restart your development server.
```sh
$ npx expo start
$ npx expo export
```
### Notes
- The config files (**app.config.ts**, **app.json**, **package.json**, **metro.config.js**, **tsconfig.json**) should remain in the root directory.
- The **src/app** directory takes higher precedence than the root **app** directory. Only the **src/app** directory will be used if you have both.
- The **public** directory should remain in the root directory.
- Static rendering will automatically use the **src/app** directory if it exists.
- You may consider updating any [type aliases](/guides/typescript#path-aliases) to point to the **src** directory instead of the root directory.
## Custom directory
> **warning** Changing the default root directory is highly discouraged. We will not accept bug reports regarding projects with custom root directories.
You can dangerously customize the root directory using the Expo Router Config Plugin. The following will change the root directory to **src/routes**, relative to the project root.
```json app.json
{
  "plugins": [
    [
      "expo-router",
      {
        "root": "./src/routes"
      }
    ]
  ]
}
```
This may lead to unexpected behavior. Many tools assume the root directory to be either **app** or **src/app**. Only tools in the exact version of Expo CLI will respect the config plugin.


## Testing configuration for Expo Router

Learn how to create integration tests for your app when using Expo Router.

Expo Router relies on your file system, which can present challenges when setting up mocks for integration tests. Expo Router's submodule, `expo-router/testing-library`, is a set of testing utilities built on top of the popular [`@testing-library/react-native`](https://callstack.github.io/react-native-testing-library/) and allows you to quickly create in-memory Expo Router apps that are pre-configured for testing.
## Configuration
Before you proceed, ensure you have set up `jest-expo` according to the [Unit testing with Jest](/develop/unit-testing/) and [`@testing-library/react-native`](https://callstack.github.io/react-native-testing-library/docs/start/quick-start) in your project.
> **Note**: When using Expo Router, do not put your test files inside the **app** directory. All files inside your **app** directory must be either routes or layout files. Instead, use the **\_\_tests\_\_** directory or a separate directory. This approach is explained in [Unit testing with Jest](/develop/unit-testing/#structure-your-tests).
## `renderRouter`
`renderRouter` extends the functionality of [`render`](https://callstack.github.io/react-native-testing-library/docs/api#render) to simplify testing with Expo Router. It returns the same query object as [`render`](https://callstack.github.io/react-native-testing-library/docs/api#render), and is compatible with [`screen`](https://callstack.github.io/react-native-testing-library/docs/api#screen), allowing you to use the standard [query API](https://callstack.github.io/react-native-testing-library/docs/api/queries) to locate components.
`renderRouter` accepts the same [options](https://callstack.github.io/react-native-testing-library/docs/api#render-options) as `render` and introduces an additional option `initialUrl`, which sets an initial route for simulating deep-linking.
#### Inline file system
`renderRouter(mock: Record<string, ReactComponent>, options: RenderOptions)`
`renderRouter` can provide inline-mocking of a file system by passing an object to this function as the first parameter. The keys of the object are the mock filesystem paths. **Do not use leading relative (`./`) or absolute (`/`) notation when defining these paths and exclude file extension.**
```tsx app.test.tsx
import { renderRouter, screen } from 'expo-router/testing-library';
import { View } from 'react-native';
it('my-test', async () => {
  const MockComponent = jest.fn(() => <View />);
  renderRouter(
    {
      index: MockComponent,
      'directory/a': MockComponent,
      '(group)/b': MockComponent,
    },
    {
      initialUrl: '/directory/a',
    }
  );
  expect(screen).toHavePathname('/directory/a');
});
```
#### Inline file system with `null` components
`renderRouter(mock: string[], options: RenderOptions)`
Providing an array of strings to `renderRouter` will create an inline mock filesystem with `null` components (`{ default: () => null }`). This is useful for testing scenarios where you do not need to test the output of a route.
```tsx app.test.tsx
import { renderRouter, screen } from 'expo-router/testing-library';
it('my-test', async () => {
  renderRouter(['index', 'directory/a', '(group)/b'], {
    initialUrl: '/directory/a',
  });
  expect(screen).toHavePathname('/directory/a');
});
```
#### Path to fixture
`renderRouter(fixturePath: string, options: RenderOptions)`
`renderRouter` can accept a directory path to mock an existing fixture. Ensure that the provided path is relative to the current test file.
```tsx app.test.tsx
import { renderRouter } from 'expo-router/testing-library';
import { View } from 'react-native';
it('my-test', async () => {
  const MockComponent = jest.fn(() => <View />);
  renderRouter('./my-test-fixture');
});
```
#### Path to the fixture with overrides
`renderRouter({ appDir: string, overrides: Record<string, ReactComponent>}, options: RenderOptions)`
For more intricate testing scenarios, `renderRouter` can leverage both directory path and inline-mocking methods simultaneously. The `appDir` parameter takes a string representing a pathname to a directory. The overrides parameter is an inline mock that can be used to override specific paths within the `appDir`. This combination allows for fine-tuned control over the mock environment.
```tsx app.test.tsx
import { renderRouter } from 'expo-router/testing-library';
import { View } from 'react-native';
it('my-test', async () => {
  const MockAuthLayout = jest.fn(() => <View />);
  renderRouter({
    appDir: './my-test-fixture',
    overrides: {
      'directory/(auth)/_layout': MockAuthLayout,
    },
  });
});
```
## Jest matchers
The following matches have been added to `expect` and can be used to assert values on `screen`.
#### toHavePathname()
Assert the current pathname against a given string. The matcher uses the value of the [`usePathname`](/router/reference/hooks/#usepathname) hook on the current `screen`.
```tsx app.test.tsx
expect(screen).toHavePathname('/my-router');
```
#### toHavePathnameWithParams()
Assert the current pathname, including URL parameters, against a given string. This is useful to assert the appearance of URL in a web browser.
```tsx app.test.tsx
expect(screen).toHavePathnameWithParams('/my-router?hello=world');
```
#### toHaveSegments()
Assert the current segments against an array of strings. The matcher uses the value of the [`useSegments`](/router/reference/hooks/#usesegments) hook on the current `screen`.
```tsx app.test.tsx
expect(screen).toHaveSegments(['[id]']);
```
#### useLocalSearchParams()
Assert the current local URL parameters against an object. The matcher uses the value of the [`useLocalSearchParams`](/router/reference/hooks/#uselocalsearchparams) hook on the current `screen`.
```tsx app.test.tsx
expect(screen).useLocalSearchParams({ first: 'abc' });
```
#### useGlobalSearchParams()
Assert the current screen's pathname that matches a value. Compares using the value of [`useGlobalSearchParams`](/router/reference/hooks/#useglobalsearchparams) hook.
Assert the current global URL parameters against an object. The matcher uses the value of the [`useGlobalSearchParams`](/router/reference/hooks/#useglobalsearchparams) hook on the current `screen`.
```tsx app.test.tsx
expect(screen).useGlobalSearchParams({ first: 'abc' });
```
#### toHaveRouterState()
An advanced matcher that asserts the current router state against an object.
```tsx app.test.tsx
expect(screen).toHaveRouterState({
  routes: [{ name: 'index', path: '/' }],
});
```


## Troubleshooting

Fixing common issues with Expo Router setup.

## Missing files or source maps in React Native DevTools
This can happen if your Chrome DevTools has exclusions within its ignore list. To fix the issue, use [React Native DevTools](https://reactnative.dev/docs/react-native-devtools):
1. Start the React Native DevTools by pressing <kbd>j</kbd> from the development server running in the terminal window
2. Open **Settings** by clicking the gear icon
3. Under **Extensions**, click **Restore defaults and reload**
4. Open **Settings** again, and go to **Ignore List** tab
5. Uncheck any exclusions for `/node_modules/`
## `EXPO_ROUTER_APP_ROOT` not defined
If `process.env.EXPO_ROUTER_APP_ROOT` is not defined you'll see the following error:
```sh
$ Invalid call at line 11: process.env.EXPO_ROUTER_APP_ROOT First argument of require.context should be a string.
```
This can happen when the Babel plugin `expo-router/babel` is not used in the project **babel.config.js**. You can try clearing the cache with:
```sh
$ npx expo start --clear
```
Alternatively, you can circumvent this issue by creating an **index.js** file in the root of your project with the following contents:
```jsx index.js
import { registerRootComponent } from 'expo';
import { ExpoRoot } from 'expo-router';
// Must be exported or Fast Refresh won't update the context
export function App() {
  const ctx = require.context('./app');
  return <ExpoRoot context={ctx} />;
}
registerRootComponent(App);
```
Then, update your app's main entry point in **package.json**:
```json package.json
{
  "main": "index.js"
}
```
> Do not use this to change the root directory (**app**) as it won't account for usage in any other places.
## `require.context` not enabled
This can happen when using a custom version of `@expo/metro-config` that does not enable context modules. Expo Router requires the project **metro.config.js** to use `expo-router/metro` as the default configuration. Delete the **metro.config.js**, or extend `expo/metro-config`. See [Customizing metro](/guides/customizing-metro/) for more information.
## Missing back button
If you set up a modal or another screen that is expected to have a back button, then you'll need to add [`unstable_settings`](/router/advanced/router-settings/) to the route's layout to ensure the initial route is configured. Initial routes are somewhat unique to mobile apps and fit awkwardly in the system &mdash; improvements pending.
```tsx app/_layout.tsx
export const unstable_settings = {
  initialRouteName: 'index',
};
```


# Migration

## Migrate from React Navigation

Learn how to migrate a project using React Navigation to Expo Router.

Both React Navigation and Expo Router are Expo frameworks for routing and navigation. Expo Router is a wrapper around React Navigation and many of the concepts are the same.
## Pitch
Along with all the benefits of React Navigation, Expo Router enables automatic deep linking, [type safety](/router/reference/typed-routes), [deferred bundling](/router/web/async-routes), [static rendering on web](/router/web/static-rendering), and more.
## Anti-pitch
If your app uses a custom `getPathFromState` or `getStateFromPath` component, it may not be a good fit for Expo Router. If you're using these functions to support [shared routes](/router/advanced/shared-routes) then you should be fine as Expo Router has built-in support for this.
## Recommendations
We recommend making the following modifications to your codebase before beginning the migration:
- Split React Navigation screen components into individual files. For example, if you have `<Stack.Screen component={HomeScreen} />`, then ensure the `HomeScreen` component is in its own file.
- Convert the project to [TypeScript](/guides/typescript/#migrating-existing-javascript-project). This will make it easier to spot errors that may occur during the migration.
- Convert relative imports to [typed aliases](/guides/typescript/#path-aliases-optional). For example, `../../components/button.tsx` to `@/components/button` before starting the migration. This makes it easier to move screens around the filesystem without having to update the relative paths.
- Migrate away from `resetRoot`. This is used to "restart" the app while running. This is generally considered bad practice, and you should restructure your app's navigation so this never needs to happen.
- Rename the initial route to `index`. Expo Router considers the route that is opened on launch to match `/`, React Navigation users will generally use something such as "Home" for the initial route.
### Refactor search parameters
Refactor screens to [use serializable top-level query parameters](https://reactnavigation.org/docs/params/#what-should-be-in-params). We recommend this in React Navigation as well.
In Expo Router, search parameters can only serialize top-level values such as `number`, `boolean`, and `string`. React Navigation doesn't have the same restrictions, so users can sometimes pass invalid parameters like Functions, Objects, Maps, and so on.
If your code has something similar to the below:
```js
import { useNavigation } from '@react-navigation/native';
const navigation = useNavigation();
navigation.push('Followers', {
  onPress: profile => {
    navigation.push('User', { profile });
  },
});
```
Consider restructuring so the function can be accessed from the "followers" screen. In this case, you can access the router and push directly from the "followers" screen.
### Eagerly load UI
It's common in React Native apps to `return null` from the root component while assets and fonts are loading. This is bad practice and generally unsupported in Expo Router. If you absolutely must defer rendering, then ensure you don't attempt to navigate to any screens.
Historically this pattern exists because React Native will throw errors if you use custom fonts that haven't loaded yet. We changed this upstream in React Native 0.72 (SDK 49) so the default behavior is to swap the default font when the custom font loads. If you'd like to hide individual text elements until a font has finished loading, write a wrapper `<Text>`, which returns null until the font has loaded.
On web, returning `null` from the root will cause [static rendering](/router/web/static-rendering) to skip all of the children, resulting in no searchable content. This can be tested by using "View Page Source" in Chrome, or by disabling JavaScript and reloading the page.
## Migration
### Delete unused or managed code
Expo Router automatically adds `react-native-safe-area-context` support.
<DiffBlock source="/static/diffs/router/migrate-from-react-navigation/remove-safe-area-provider.diff" />
Expo Router **does not** add `react-native-gesture-handler` (as of v3), so you'll have to add this yourself if you are using Gesture Handler or `<Drawer />` layout. Avoid using this package on web since it adds a lot of JavaScript that is often unused.
### Copy screens to the app directory
Create an **app** directory at the root of your repo, or in a root **src** directory.
Layout the structure of your app by creating files according to the [application of Expo Router rules](/router/basics/core-concepts/#the-rules-of-expo-router-applied). Kebab-case and lowercase letters are considered best practice for route filenames.
Replace navigators with directories, for example:
```jsx React Navigation
function HomeTabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={Home} />
      <Tab.Screen name="Feed" component={Feed} />
    </Tab.Navigator>
  );
}
function App() {
  return (
    // NavigationContainer is managed by Expo Router.
    <NavigationContainer
      linking={
        {
          // ...linking configuration
        }
      }
    >
      <Stack.Navigator>
        <Stack.Screen name="Settings" component={Settings} />
        <Stack.Screen name="Profile" component={Profile} />
        <Stack.Screen
          name="Home"
          component={HomeTabs}
          options={{
            title: 'Home Screen',
          }}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```
**Expo Router:**
- Rename the "main" route from **Home** to **index** to ensure it matches the `/` path.
- Convert names to lowercase.
- Move all the screens to the appropriate file locations inside the app directory. This may take some experimenting.
```
└── app/
    ├── _layout.js
    ├── (home)/
    │   ├── _layout.js
    │   ├── index.js
    │   └── feed.js
    ├── profile.js
    └── settings.js
```
```jsx app/_layout.js
import { Stack } from 'expo-router';
export default function RootLayout() {
  return (
    <Stack>
      <Stack.Screen
        name="(home)"
        options={
            title: 'Home Screen',
        }
      />
    </Stack>
  );
}
```
The tab navigator will be moved to a subdirectory.
```jsx app/(home)/_layout.js
import { Tabs } from 'expo-router';
export default function HomeLayout() {
  return <Tabs />;
}
```
### Use Expo Router hooks
React Navigation v6 and lower will pass the props `{ navigation, route }` to every screen. This pattern is going away in React Navigation, and we never introduced it to the Expo Router.
Instead, migrate `navigation` to the `useRouter` hook.
<DiffBlock source="/static/diffs/router/migrate-from-react-navigation/use-router-hook.diff" />
Similarly, migrate from the `route` prop to the [`useLocalSearchParams`](/router/reference/hooks/#uselocalsearchparams) hook.
<DiffBlock source="/static/diffs/router/migrate-from-react-navigation/use-local-search-params.diff" />
To access the [`navigation.navigate`](https://reactnavigation.org/docs/navigation-object/#navigate), import the `navigation` prop from [`useNavigation`](/router/reference/hooks/#usenavigation) hook.
<DiffBlock source="/static/diffs/router/migrate-from-react-navigation/use-navigation-hook.diff" />
### Migrate the Link component
React Navigation and Expo Router both provide Link components. However, Expo's Link component uses `href` instead of [`to`](https://reactnavigation.org/docs/use-link-props/#to).
```jsx
// React Navigation
<Link to="Settings" />
// Expo Router
<Link href="/settings" />
```
React Navigation users will often create a custom Link component with the `useLinkProps` hook to control the child component. This isn't necessary in Expo Router, instead, use the `asChild` prop.
### Share screens across navigators
It's common for React Navigation apps to reuse a set of routes across multiple navigators. This is generally used with tabs to ensure each tab can push any screen.
In Expo Router, you can either migrate to [shared routes](/router/advanced/shared-routes) or create multiple files and re-export the same component from them.
When you use groups or shared routes, you can navigate to specific tabs by using the fully qualified route name, for example, `/(home)/settings` instead of `/settings`.
### Migrate screen tracking events
You may have your screen tracking setup according to our [React Navigation screen tracking guide](https://reactnavigation.org/docs/screen-tracking/), update it according to the [Expo Router screen tracking guide](/router/reference/screen-tracking).
### Use platform-specific components for screens
Refer to the [platform-specific modules](/router/advanced/platform-specific-modules) guide for info on switching UI based on the platform.
### Replace the `NavigationContainer`
The global React Navigation [`<NavigationContainer />`](https://reactnavigation.org/docs/navigation-container/) is completely managed in Expo Router. Expo Router provides systems for achieving the same functionality as the `NavigationContainer` without needing to use it directly.
Note: API substitutions
---
### Ref
The `NavigationContainer` ref should not be accessed directly. Use the following methods instead.
#### `resetRoot​`
Navigate to the initial route of the application. For example, if your app starts at `/` (recommended), then you can replace the current route with `/` using this method.
```jsx
import { useRouter } from 'expo-router';
function Example() {
  const router = useRouter();
  return (
    <Text
      onPress={() => {
        // Go to the initial route of the application.
        router.replace('/');
      }}>
      Reset App
    </Text>
  );
}
```
#### `getRootState`
Use `useRootNavigationState()`.
#### `getCurrentRoute`
Unlike React Navigation, Expo Router can reliably represent any route with a string. Use the [`usePathname()`](/router/reference/hooks/#usepathname) or [`useSegments()`](/router/reference/hooks/#usesegments) hooks to identify the current route.
#### `getCurrentOptions`
Use the [`useLocalSearchParams()`](/router/reference/hooks/#uselocalsearchparams) hook to get the current route's query parameters.
#### `addListener`
The following events can be migrated:
#### `state`
Use the [`usePathname()`](/router/reference/hooks/#usepathname) or [`useSegments()`](/router/reference/hooks/#usesegments) hooks to identify the current route. Use in conjunction with `useEffect(() => {}, [...])` to observe changes.
#### `options`
Use the [`useLocalSearchParams()`](/router/reference/hooks/#uselocalsearchparams) hook to get the current route's query parameters. Use in conjunction with `useEffect(() => {}, [...])` to observe changes.
### props
Migrate the following `<NavigationContainer />` props:
#### `initialState`
In Expo Router, you can rehydrate your application state from a route string (for example, `/user/evanbacon`). Use [redirects](/router/reference/redirects/) to handle initial states. See [shared routes](/router/advanced/shared-routes/) for advanced redirects.
Avoid using this pattern in favor of deep linking (for example, a user opens your app to `/profile` rather than from the home screen) as it is most analogous to the web. If an app crashes due to a particular screen, it's best to avoid automatically navigating back to that exact screen when the app starts as it may require reinstalling the app to fix.
#### `onStateChange`
Use the [`usePathname()`](/router/reference/hooks/#usepathname), [`useSegments()`](/router/reference/hooks/#usesegments), and [`useGlobalSearchParams()`](/router/reference/hooks/#useglobalsearchparams) hooks to identify the current route state. Use in conjunction with `useEffect(() => {}, [...])` to observe changes.
- If you're attempting to track screen changes, follow the [Screen Tracking guide](/router/reference/screen-tracking/).
- React Navigation recommends avoiding [`onStateChange`](https://reactnavigation.org/docs/navigation-container/#onstatechange).
#### `onReady`
In React Navigation, [`onReady`](https://reactnavigation.org/docs/navigation-container/#onready) is most often used to determine when the splash screen should hide or when to track screens using analytics. Expo Router has special handling for both of these use cases. Assume the navigation is always ready for navigation events in the Expo Router.
- See the [Screen Tracking guide](/router/reference/screen-tracking/) for info on migrating analytics from React Navigation.
- See the [Splash Screen feature](/develop/user-interface/splash-screen-and-app-icon/) for info on handling the splash screen.
#### `onUnhandledAction`
Actions are always handled in Expo Router. Use [dynamic routes](/router/basics/notation/#square-brackets) and [404 screens](/router/error-handling/#unmatched-routes) in favor of [`onUnhandledAction`](https://reactnavigation.org/docs/navigation-container/#onunhandledaction).
#### `linking`
The [`linking`](https://reactnavigation.org/docs/navigation-container/#linking) prop is automatically constructed based on the files to the **app** directory.
#### `fallback`
The [`fallback`](https://reactnavigation.org/docs/navigation-container/#fallback) prop is automatically handled by Expo Router. Learn more in the [Splash Screen](/versions/latest/sdk/splash-screen/) reference.
#### `theme`
In React Navigation, you set the theme for the entire app using the [`<NavigationContainer />`](https://reactnavigation.org/docs/navigation-container/#theme) component. Expo Router manages the root container for you, so instead you should set the theme using the `ThemeProvider` directly.
```tsx app/_layout.tsx
import { ThemeProvider, DarkTheme, DefaultTheme, useTheme } from '@react-navigation/native';
import { Slot } from 'expo-router';
export default function RootLayout() {
  return (
    <ThemeProvider value={DarkTheme}>
      <Slot />
    </ThemeProvider>
  );
}
```
You can use this technique at any layer of the app to set the theme for a specific layout. The current theme can be accessed with the `useTheme` hook from `@react-navigation/native`.
#### `children`
The `children` prop is automatically populated based on the files in the **app** directory and the currently open URL.
#### `independent`
Expo Router does not support [`independent`](https://reactnavigation.org/docs/navigation-container/#independent) containers. This is because the router is responsible for managing the single `<NavigationContainer />`. Any additional containers will not be automatically managed by Expo Router.
#### `documentTitle`
Use the [Head component](/router/web/static-rendering#meta-tags) to set the webpage title.
#### `ref`
Use the `useNavigationContainerRef()` hook instead.
---
### Rewrite custom navigators
If your project has a custom navigator, you can rewrite this or port it to Expo Router.
To port, simply use the `withLayoutContext` function:
```js
import { createCustomNavigator } from './my-navigator';
export const CustomNavigator = withLayoutContext(createCustomNavigator().Navigator);
```
To rewrite, use the `Navigator` component, which wraps the [`useNavigationBuilder`](https://reactnavigation.org/docs/custom-navigators#usenavigationbuilder) hook from React Navigation.
The return value of `useNavigationBuilder` can be accessed with the `Navigator.useContext()` hook from inside the `<Navigator />` component. Properties can be passed to `useNavigationBuilder` using the props of the `<Navigator />` component, this includes `initialRouteName`, `screenOptions`, `router`.
All of the `children` of a `<Navigator />` component will be rendered as-is.
- `Navigator.useContext`: Access the React Navigation `state`, `navigation`, `descriptors`, and `router` for the custom navigator.
- `Navigator.Slot`: A React component used to render the currently selected route. This component can only be rendered inside a `<Navigator />` component.
#### Example
Custom layouts have an internal context that is ignored when using the `<Slot />` component without a `<Navigator />` component wrapping it.
```jsx
import { View } from 'react-native';
import { TabRouter } from '@react-navigation/native';
import { Navigator, usePathname, Slot, Link } from 'expo-router';
export default function App() {
  return (
      <Header />
      <Slot />
    </Navigator>
  );
}
function Header() {;
  const pathname = usePathname();
  return (
    <View>
      <Link href="/">Home</Link>
      <Link
        href="/profile"
        Profile
      </Link>
      <Link href="/settings">Settings</Link>
    </View>
  );
}
```
### Use Expo Router's Splash Screen wrapper
Expo Router wraps `expo-splash-screen` and adds special handling to ensure it's hidden after the navigation mounts, and whenever an unexpected error is caught. Simply migrate from importing `expo-splash-screen` to importing `SplashScreen` from `expo-router`.
### Navigation state observation
If you're observing the navigation state directly, migrate to the [`usePathname`](/router/reference/hooks/#usepathname), [`useSegments`](/router/reference/hooks/#usesegments), and [`useGlobalSearchParams`](/router/reference/hooks/#useglobalsearchparams) hooks.
### Pass params to nested screens
Instead of using the [nested screen navigation events](https://reactnavigation.org/docs/params/#passing-params-to-nested-navigators), use a qualified href:
```js
// React Navigation
navigation.navigate('Account', {
  screen: 'Settings',
  params: { user: 'jane' },
});
// Expo Router
router.push({ pathname: '/account/settings', params: { user: 'jane' } });
```
### Set initial routes for deep linking and server navigation
In React Navigation, you can use the `initialRouteName` property of the linking configuration. In Expo Router, use [layout settings](/router/advanced/router-settings).
### Reset navigation state
You can use the [`reset`](https://reactnavigation.org/docs/navigation-actions/#reset) action from the React Navigation library to reset the navigation state. It is dispatched using the [`useNavigation`](/router/reference/hooks/#usenavigation) hook from Expo Router to access the `navigation` prop.
In the below example, the `navigation` prop is accessible from the `useNavigation` hook and the `CommonActions.reset` action from `@react-navigation/native`. The object specified in the `reset` action replaces the existing navigation state with the new one.
```jsx app/screen.js
import { useNavigation } from 'expo-router'
import { CommonActions } from '@react-navigation/native'
export default function Screen() {
  const navigation = useNavigation();
  const handleResetAction = () => {
    navigation.dispatch(CommonActions.reset({
      routes: [{key: "(tabs)", name: "(tabs)"}]
    }))
  }
  return (
    <>
      {/* ...rest of the code */}
      <Button title='Reset' onPress={handleResetAction} />
    </>
  );
}
```
### Migrate TypeScript types
Expo Router can automatically generate [statically typed routes](/router/reference/typed-routes), this will ensure you can only navigate to valid routes.
## Additional information
### React Navigation themes
React Navigation navigators `<Stack>`, `<Drawer>`, and `` use a shared appearance provider. In React Navigation, you set the theme for the entire app using the `<NavigationContainer />` component. Expo Router manages the root container so that you can set the theme using the `ThemeProvider` directly.
```tsx app/_layout.tsx
import { ThemeProvider, DarkTheme, DefaultTheme, useTheme } from '@react-navigation/native';
import { Slot } from 'expo-router';
export default function RootLayout() {
  return (
    <ThemeProvider value={DarkTheme}>
      <Slot />
    </ThemeProvider>
  );
}
```
You can use this technique at any layer of the app to set the theme for a specific layout. The current theme can be accessed via `useTheme` hook from `@react-navigation/native`.
### React Navigation Elements
The [`@react-navigation/elements`](https://reactnavigation.org/docs/elements/) library provides a set of UI elements and helpers that can be used to build a navigation UI. These components are designed to be composable and customizable. You can reuse the default functionality from the library or build your navigator's UI on top of it.
To use it with Expo Router, you need to install the library:
For npm: 
```sh
$ npm install @react-navigation/elements
```
For Yarn: 
```sh
$ yarn add @react-navigation/elements
```
To learn more about the components and utilities the library provides, see [Elements library](https://reactnavigation.org/docs/elements/) documentation.


## Migrate from Expo Webpack

Learn how to migrate a website using Expo Webpack to Expo Router.

The original **Expo for web** version was based on Webpack 4 and focused primarily on building single-page applications (SPAs). This approach was based on [Create React App](https://create-react-app.dev/) and enabled building simple web apps with Expo SDK and React Native for web.
Expo Router is the new approach to building powerful universal apps that run on web and native. This guide will help you migrate your existing website to Expo Router.
Both React Navigation and Expo Router are Expo frameworks for routing and navigation. Expo Router is a wrapper around React Navigation and has many shared concepts.
## Pitch
> **warning** `@expo/webpack-config` is deprecated and not receiving any new feature updates.
Expo Router supports [static rendering on web](/router/web/static-rendering), which enables search engine optimization (SEO), social media previews, and faster loading times, unlike Expo Webpack. Along with the benefits of React Navigation, it enables automatic deep linking, [type safety](/router/reference/typed-routes), [deferred bundling](/router/web/async-routes), [modular HTML templates](/router/web/static-rendering#root-html), [static rendering on web](/router/web/static-rendering), and more.
Expo Router is also designed to fix the main cross-platform issue with Expo Webpack by sharing navigation between web and native without compromising functionality or performance.
## Anti-pitch
Expo Router uses a custom bundler stack based on [Metro](https://metrobundler.dev/). It is the same bundler used by React Native. This is great for ensuring maximum code reusability and solves many forked behavior issues from using different bundlers across platforms. This also means certain bundling features may not be available in Expo Router yet.
Ultimately as a full universal framework, Expo Router is a substantially more robust solution than `@expo/webpack-config`, which is a bundler integration. It should be used for all new Expo web projects.
## Expo CLI
Unlike `@expo/webpack-config`, Expo Router uses the same CLI commands and features for web and native. Refer to the table below for more information on the differences between Expo Router and `@expo/webpack-config`.
| Feature                  | Expo Router                                       | `@expo/webpack-config` |
| ------------------------ | ------------------------------------------------- | ---------------------- |
| Start command            | `npx expo start`                                  | `npx expo start`       |
| Bundle command           | `npx expo export`                                 | `npx expo export:web`  |
| Output directory         | **dist**                                          | **web-build**          |
| Static directory         | **public**                                        | **web**                |
| Config file              | **metro.config.js**                               | **webpack.config.js**  |
| Default config           | `@expo/metro-config`                              | `@expo/webpack-config` |
| Bundle Splitting         | <YesIcon /> (SDK 50 • web)                        | <YesIcon />            |
| Global CSS               | <YesIcon /> (SDK 50 • web)                        | <YesIcon />            |
| CSS Modules              | <YesIcon /> (SDK 50 • web)                        | <NoIcon />             |
| Static Font Optimization | <YesIcon /> (SDK 50 • web)                        | <NoIcon />             |
| API Routes               | <YesIcon /> (SDK 50)                              | <NoIcon />             |
| Multi-platform           | <YesIcon />                                       | <NoIcon />             |
| Fast Refresh             | <YesIcon />                                       | <NoIcon />             |
| Error Overlay            | <YesIcon />                                       | <NoIcon />             |
| Lazy bundling            | <YesIcon />                                       | <NoIcon />             |
| Static Generation        | <YesIcon />                                       | <NoIcon />             |
| Environment Variables    | <YesIcon />                                       | <NoIcon />             |
| `tsconfig.json` paths    | <YesIcon />                                       | <NoIcon />             |
| Tree Shaking             | <PendingIcon /> ([Partial support][tree-shaking]) | <YesIcon />            |
## HTML template
In `@expo/webpack-config` all routes shared a single HTML file. This file was based on the template in `web/index.html` which was then modified by the `@expo/webpack-config` to include the necessary scripts and stylesheets.
In Expo Router, there are two different rendering patterns:
- **Recommended**: `web.output: "static"` which outputs a new HTML file for each route in the app. This approach lets you [dynamically generate the entire HTML template using the **app/+html.js** file](/router/web/static-rendering#root-html).
- **Not recommended**: `web.output: "single"` which outputs a single-page application. This approach lets you use `public/index.html` as the template HTML file.
## Static resources
In `@expo/webpack-config`, you could host static files in the `web` directory, which would be served from the website's root. For example, `web/favicon.ico` was served from `https://example.com/favicon.ico`.
In Expo Router, you can use the **public** directory to host static files. For example, **public/favicon.ico** is served from `https://example.com/favicon.ico`. Unlike Webpack, Expo Router's hosting works on native too. Make sure to host the files from a server before using them in production.
## Bundling for production
In `@expo/webpack-config`, you could bundle your website for production using `npx expo export:web`. This would output a bundle to the **web-build** directory.
In Expo Router, use the `npx expo export --platform web` command to export to the **dist** directory. You can generate sourcemaps with the `--dump-sourcemap` flag. On build, the contents of the **public** directory will be copied to the **dist** directory.
## Babel configuration
Like before, the root [**babel.config.js**](/versions/latest/config/babel/) file is used for both web and native. You can change the preset by using the `platform` property in the API caller:
```js babel.config.js
module.exports = api => {
  // Get the platform from the API caller...
  const platform = api.caller(caller => caller && caller.platform);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      // Add a web-only plugin...
      platform === 'web' && 'custom-web-only-plugin',
    ].filter(Boolean),
  };
};
```
## Dev server
In Expo Router, all platforms are hosted from the same dev server on the same port. This is convenient for emulating the production behavior of the app. All logs and hot module reloading go through the same port as well.
Due to limitations on native, hosting with fake HTTPS is not currently supported. This feature is less important now than in 2018, as you can test secure features such as camera and location on localhost using a web browser like Chrome.
## Expo constants
The [`expo-constants`](/versions/latest/sdk/constants/) library can be used to access the **app.json** in-app. Behind the scenes, this is accomplished by setting `process.env.APP_MANIFEST` with the stringified contents of the **app.json** file.
In Expo Router, this is done using Babel with the `babel-preset-expo`. If you modify the **app.json**, restart the Babel cache with `npx expo start --clear` to see the updates.
## Base path and subpath hosting
> **important** Experimental functionality.
In `@expo/webpack-config`, you could bundle your website to be hosted from a subpath by using the `PUBLIC_URL` environment variable or the `homepage` field in the project's **package.json**:
```json package.json
{
  "homepage": "/evanbacon/my-website"
}
```
In Expo Router, you can use the experimental `baseUrl` field in the project's **app.json**:
```json app.json
{
  "expo": {
    "experiments": {
      "baseUrl": "/evanbacon/my-website"
    }
  }
}
```
Unlike the previous system, this will also update the routing to account for the base path. For example, if you have a route `/profile` and you set the base path to `/evanbacon/my-website`, then the route will be `/evanbacon/my-website/profile`.
See [hosting with sub-paths](/more/expo-cli#hosting-with-sub-paths) for more information.
## Fast refresh
In `@expo/webpack-config` you could install `@pmmmwh/react-refresh-webpack-plugin` and add the following to the **webpack.config.js**:
```js webpack.config.js
const createExpoWebpackConfigAsync = require('@expo/webpack-config');
const ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin');
module.exports = async function (env, argv) {
  const config = await createExpoWebpackConfigAsync(env, argv);
  // Use the React refresh plugin in development mode
  if (env.mode === 'development') {
    config.plugins.push(new ReactRefreshWebpackPlugin({ disableRefreshCheck: true }));
  }
  return config;
};
```
In Expo Router, **Fast Refresh is enabled by default** using the official Fast Refresh implementation by Meta.
## Favicons
Like `@expo/webpack-config`, Expo Router supports generating the **favicon.ico** file based on the `web.favicon` field in the **app.json**.
## Service workers
> **warning** Be careful adding service workers as they are known to cause unexpected behavior on web. If you accidentally ship a service worker that aggressively caches your website, users cannot request updates easily. For the best offline mobile experience, create a native app with Expo. Unlike websites with service workers, native apps can be updated through the app store to clear the cached experience. This would be similar to resetting the user's native browser (which they may have to do if the service worker is aggressive enough). See [why service workers are suboptimal](https://github.com/facebook/create-react-app/issues/2398) for more information.
Expo Webpack didn't have built-in service worker support. However, you could add it yourself by using the `workbox-webpack-plugin` and adding it to the **webpack.config.js**.
Workbox doesn't have a Metro integration, but because Workbox doesn't require one of the core features of a bundler (transformation, resolution, serialization), it can easily be used as a post-build step. Follow the guide for [using Workbox CLI](https://developer.chrome.com/docs/workbox/modules/workbox-cli/), and wherever it refers to a "build script" use `npx expo export -p web` instead.
For example, here's a possible flow for setting up Workbox. Create a new project with the following command:
```sh
$ npm create expo -t tabs my-app
$ cd my-app
```
Next, create a root HTML file for the app and add the service worker registration script:
```tsx app/+html.tsx
import { ScrollViewStyleReset } from 'expo-router/html';
import type { PropsWithChildren } from 'react';
// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        {/* Bootstrap the service worker. */}
        <script dangerouslySetInnerHTML={{ __html: sw }} />
        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
const sw = `
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').then(registration => {
            console.log('Service Worker registered with scope:', registration.scope);
        }).catch(error => {
            console.error('Service Worker registration failed:', error);
        });
    });
}
`;
```
Now build the app before running the wizard:
```sh
$ npx expo export -p web
```
Run the wizard command, select `dist` as the root of the app, and the defaults for everything else:
```sh
$ npx workbox-cli wizard
$ ? What is the root of your web app (that is which directory do you deploy)? dist/
$ ? Which file types would you like to precache? js
html
ttf
ico
json
$ ? Where would you like your service worker file to be saved? dist/sw.js
$ ? Where would you like to save these configuration options? workbox-config.js
$ ? Does your web app manifest include search parameter(s) in the 'start_url
other than 'utm_' or 'fbclid' (like '?source=pwa')? No
```
Finally, run `npx workbox-cli generateSW workbox-config.js` to generate the service worker config. Going forward, you can add a build script in **package.json** to run both scripts in the correct order:
```json package.json
{
  "scripts": {
    "build:web": "expo export -p web && npx workbox-cli generateSW workbox-config.js"
  }
}
```
## PWA manifests
Unlike `@expo/webpack-config`, Expo Router does not automatically attempt to generate the PWA manifest configuration. You can create one in **public/manifest.json**:
```json
{
  "short_name": "Expo App",
  "name": "Expo Router Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
```
You can link this in your HTML file using the `link` tag:
```tsx app/+html.tsx
import { ScrollViewStyleReset } from 'expo-router/html';
import type { PropsWithChildren } from 'react';
// This file is web-only and used to configure the root HTML for every
// web page during static rendering.
// The contents of this function only run in Node.js environments and
// do not have access to the DOM or browser APIs.
export default function Root({ children }: PropsWithChildren) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        {/* Link the PWA manifest file. */}
        <link rel="manifest" href="/manifest.json" />
        {/*
          Disable body scrolling on web. This makes ScrollView components work closer to how they do on native.
          However, body scrolling is often nice to have for mobile web. If you want to enable it, remove this line.
        */}
        <ScrollViewStyleReset />
        {/* Add any additional <head> elements that you want globally available on web... */}
      </head>
      <body>{children}</body>
    </html>
  );
}
```
## Bundler plugins
If you were using custom bundler plugins, see [Expo Metro config](/versions/latest/config/metro) for adding custom functionality to your bundler pipeline.
## Navigation
If you used React Navigation for navigating between screens in `@expo/webpack-config`, see the [migration guide for React Navigation](/router/migrate/from-react-navigation).
## Deployment
Check out [Publishing websites](/guides/publishing-websites) on how to deploy Expo Router websites to various hosting providers.
[tree-shaking]: /guides/tree-shaking


# Expo Modules API

## Expo Modules API: Overview

An overview of the APIs and utilities provided by Expo to develop native modules.

## What is the Expo Modules API
The Expo Modules API allows you to write Swift and Kotlin to add new capabilities to your app with native modules and views. The API is designed to take advantage of modern language features, to be as consistent as possible on both platforms, to require minimal boilerplate, and provide comparable performance characteristics to React Native's Turbo Modules API. Expo Modules all support the New Architecture and are automatically backwards compatible with existing React Native apps using the old architecture.
We believe that using the Expo Modules API makes building and maintaining nearly all kinds of React Native modules about as easy as it can be, and we think that the Expo Modules API is the best choice for the vast majority of developers building native modules for their apps.
### Common questions
Note: Do I need to know the Expo Modules API to build an Expo / React Native app?
---
Most of the time, Expo and React Native developers don't need to write any native code &mdash; libraries are already available for a wide range of use cases, from camera to video to maps to haptics and much more.
But sometimes, nothing does exactly what you need. Maybe you want to integrate an analytics service that your company mandates but that doesn't yet have a React Native library yet, so you need to build a module around their SDK. Or maybe you want to access a system feature that your app requires, but isn't commonly used, so nobody maintains a library for it.
---
Note: When should I use Turbo Modules and when should I use the Expo Modules API?
---
To summarize and paraphrase the [recommendation from the React Native team](https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0759-react-native-frameworks.md#what-do-we-recommend-to-react-native-library-developers):
- If you intend to use C++ in your native module, use Turbo Modules since it provides easier access to lower-level mechanisms.
- If you are looking for a better developer experience and you are willing to depend on the `expo` package in your module, then use the Expo Modules API.
---
Note: Where can I find open source Expo Modules to learn from?
---
The [Expo SDK](https://github.com/expo/expo/tree/main/packages) is a great place to look if you want to learn how we have implemented our libraries. Another great resource is open source apps, such as [Bluesky](https://github.com/bluesky-social/social-app/tree/main/modules).
The following libraries are some of our favorites from the community:
- [`react-native-widget-extension`](https://github.com/bndkt/react-native-widget-extension)
- [`burnt`](https://github.com/nandorojo/burnt)
- [`expo-video-metadata`](https://github.com/hirbod/expo-video-metadata)
- [`swiftui-react-native`](https://github.com/andrew-levy/swiftui-react-native)
- [`react-native-ios-context-menu`](https://github.com/dominicstop/react-native-ios-context-menu)
- [`react-native-mlkit`](https://github.com/infinitered/react-native-mlkit)
- [`react-native-passkeys`](https://github.com/peterferguson/react-native-passkeys)
- [`expo-drag-drop-content-view`](https://github.com/AlirezaHadjar/expo-drag-drop-content-view)
---
Note: What impact does using the Expo Modules API have on my app size?
---
Adding the Expo Modules API to your app has a negligible impact on your app size, it may increase the size by a few hundred kilobytes. [Learn more in this blog post](https://blog.expo.dev/embracing-expo-modules-in-your-react-native-projects-cd8ed4cbec3).
---
Note: What impact does using the Expo Modules API have on my app's performance?
---
The Expo Modules API has similar performance characteristics to React Native's Turbo Modules API. Both APIs leverage React Native's JavaScript Interface (JSI), rather than the legacy approach of using a JSON message queue ("bridge") ([learn more about JSI](https://reactnative.dev/docs/the-new-architecture/landing-page#fast-javascriptnative-interfacing)).
Neither Expo Modules nor Turbo Modules are designed to be as fast as technically possible, but rather they are fast where it matters. For example, the Expo Modules API could leverage code generation and the new native Swift / C++ interop to reduce the overhead of individual method calls. However, this imposes some developer experience challenges and overhead, and we have not yet encountered any use cases where such an optimization would provide any meaningful real-world performance improvements. In reality, the time spent executing the body of a native method is often orders of magnitude greater than the overhead of the method invocation. Both Expo Modules and Turbo Modules can easily execute hundreds of thousands of native method calls per second, which is well over what you are likely to find in any app, and the overhead of the method calls is unlikely to be the bottleneck.
If you encounter any performance bottlenecks with the Expo Modules API, [file an issue](https://github.com/expo/expo/issues/new/choose) and we'd be happy to discuss it with you.
---
Note: Does the Expo Modules API support platforms other than Android, iOS, and web?
---
The Expo Modules API has experimental support for macOS and tvOS. See [Additional platform support](/modules/additional-platform-support/) tutorial for more information.
---
Note: How can I use the Expo Modules API to make a third-party SDK available to my Expo app?
---
Learn more about this in the [Integrate an existing library](/modules/existing-library/) tutorial.
---
## Next steps


## Expo Modules API: Get started

Learn about getting started with Expo modules API.

**There are two ways to get started with the Expo Modules API:** you can either initialize a new module from scratch or add the Expo Modules API to an existing module. This guide will walk you through creating a new module from scratch, and the [Integrating in an existing library](/modules/existing-library) covers the latter.
The two recommended flows to create a new module with Expo Modules API:
- [Add a new module to an existing Expo application](#add-a-new-module-to-an-existing-application), and use it to test and develop your module.
- [Create a new module in isolation with a generated example project](#create-a-new-module-with-an-example-project) if you want to reuse it in multiple projects or publish it to npm.
Both of these flows are covered in the next sections.
## Add a new module to an existing application
Step 1: 
### Create the local Expo module
Navigate to your project directory (the one that contains the **package.json** file) and run the following command. This is the recommended way to create a local Expo module.
```sh
$ npx create-expo-module@latest --local
```
You can provide a meaningful module name in the CLI prompt. For the rest of the prompts, you can also accept the default suggestions.
Once you've run the command, you will see a new directory created in your project called **modules**. The directory structure should look like this:
```
└── modules/
    └── my-module/
        ├── android/
        │   └── 
        ├── ios/
        │   └── 
        ├── src/
        │   └── 
        ├── expo-module.config.json
        └── index.ts
```
Then, if your project doesn't have native projects generated (**android** and **ios** directories), run the following command, otherwise skip this command:
```sh
$ npx expo prebuild --clean
```
> **Note**: If you have a pre-existing **ios** directory in your project's root which was created using `npx expo prebuild`, you must reinstall the pods:
>
> 
> ```sh
$ npx pod-install
```
Step 2: 
### Use the local module
Import the local module in your application, for example in **App.js** or **App.tsx** or **app/(tabs)/index.tsx**:
```tsx app/(tabs)/index.tsx
import MyModule from '@/modules/my-module';
export default function HomeScreen() {
  return (
    <View style={styles.container}>
      <Text>{MyModule.hello()}</Text>
    </View>
  );
}
```
Start the development server in your terminal so that when you edit the native module and build the app in the next step, the changes will be reflected in the app:
```sh
$ npx expo start
```
Congratulations! You have created a local Expo module. You can now start working on it.
> **info** **Tip**: You can also use absolute import paths [by applying these configuration changes](https://expo.fyi/absolute-path-expo-modules.md).
Step 3: 
### Edit the module
To develop and test your module locally, let's use Android Studio and Xcode for Android and iOS.
#### Android
1. Open the **android** directory (that is generated by `npx expo prebuild` in step 1) from your project in Android Studio. It may take a while for Gradle to finish syncing the native directory project.
2. Once the project is synced, open **modules/my-module/android/src/main/java/expo/modules/mymodule/MyModule.kt** file.
3. Change `hello` function to return a different string, such as "Hello world! 🌎🤖" and save the file.
4. Build the app by clicking **Run 'app'** button from top menu bar and you will see the changes on the screen.
You have to repeat the build step anytime you make a change to the native code to the changes.
#### iOS
1. Open the **ios** directory (that is generated by `npx expo prebuild` in step 1) from your project in Xcode by running `xed ios` command.
2. Under **Pods** > **Development Pods** > **MyModule**, open **MyModule.swift** file.
3. Change `hello` function to return a different string, such as "Hello world! 🌎🍎" and save the file.
4. Build your app by clicking **Run** button from top menu bar or press <kbd>⌘ Cmd</kbd> + <kbd>R</kbd>, you will see the changes on the screen.
You have to repeat the build step anytime you make a change to the native code to the changes.
> **info** **Tip**: Use `npx pod-install` to reinstall the pods if you add new native files to the module or when you modify **expo-module.config.json**.
> **Note**: There are also other flows for working on an Expo module in parallel with your application. For example, you can use a monorepo or publish to npm, as described in the [How to use a standalone Expo module](/modules/use-standalone-expo-module-in-your-project) guide.
## Create a new module with an example project
Step 1: 
### Create the Expo module
To create a new Expo module from scratch, run the `create-expo-module` script as shown below.
The script will ask you a few questions and then generate the native Expo module along with the example app for Android and iOS that uses your new module.
```sh
`$ npx create-expo-module@latest my-module`
```
Step 2: 
### Open the module and start the development server
Navigate to the module directory and then open the Android and/or iOS example project by running the following commands:
```sh
`$ cd my-module`
`$ npm run open:android`
`$ npm run open:ios`
```
Go to **example** directory and start the development server in your terminal so that when you edit the native module and build the app in the next step, the changes will be reflected in the app:
```sh
$ cd example
$ npx expo start
```
> **Note:** If you're using Windows, you can open the example project by opening the **android** directory in Android Studio, but you cannot open the iOS project files.
Step 3: 
### Edit the module
#### Android
1. Open **my-module/android/src/main/java/expo/modules/mymodule/MyModule.kt** file.
2. Change `hello` function to return a different string, such as "Hello world! 🌎🤖" and save the file.
3. Build the app by clicking **Run 'app'** button from top menu bar and you will see the changes on the screen.
You have to repeat the build step anytime you make a change to the native code to the changes.
#### iOS
1. Under **Pods** > **Development Pods** > **MyModule**, open **MyModule.swift** file.
2. Change `hello` function to return a different string, such as "Hello world! 🌎🍎" and save the file.
3. Build your app by clicking **Run** button from top menu bar or press <kbd>⌘ Cmd</kbd> + <kbd>R</kbd>, you will see the changes on the screen.
You have to repeat the build step anytime you make a change to the native code to the changes.
> **info** **Tip**: Use `npx pod-install` to reinstall the pods if you add new native files to the module or when you modify **expo-module.config.json**.
## Next steps
Now that you have learned how to initialize a module and make simple changes to it, you can continue to a tutorial or dive right into the API reference.


# Tutorials

## Tutorial: Create a native module

A tutorial on creating a native module that persists settings with Expo Modules API.

In this tutorial, you build a module that stores the user's preferred app theme: dark, light, or system. On Android, use [`SharedPreferences`](https://developer.android.com/reference/android/content/SharedPreferences), and on iOS, use [`UserDefaults`](https://developer.apple.com/documentation/foundation/userdefaults). You can implement web support with [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), but this tutorial does not cover that.
Video Tutorial: [Watch: How to create a native module with the Expo Modules API](https://www.youtube.com/watch?v=CdaQSlyGik8)
---
Step 1: 
## Initialize a new module
First, create a new module. For this tutorial, the module is named `expo-settings` or `ExpoSettings`. You can choose a different name, but adjust the instructions to match your choice.
```sh
$ npx create-expo-module expo-settings
```
> **info** Since you aren't going to actually ship this library, you can hit <kbd>return</kbd> for all the prompts to accept the default values.
Step 2: 
## Set up workspace
Clean up the default module to start with a clean slate. Delete the view module since this guide does not use it.
```sh
$ cd expo-settings
$ rm ios/ExpoSettingsView.swift
$ rm android/src/main/java/expo/modules/settings/ExpoSettingsView.kt
$ rm src/ExpoSettingsView.tsx
$ rm src/ExpoSettingsView.web.tsx src/ExpoSettingsModule.web.ts
```
Locate the following files and replace their contents with the provided minimal boilerplate:
```kotlin android/src/main/java/expo/modules/settings/ExpoSettingsModule.kt
package expo.modules.settings
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoSettingsModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoSettings")
    Function("getTheme") {
      return@Function "system"
    }
  }
}
```
```swift ios/ExpoSettingsModule.swift
import ExpoModulesCore
public class ExpoSettingsModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoSettings")
    Function("getTheme") { () -> String in
      "system"
    }
  }
}
```
```ts src/ExpoSettings.types.ts
export type ExpoSettingsModuleEvents = {};
```
```ts src/ExpoSettingsModule.ts
import { NativeModule, requireNativeModule } from 'expo';
import { ExpoSettingsModuleEvents } from './ExpoSettings.types';
declare class ExpoSettingsModule extends NativeModule<ExpoSettingsModuleEvents> {
  getTheme: () => string;
}
// This call loads the native module object from the JSI.
export default requireNativeModule<ExpoSettingsModule>('ExpoSettings');
```
```ts src/index.ts
import ExpoSettingsModule from './ExpoSettingsModule';
export function getTheme(): string {
  return ExpoSettingsModule.getTheme();
}
```
```tsx example/App.tsx
import * as Settings from 'expo-settings';
import { Text, View } from 'react-native';
export default function App() {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Theme: {Settings.getTheme()}</Text>
    </View>
  );
}
```
Step 3: 
## Run the example project
Start the TypeScript compiler to watch for changes.
```sh
$ npm run build
```
In a separate terminal window, run the example app.
```sh
$ cd example
$ npx expo run:android
$ npx expo run:ios
```
You should see the text "Theme: system" in the center of the screen when you launch the example app. The value `"system"` comes from synchronously calling the `getTheme()` function in the native module. You will change this value in the next step.
Step 4: 
## Get, set, and persist the theme preference value
### Android native module
To read the value, look for a `SharedPreferences` string under the key `"theme"`. If the key does not exist, default to `"system"`. Use the `reactContext` (a React Native [ContextWrapper](https://developer.android.com/reference/android/content/ContextWrapper)) to access the `SharedPreferences` instance with `getSharedPreferences()`.
To set the value, use the `edit()` method of `SharedPreferences` to get an `Editor` instance. Then, use `putString()` to set the value. Ensure the `setTheme` function accepts a value of type `String`.
```kotlin android/src/main/java/expo/modules/settings/ExpoSettingsModule.kt
package expo.modules.settings
import android.content.Context
import android.content.SharedPreferences
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoSettingsModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoSettings")
    Function("setTheme") { theme: String ->
      getPreferences().edit().putString("theme", theme).commit()
    }
    Function("getTheme") {
      return@Function getPreferences().getString("theme", "system")
    }
  }
  private val context
  get() = requireNotNull(appContext.reactContext)
  private fun getPreferences(): SharedPreferences {
    return context.getSharedPreferences(context.packageName + ".settings", Context.MODE_PRIVATE)
  }
}
```
### iOS native module
To read the value on iOS, look for a `UserDefaults` string under the key `"theme"`. If the key does not exist, default to `"system"`.
To set the value, use the `set(_:forKey:)` method of `UserDefaults`. Ensure the `setTheme` function accepts a value of type `String`.
```swift ios/ExpoSettingsModule.swift
import ExpoModulesCore
public class ExpoSettingsModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoSettings")
    Function("setTheme") { (theme: String) -> Void in
      UserDefaults.standard.set(theme, forKey:"theme")
    }
    Function("getTheme") { () -> String in
      UserDefaults.standard.string(forKey: "theme") ?? "system"
    }
  }
}
```
### TypeScript module
Update the **ExpoSettingsModule.ts** to add a TypeScript interface for the `ExpoSettingsModule` native module to update the theme.
```ts src/ExpoSettingsModule.ts
import { NativeModule, requireNativeModule } from 'expo';
import { ExpoSettingsModuleEvents } from './ExpoSettings.types';
declare class ExpoSettingsModule extends NativeModule<ExpoSettingsModuleEvents> {
  setTheme: (theme: string) => void;
  getTheme: () => string;
}
// This call loads the native module object from the JSI.
export default requireNativeModule<ExpoSettingsModule>('ExpoSettings');
```
Now, call your native modules from TypeScript.
```ts src/index.ts
import ExpoSettingsModule from './ExpoSettingsModule';
export function getTheme(): string {
  return ExpoSettingsModule.getTheme();
}
export function setTheme(theme: string): void {
  return ExpoSettingsModule.setTheme(theme);
}
```
### Example app
You can now use the Settings API in your example app.
```tsx example/App.tsx
import * as Settings from 'expo-settings';
import { Button, Text, View } from 'react-native';
export default function App() {
  const theme = Settings.getTheme();
  // Toggle between dark and light theme
  const nextTheme = theme === 'dark' ? 'light' : 'dark';
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Theme: {Settings.getTheme()}</Text>
      <Button title={`Set theme to ${nextTheme}`} onPress={() => Settings.setTheme(nextTheme)} />
    </View>
  );
}
```
When you rebuild and run the app, the "system" theme is still set. Pressing the button does nothing, but when you reload the app, the theme changes. This happens because the app does not fetch the new theme value or re-render. You will fix this in the next step.
Step 5: 
## Emit change events for the theme value
Ensure developers using your API can react to theme value changes by emitting a change event whenever the value updates. Use the [Events](/modules/module-api/#events) definition component to describe the events your module emits, `sendEvent` to emit the event from native code, and the [EventEmitter](/modules/module-api/#sending-events) API to subscribe to events in JavaScript. The event payload is `{ theme: string }`.
### Android native module
Events payloads are represented as [`Bundle`](https://developer.android.com/reference/android/os/Bundle.html) instances on Android, which you can create using the [`bundleOf`](<https://developer.android.com/reference/kotlin/androidx/core/os/package-summary#bundleOf(kotlin.Array)>) function.
```kotlin android/src/main/java/expo/modules/settings/ExpoSettingsModule.kt
package expo.modules.settings
import android.content.Context
import android.content.SharedPreferences
import androidx.core.os.bundleOf
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoSettingsModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoSettings")
    Events("onChangeTheme")
    Function("setTheme") { theme: String ->
      getPreferences().edit().putString("theme", theme).commit()
      this@ExpoSettingsModule.sendEvent("onChangeTheme", bundleOf("theme" to theme))
    }
    Function("getTheme") {
      return@Function getPreferences().getString("theme", "system")
    }
  }
  private val context
  get() = requireNotNull(appContext.reactContext)
  private fun getPreferences(): SharedPreferences {
    return context.getSharedPreferences(context.packageName + ".settings", Context.MODE_PRIVATE)
  }
}
```
### iOS native module
```swift ios/ExpoSettingsModule.swift
import ExpoModulesCore
public class ExpoSettingsModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoSettings")
    Events("onChangeTheme")
    Function("setTheme") { (theme: String) -> Void in
      UserDefaults.standard.set(theme, forKey:"theme")
      sendEvent("onChangeTheme", [
        "theme": theme
      ])
    }
    Function("getTheme") { () -> String in
      UserDefaults.standard.string(forKey: "theme") ?? "system"
    }
  }
}
```
### TypeScript module
```ts src/ExpoSettings.types.ts
export type ThemeChangeEvent = {
  theme: string;
};
export type ExpoSettingsModuleEvents = {
  onChangeTheme: (params: ThemeChangeEvent) => void;
};
```
```ts src/index.ts
import { EventSubscription } from 'expo-modules-core';
import ExpoSettingsModule from './ExpoSettingsModule';
import { ThemeChangeEvent } from './ExpoSettings.types';
export function addThemeListener(listener: (event: ThemeChangeEvent) => void): EventSubscription {
  return ExpoSettingsModule.addListener('onChangeTheme', listener);
}
export function getTheme(): string {
  return ExpoSettingsModule.getTheme();
}
export function setTheme(theme: string): void {
  return ExpoSettingsModule.setTheme(theme);
}
```
### Example app
```tsx example/App.tsx
import * as Settings from 'expo-settings';
import { useEffect, useState } from 'react';
import { Button, Text, View } from 'react-native';
export default function App() {
  const [theme, setTheme] = useState<string>(Settings.getTheme());
  useEffect(() => {
    const subscription = Settings.addThemeListener(({ theme: newTheme }) => {
      setTheme(newTheme);
    });
    return () => subscription.remove();
  }, [setTheme]);
  // Toggle between dark and light theme
  const nextTheme = theme === 'dark' ? 'light' : 'dark';
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Theme: {Settings.getTheme()}</Text>
      <Button title={`Set theme to ${nextTheme}`} onPress={() => Settings.setTheme(nextTheme)} />
    </View>
  );
}
```
Step 6: 
## Improve type safety with Enums
It's easy to make mistakes when using the `Settings.setTheme()` API in its current form, as it allows any string value. Improve the type safety of this API by using an enum to restrict the possible values to `system`, `light`, and `dark`.
### Android native module
```kotlin android/src/main/java/expo/modules/settings/ExpoSettingsModule.kt
package expo.modules.settings
import android.content.Context
import android.content.SharedPreferences
import androidx.core.os.bundleOf
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import expo.modules.kotlin.types.Enumerable
class ExpoSettingsModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoSettings")
    Events("onChangeTheme")
    Function("setTheme") { theme: Theme ->
      getPreferences().edit().putString("theme", theme.value).commit()
      this@ExpoSettingsModule.sendEvent("onChangeTheme", bundleOf("theme" to theme.value))
    }
    Function("getTheme") {
      return@Function getPreferences().getString("theme", Theme.SYSTEM.value)
    }
  }
  private val context
  get() = requireNotNull(appContext.reactContext)
  private fun getPreferences(): SharedPreferences {
    return context.getSharedPreferences(context.packageName + ".settings", Context.MODE_PRIVATE)
  }
}
enum class Theme(val value: String) : Enumerable {
  LIGHT("light"),
  DARK("dark"),
  SYSTEM("system")
}
```
### iOS native module
```swift ios/ExpoSettingsModule.swift
import ExpoModulesCore
public class ExpoSettingsModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoSettings")
    Events("onChangeTheme")
    Function("setTheme") { (theme: Theme) -> Void in
      UserDefaults.standard.set(theme.rawValue, forKey:"theme")
      sendEvent("onChangeTheme", [
        "theme": theme.rawValue
      ])
    }
    Function("getTheme") { () -> String in
      UserDefaults.standard.string(forKey: "theme") ?? Theme.system.rawValue
    }
  }
  enum Theme: String, Enumerable {
    case light
    case dark
    case system
  }
}
```
### TypeScript module
```ts src/ExpoSettings.types.ts
export type Theme = 'light' | 'dark' | 'system';
export type ThemeChangeEvent = {
  theme: Theme;
};
export type ExpoSettingsModuleEvents = {
  onChangeTheme: (params: ThemeChangeEvent) => void;
};
```
```ts src/ExpoSettingsModule.ts
import { NativeModule, requireNativeModule } from 'expo';
import { ExpoSettingsModuleEvents, Theme } from './ExpoSettings.types';
declare class ExpoSettingsModule extends NativeModule<ExpoSettingsModuleEvents> {
  setTheme: (theme: Theme) => void;
  getTheme: () => Theme;
}
// This call loads the native module object from the JSI.
export default requireNativeModule<ExpoSettingsModule>('ExpoSettings');
```
```ts src/index.ts
import { EventSubscription } from 'expo-modules-core';
import ExpoSettingsModule from './ExpoSettingsModule';
import { Theme, ThemeChangeEvent } from './ExpoSettings.types';
export function addThemeListener(listener: (event: ThemeChangeEvent) => void): EventSubscription {
  return ExpoSettingsModule.addListener('onChangeTheme', listener);
}
export function getTheme(): Theme {
  return ExpoSettingsModule.getTheme();
}
export function setTheme(theme: Theme): void {
  return ExpoSettingsModule.setTheme(theme);
}
```
### Example app
If you change `Settings.setTheme(nextTheme)` to `Settings.setTheme("not-a-real-theme")`, TypeScript will raise an error. If you ignore the error and press the button, you will see the following runtime error:
```text
 ERROR  Error: FunctionCallException: Calling the 'setTheme' function has failed (at ExpoModulesCore/SyncFunctionComponent.swift:76)
→ Caused by: ArgumentCastException: Argument at index '0' couldn't be cast to type Enum<Theme> (at ExpoModulesCore/JavaScriptUtils.swift:41)
→ Caused by: EnumNoSuchValueException: 'not-a-real-theme' is not present in Theme enum, it must be one of: 'light', 'dark', 'system' (at ExpoModulesCore/Enumerable.swift:37)
```
The last line of the error message shows that `not-a-real-theme` is not a valid value for the `Theme` enum. The only valid values are `light`, `dark`, and `system`.
Congratulations! You have created your first Expo Module for Android and iOS.
## Next steps


## Tutorial: Create a native view

A tutorial on creating a native view that renders a WebView with Expo Modules API.

In this tutorial, you'll build an example module with a native view that renders a WebView. For Android, you'll use the [`WebView`](https://developer.android.com/reference/android/webkit/WebView) component, and for iOS, [`WKWebView`](https://developer.apple.com/documentation/webkit/wkwebview). Web support can be implemented using an [`iframe`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) and is left as an exercise for you.
Step 1: 
## Initialize a new module
Create a new module by running the following command and name the example module `expo-web-view`:
```sh
$ npx create-expo-module expo-web-view
```
> **info** Since this is an example library and won't be published, press <kbd>return</kbd> for all prompts to accept the default values.
Step 2: 
## Set up workspace
Clean up the default module to start with a clean slate by deleting the following files:
```sh
$ cd expo-web-view
$ rm src/ExpoWebView.types.ts src/ExpoWebViewModule.ts
$ rm src/ExpoWebView.web.tsx src/ExpoWebViewModule.web.ts
```
Locate the following files and replace them with the provided minimal boilerplate:
```kotlin android/src/main/java/expo/modules/webview/ExpoWebViewModule.kt
package expo.modules.webview
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoWebViewModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView::class) {}
  }
}
```
```swift ios/ExpoWebViewModule.swift
import ExpoModulesCore
public class ExpoWebViewModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView.self) {}
  }
}
```
```tsx src/ExpoWebView.tsx
import { ViewProps } from 'react-native';
import { requireNativeViewManager } from 'expo-modules-core';
import * as React from 'react';
export type Props = ViewProps;
const NativeView: React.ComponentType<Props> = requireNativeViewManager('ExpoWebView');
export default function ExpoWebView(props: Props) {
  return <NativeView {...props} />;
}
```
```tsx src/index.ts
export { default as WebView, Props as WebViewProps } from './ExpoWebView';
```
```tsx example/App.tsx
import { WebView } from 'expo-web-view';
export default function App() {
  return <WebView style={{ flex: 1, backgroundColor: 'purple' }} />;
}
```
Step 3: 
## Run the example project
To ensure everything is working, start the TypeScript compiler to watch for changes and rebuild the module's JavaScript:
```sh
$ npm run build
```
```sh
$ cd example
$ npx expo run:android
$ npx expo run:ios
```
You should now see a blank purple screen. While it's not very exciting, it's a good start. Next, turn it into a WebView.
Step 4: 
## Add the system WebView as a subview
Add the system `WebView` with a hardcoded URL as a subview of `ExpoWebView`. The `ExpoWebView` class extends `ExpoView`, which extends `RCTView` from React Native, and eventually extends `View` on Android and `UIView` on iOS.
Ensure that the `WebView` subview uses the same layout as `ExpoWebView`, whose layout is calculated by React Native's layout engine.
### Android view
On Android, use `LayoutParams` to set the WebView's layout to match the `ExpoWebView` layout. You can do this when you instantiate the WebView.
```kotlin android/src/main/java/expo/modules/webview/ExpoWebView.kt
package expo.modules.webview
import android.content.Context
import android.webkit.WebView
import android.webkit.WebViewClient
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.views.ExpoView
class ExpoWebView(context: Context, appContext: AppContext) : ExpoView(context, appContext) {
  internal val webView = WebView(context).also {
    it.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
    it.webViewClient = object : WebViewClient() {}
    addView(it)
    it.loadUrl("https://docs.expo.dev/modules/")
  }
}
```
### iOS view
On iOS, set `clipsToBounds` to `true` and ensure the WebView's `frame` matches the bounds of `ExpoWebView` in `layoutSubviews`. The `init` method is called when the view is created, and `layoutSubviews` is called when the layout changes.
```swift ios/ExpoWebView.swift
import ExpoModulesCore
import WebKit
class ExpoWebView: ExpoView {
  let webView = WKWebView()
  required init(appContext: AppContext? = nil) {
    super.init(appContext: appContext)
    clipsToBounds = true
    addSubview(webView)
    let url =  URL(string:"https://docs.expo.dev/modules/")!
    let urlRequest = URLRequest(url:url)
    webView.load(urlRequest)
  }
  override func layoutSubviews() {
    webView.frame = bounds
  }
}
```
### Example app
No changes are required. Rebuild and run the app using the following commands:
```sh
$ npx expo prebuild --clean
$ npx expo run:android
$ npx expo run:ios
```
After that, you'll see the [Expo Modules API overview page](/modules/overview) rendered. If the changes aren't reflected, try reinstalling the app.
Step 5: 
## Add a prop to set the URL
To set a prop on the view, define the prop name and setter inside `ExpoWebViewModule`. In this case, you can access the `webView` property directly for convenience. However, in real-world scenarios, keep the logic inside the `ExpoWebView` class to minimize how much `ExpoWebViewModule` knows about its internals.
Use the [Prop definition component](/modules/module-api/#prop) to define the prop. In the prop setter block, you can access both the view and the prop. Specify that the URL is of type `URL` &mdash; the Expo modules API will convert strings to the native `URL` type.
### Android module
```kotlin android/src/main/java/expo/modules/webview/ExpoWebViewModule.kt
package expo.modules.webview
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import java.net.URL
class ExpoWebViewModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView::class) {
      Prop("url") { view: ExpoWebView, url: URL? ->
        view.webView.loadUrl(url.toString())
      }
    }
  }
}
```
### iOS module
```swift ios/ExpoWebViewModule.swift
import ExpoModulesCore
public class ExpoWebViewModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView.self) {
      Prop("url") { (view, url: URL) in
        if view.webView.url != url {
          let urlRequest = URLRequest(url: url)
          view.webView.load(urlRequest)
        }
      }
    }
  }
}
```
### TypeScript module
Next, add the `url` prop to the `Props` type.
```tsx src/ExpoWebView.tsx
import { ViewProps } from 'react-native';
import { requireNativeViewManager } from 'expo-modules-core';
import * as React from 'react';
export type Props = {
  url?: string;
} & ViewProps;
const NativeView: React.ComponentType<Props> = requireNativeViewManager('ExpoWebView');
export default function ExpoWebView(props: Props) {
  return <NativeView {...props} />;
}
```
### Example app
Finally, pass a `URL` to your `WebView` component in the example app.
```tsx example/App.tsx
import { WebView } from 'expo-web-view';
export default function App() {
  return <WebView style={{ flex: 1 }} url="https://expo.dev" />;
}
```
Rebuild the example app:
```sh
$ npx expo prebuild --clean
$ npx expo run:android
$ npx expo run:ios
```
After that, you'll see the [Expo homepage](https://expo.dev) in the WebView.
Step 6: 
## Add an event to notify when the page has loaded
[View callbacks](/modules/module-api/#view-callbacks) allow developers to listen for events on components. They are typically registered through props on the component, for example: `<Image onLoad={...} />`. Use the [Events definition component](/modules/module-api/#events) to define an event for your WebView. Call it `onLoad`.
### Android view and module
On Android, override the `onPageFinished` function. Then, call the `onLoad` event handler that you defined in the module.
```kotlin android/src/main/java/expo/modules/webview/ExpoWebView.kt
package expo.modules.webview
import android.content.Context
import android.webkit.WebView
import android.webkit.WebViewClient
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.viewevent.EventDispatcher
import expo.modules.kotlin.views.ExpoView
class ExpoWebView(context: Context, appContext: AppContext) : ExpoView(context, appContext) {
  private val onLoad by EventDispatcher()
  internal val webView = WebView(context).also {
    it.layoutParams = LayoutParams(
      LayoutParams.MATCH_PARENT,
      LayoutParams.MATCH_PARENT
    )
    it.webViewClient = object : WebViewClient() {
      override fun onPageFinished(view: WebView, url: String) {
        onLoad(mapOf("url" to url))
      }
    }
    addView(it)
  }
}
```
Indicate in `ExpoWebViewModule` that the `View` has an `onLoad` event.
```kotlin android/src/main/java/expo/modules/webview/ExpoWebViewModule.kt
package expo.modules.webview
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import java.net.URL
class ExpoWebViewModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView::class) {
      Events("onLoad")
      Prop("url") { view: ExpoWebView, url: URL? ->
        view.webView.loadUrl(url.toString())
      }
    }
  }
}
```
### iOS view and module
On iOS, implement `webView(_:didFinish:)` and make `ExpoWebView` extend `WKNavigationDelegate`. Then, call `onLoad` from that delegate method.
```swift ios/ExpoWebView.swift
import ExpoModulesCore
import WebKit
class ExpoWebView: ExpoView, WKNavigationDelegate {
  let webView = WKWebView()
  let onLoad = EventDispatcher()
  required init(appContext: AppContext? = nil) {
    super.init(appContext: appContext)
    clipsToBounds = true
    webView.navigationDelegate = self
    addSubview(webView)
  }
  override func layoutSubviews() {
    webView.frame = bounds
  }
  func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
    if let url = webView.url {
      onLoad([
        "url": url.absoluteString
      ])
    }
  }
}
```
Indicate in `ExpoWebViewModule` that the `View` has an `onLoad` event.
```swift ios/ExpoWebViewModule.swift
import ExpoModulesCore
public class ExpoWebViewModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoWebView")
    View(ExpoWebView.self) {
      Events("onLoad")
      Prop("url") { (view, url: URL) in
        if view.webView.url != url {
          let urlRequest = URLRequest(url: url)
          view.webView.load(urlRequest)
        }
      }
    }
  }
}
```
### TypeScript module
Event payloads are included within the `nativeEvent` property of the event. To access the `url` from the `onLoad` event, read `event.nativeEvent.url`.
```tsx src/ExpoWebView.tsx
import { ViewProps } from 'react-native';
import { requireNativeViewManager } from 'expo-modules-core';
import * as React from 'react';
export type OnLoadEvent = {
  url: string;
};
export type Props = {
  url?: string;
  onLoad?: (event: { nativeEvent: OnLoadEvent }) => void;
} & ViewProps;
const NativeView: React.ComponentType<Props> = requireNativeViewManager('ExpoWebView');
export default function ExpoWebView(props: Props) {
  return <NativeView {...props} />;
}
```
### Example app
Update the example app to show an alert when the page has loaded. Copy the following code, then rebuild and run your app, and you'll see the alert!
```tsx example/App.tsx
import { WebView } from 'expo-web-view';
export default function App() {
  return (
    <WebView
      style={{ flex: 1 }}
      url="https://expo.dev"
      onLoad={event => alert(`loaded ${event.nativeEvent.url}`)}
    />
  );
}
```
Step 7: 
## Bonus: Build a web browser UI around it
Now that you have a WebView, build a web browser UI around it. Try rebuilding a browser UI, and feel free to add new native capabilities as needed (for example, support for back or reload buttons). If you need inspiration, see the example below.
Note: example/App.tsx
---
```tsx App.tsx
import { useState } from 'react';
import { ActivityIndicator, Platform, Text, TextInput, View } from 'react-native';
import { WebView } from 'expo-web-view';
export default function App() {
  const [inputUrl, setInputUrl] = useState('https://docs.expo.dev/modules/');
  const [url, setUrl] = useState(inputUrl);
  const [isLoading, setIsLoading] = useState(true);
  return (
    <View style={{ flex: 1, paddingTop: Platform.OS === 'ios' ? 80 : 30 }}>
      <TextInput
        value={inputUrl}
        onChangeText={setInputUrl}
        returnKeyType="go"
        autoCapitalize="none"
        onSubmitEditing={() => {
          if (inputUrl !== url) {
            setUrl(inputUrl);
            setIsLoading(true);
          }
        }}
        keyboardType="url"
        style={{
          color: '#fff',
          backgroundColor: '#000',
          borderRadius: 10,
          marginHorizontal: 10,
          paddingHorizontal: 20,
          height: 60,
        }}
      />
      <WebView
        url={url.startsWith('https://') || url.startsWith('http://') ? url : `https://${url}`}
        onLoad={() => setIsLoading(false)}
        style={{ flex: 1, marginTop: 20 }}
      />
      <LoadingView isLoading={isLoading} />
    </View>
  );
}
function LoadingView({ isLoading }: { isLoading: boolean }) {
  if (!isLoading) {
    return null;
  }
  return (
    <View
      style={{
        position: 'absolute',
        bottom: 0,
        left: 0,
        right: 0,
        height: 80,
        backgroundColor: 'rgba(0,0,0,0.5)',
        paddingBottom: 10,
        justifyContent: 'center',
        alignItems: 'center',
        flexDirection: 'row',
      }}>
      <ActivityIndicator animating={isLoading} color="#fff" style={{ marginRight: 10 }} />
      <Text style={{ color: '#fff' }}>Loading...</Text>
    </View>
  );
}
```
---
Congratulations! You've created your first Expo module with a native view for Android and iOS.
## Next steps


## Tutorial: Create a module with a config plugin

A tutorial on creating a native module with a config plugin using Expo Modules API.

[Config plugins](/config-plugins/introduction/) let you customize native Android and iOS projects generated with `npx expo prebuild` in [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) projects. You can use them to add properties to native config files, copy assets to native projects, or apply advanced configurations, such as adding an [app extension target](/build-reference/app-extensions/).
As an app developer, config plugins help you apply customizations not exposed in the default [app config](/workflow/configuration). As a library author, they enable you to configure native projects automatically for developers using your library.
This tutorial explains how to create a new config plugin from scratch and read custom values that your plugin injects into **AndroidManifest.xml** and **Info.plist** from an Expo module.
Step 1: 
## Initialize a module
Start by initializing a new Expo module project with `create-expo-module`. This sets up scaffolding for Android, iOS, and TypeScript and includes an example project to test the module within an app. Run the following command to get started:
```sh
$ npx create-expo-module expo-native-configuration
```
This guide uses the name `expo-native-configuration`/`ExpoNativeConfiguration` for the module project. However, you can choose any name you prefer.
Step 2: 
## Set up workspace
In this example, you don't need the view module included by `create-expo-module`. Clean up the default module with the following command:
```sh
$ cd expo-native-configuration
$ rm android/src/main/java/expo/modules/nativeconfiguration/ExpoNativeConfigurationView.kt
$ rm ios/ExpoNativeConfigurationView.swift
$ rm src/ExpoNativeConfigurationView.tsx src/ExpoNativeConfiguration.types.ts
$ rm src/ExpoNativeConfigurationView.web.tsx src/ExpoNativeConfigurationModule.web.ts
```
Locate the following files and replace them with the provided minimal boilerplate:
- **android/src/main/java/expo/modules/nativeconfiguration/ExpoNativeConfigurationModule.kt**
- **ios/ExpoNativeConfigurationModule.swift**
- **src/ExpoNativeConfigurationModule.ts**
- **src/index.ts**
- **example/App.tsx**
- **package.json**
```kotlin android/src/main/java/expo/modules/nativeconfiguration/ExpoNativeConfigurationModule.kt
package expo.modules.nativeconfiguration
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoNativeConfigurationModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoNativeConfiguration")
    Function("getApiKey") {
      return@Function "api-key"
    }
  }
}
```
```swift ios/ExpoNativeConfigurationModule.swift
import ExpoModulesCore
public class ExpoNativeConfigurationModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoNativeConfiguration")
    Function("getApiKey") { () -> String in
      "api-key"
    }
  }
}
```
```ts src/ExpoNativeConfigurationModule.ts
import { NativeModule, requireNativeModule } from 'expo';
declare class ExpoNativeConfigurationModule extends NativeModule {
  getApiKey(): string;
}
// This call loads the native module object from the JSI.
export default requireNativeModule<ExpoNativeConfigurationModule>('ExpoNativeConfiguration');
```
```ts src/index.ts
import ExpoNativeConfigurationModule from './ExpoNativeConfigurationModule';
export function getApiKey(): string {
  return ExpoNativeConfigurationModule.getApiKey();
}
```
```tsx example/App.tsx
import * as ExpoNativeConfiguration from 'expo-native-configuration';
import { Text, View } from 'react-native';
export default function App() {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>API key: {ExpoNativeConfiguration.getApiKey()}</Text>
    </View>
  );
}
```
```json package.json
{
  "dependencies": {
    "expo-native-configuration": "file:.."
  }
}
```
Step 3: 
## Run the example project
In the root of your project, run the TypeScript compiler to watch for changes and rebuild the module's JavaScript:
```sh
$ npm run build
```
In another terminal window, compile and run the example app:
```sh
$ cd example
$ rm -rf node_modules && npm install
$ npx expo run:android
$ npx expo run:ios
```
You should see a screen with the text "API key: api-key".
Step 4: 
## Create a new config plugin
[Plugins](/config-plugins/introduction/#plugin-function) are synchronous functions that accept an `ExpoConfig` and return a modified `ExpoConfig`. By convention, these functions are prefixed with the word `with`. Name your plugin `withMyApiKey` or use a different name, as long as it follows this convention.
Here is an example of a basic config plugin function:
```js
const withMyApiKey = config => {
  return config;
};
```
You can also use `mods`, which are async functions that modify files in native projects, such as source code or configuration files (plist, xml). The `mods` object is different from the rest of the app config because it doesn't serialize after the initial reading. This allows you to perform actions _during_ code generation.
When writing config plugins, follow these considerations:
- Plugins must be synchronous, and their return value must be serializable, except for any `mods` that are added.
- `plugins` are invoked whenever the `getConfig` method from `expo/config` reads the configuration. In contrast, `mods` are invoked only during the "syncing" phase of `npx expo prebuild`.
> Although optional, use [`expo-module-scripts`](https://www.npmjs.com/package/expo-module-scripts) to simplify plugin development. It provides a recommended default configuration for TypeScript and Jest. For more information, see the [config plugins guide](https://github.com/expo/expo/tree/main/packages/expo-module-scripts#-config-plugin).
Start creating your plugin with this minimal boilerplate. Create a **plugin** directory for writing the plugin in TypeScript and add an **app.plugin.js** file in the project root, which will be the plugin's entry point.
### Create a plugin/tsconfig.json file
```json plugin/tsconfig.json
{
  "extends": "expo-module-scripts/tsconfig.plugin",
  "compilerOptions": {
    "outDir": "build",
    "rootDir": "src"
  },
  "include": ["./src"],
  "exclude": ["**/__mocks__/*", "**/__tests__/*"]
}
```
### Create a plugin/src/index.ts file for your plugin
```ts plugin/src/index.ts
import { ConfigPlugin } from 'expo/config-plugins';
const withMyApiKey: ConfigPlugin = config => {
  console.log('my custom plugin');
  return config;
};
export default withMyApiKey;
```
### Create an app.plugin.js file in the root directory
```js app.plugin.js
// This file configures the entry file for your plugin.
module.exports = require('./plugin/build');
```
At the root of your project, run `npm run build plugin` to start the TypeScript compiler in watch mode. Next, configure your example project to use your plugin by adding the following line to the **example/app.json** file:
```json example/app.json
{
  "expo": {
    "plugins": ["../app.plugin.js"]
  }
}
```
When you run the `npx expo prebuild` command inside your **example** directory, the terminal logs "my custom plugin" through a console statement.
```sh
$ cd example
$ npx expo prebuild --clean
```
To inject your custom API keys into **AndroidManifest.xml** and **Info.plist**, use helper [`mods` provided by `expo/config-plugins`](/config-plugins/plugins-and-mods/#what-are-mods). These make it easy to modify native files. For this example, use `withAndroidManifest` and `withInfoPlist`.
As the name suggests, `withAndroidManifest` allows you to read and modify the **AndroidManifest.xml** file. Use `AndroidConfig` helpers to add a metadata item to the main application, as shown below:
```ts
const withMyApiKey: ConfigPlugin<{ apiKey: string }> = (config, { apiKey }) => {
  config = withAndroidManifest(config, config => {
    const mainApplication = AndroidConfig.Manifest.getMainApplicationOrThrow(config.modResults);
    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'MY_CUSTOM_API_KEY',
      apiKey
    );
    return config;
  });
  return config;
};
```
Similarly, you can use `withInfoPlist` to modify the **Info.plist** values. Using the `modResults` property, you can add custom values as shown in the code snippet below:
```ts
const withMyApiKey: ConfigPlugin<{ apiKey: string }> = (config, { apiKey }) => {
  config = withInfoPlist(config, config => {
    config.modResults['MY_CUSTOM_API_KEY'] = apiKey;
    return config;
  });
  return config;
};
```
You can create a custom plugin by merging everything into a single function:
```ts plugin/src/index.ts
import {
  withInfoPlist,
  withAndroidManifest,
  AndroidConfig,
  ConfigPlugin,
} from 'expo/config-plugins';
const withMyApiKey: ConfigPlugin<{ apiKey: string }> = (config, { apiKey }) => {
  config = withInfoPlist(config, config => {
    config.modResults['MY_CUSTOM_API_KEY'] = apiKey;
    return config;
  });
  config = withAndroidManifest(config, config => {
    const mainApplication = AndroidConfig.Manifest.getMainApplicationOrThrow(config.modResults);
    AndroidConfig.Manifest.addMetaDataItemToMainApplication(
      mainApplication,
      'MY_CUSTOM_API_KEY',
      apiKey
    );
    return config;
  });
  return config;
};
export default withMyApiKey;
```
With the plugin ready to use, update the example app to pass your API key to the plugin as a configuration option. Modify the `plugins` field in **example/app.json** as shown below:
```json example/app.json
{
  "expo": {
    "plugins": [["../app.plugin.js", { "apiKey": "custom_secret_api" }]]
  }
}
```
After making this change, test that the plugin works correctly by running `npx expo prebuild --clean` inside the **example** directory. This command executes your plugin and updates native files, injecting `"MY_CUSTOM_API_KEY"` into **AndroidManifest.xml** and **Info.plist**. You can verify this by checking the contents of **example/android/app/src/main/AndroidManifest.xml** and **example/ios/exponativeconfigurationexample/Info.plist**.
Step 5: 
## Read native values from the module
Now, make your native module read the fields added to **AndroidManifest.xml** and **Info.plist** by using platform-specific methods to access their contents.
On Android, access metadata information from the **AndroidManifest.xml** file using the `packageManager` class. To read the `"MY_CUSTOM_API_KEY"` value, update the **android/src/main/java/expo/modules/nativeconfiguration/ExpoNativeConfigurationModule.kt** file:
```kotlin android/src/main/java/expo/modules/nativeconfiguration/ExpoNativeConfigurationModule.kt
package expo.modules.nativeconfiguration
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import android.content.pm.PackageManager
class ExpoNativeConfigurationModule() : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoNativeConfiguration")
    Function("getApiKey") {
      val applicationInfo = appContext?.reactContext?.packageManager?.getApplicationInfo(appContext?.reactContext?.packageName.toString(), PackageManager.GET_META_DATA)
      return@Function applicationInfo?.metaData?.getString("MY_CUSTOM_API_KEY")
    }
  }
}
```
On iOS, you can read the content of an **Info.plist** property using the `Bundle.main.object(forInfoDictionaryKey: "")` method. To access the `"MY_CUSTOM_API_KEY"` value added earlier, update the **ios/ExpoNativeConfigurationModule.swift** file as shown:
```swift ios/ExpoNativeConfigurationModule.swift
import ExpoModulesCore
public class ExpoNativeConfigurationModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoNativeConfiguration")
    Function("getApiKey") {
     return Bundle.main.object(forInfoDictionaryKey: "MY_CUSTOM_API_KEY") as? String
    }
  }
}
```
Step 6: 
## Run your module
With your native modules reading the fields added to the native files, you can now run the example app and access your custom API key using the `ExamplePlugin.getApiKey()` function.
```sh
$ cd example
$ npx expo prebuild
$ npx expo run:android
$ npx expo run:ios
```
## Next steps
Congratulations, you have created a config plugin that interacts with an Expo module for Android and iOS!
If you want to challenge yourself and make the plugin more versatile, this exercise is open for you. Modify the plugin to allow any arbitrary set of config keys and values to be passed in, and add functionality to read arbitrary keys from the module.


## How to use a standalone Expo module

Learn how to use a standalone module created with create-expo-module in your project by using a monorepo or publishing the package to npm.

**The recommended way to create an Expo module** in an existing project is described in the [Expo Modules API: Get Started](/modules/get-started/) guide. This tutorial explains two additional methods for using a module created with `create-expo-module` in an existing project:
- [Configure a monorepo](#use-a-monorepo)
- [Publish the module to npm](#publish-the-module-to-npm)
These methods are useful if you still want to keep the module separate from the application or share it with other developers.
## Use a monorepo
Your project should use the following structure:
- **apps**: A directory to store multiple projects, including React Native apps.
- **packages**: A directory to keep different packages used by your apps.
- **package.json**: This is the root package file that contains the Yarn workspaces configuration.
> **info** To learn how to configure your project as a monorepo, check out the [Working with monorepos](/guides/monorepos/) guide.
Step 1: 
### Initialize a new module
Once you have set up the basic monorepo structure, create a new module using `create-expo-module` with the flag `--no-example` to skip creating the example app:
```sh
$ npx create-expo-module packages/expo-settings --no-example
```
Step 2: 
### Set up a workspace dependency
Add your native module from **packages** to your apps' dependencies. Update the **package.json** file in each app inside the **apps** directory that will use your native module and add your native module to the existing entries of dependencies:
```json package.json
{
  "dependencies": {
    "expo-settings": "*"
  }
}
```
Step 3: 
### Run the module
Run one of your apps to ensure everything works. Then, start the TypeScript compiler in **packages/expo-settings** to watch for changes and rebuild the module's JavaScript:
```sh
$ cd packages/expo-settings
$ npm run build
```
Open another terminal window, select an app from the **apps** directory, and run the `prebuild` command with the `--clean` option. Repeat these steps for each app in your monorepo to use the new module.
```sh
$ npx expo prebuild --clean
```
Compile and run the app with the following command:
```sh
$ npx expo run:android
$ npx expo run:ios
```
You can now use the module in your app. To test it, edit the **app/(tabs)/index.tsx** file in your app and render the text message from the `expo-settings` module:
```tsx app/(tabs)/index.tsx
import React from 'react';
import { Text, View } from 'react-native';
import * as Settings from 'expo-settings';
export default function TabOneScreen() {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>{Settings.hello()}</Text>
    </View>
  );
}
```
After this configuration, the app displays the text "Hello world! 👋".
## Publish the module to npm
You can publish the module on npm and install it as a dependency in your project by following the steps below.
Step 1: 
### Initialize a new module
Start by creating a new module with `create-expo-module`. Follow the prompts carefully, as you will publish this library, and choose a unique name for your npm package.
```sh
$ npx create-expo-module expo-settings
```
Step 2: 
### Run the example project
Run one of your apps to ensure everything works. Then, start the TypeScript compiler in the root of your project to watch for changes and rebuild the module's JavaScript:
```sh
$ npm run build
```
Open another terminal window, compile and run the example app:
```sh
$ cd example
$ npx expo run:android
$ npx expo run:ios
```
Step 3: 
### Publish the package to npm
To publish your package to npm, you need an npm account. If you don't have one, create an account on [the npm website](https://www.npmjs.com/signup). After creating an account, log in by running the following command:
```sh
$ npm login
```
Navigate to the root of your module, then run the following command to publish it:
```sh
$ npm publish
```
Your module will now be published to npm and can be installed in other projects using `npm install`.
Apart from publishing your module to npm, you can use it in your project in the following ways:
- **Create a tarball**: Use `npm pack` to create a tarball of your module, then install it in your project by running `npm install /path/to/tarball`. This method is helpful for testing your module locally before publishing it or sharing it with others who don't have access to the npm registry.
- **Run a local npm registry**: Use a tool such as [Verdaccio](https://verdaccio.org/) to host a local npm registry. You can install your module from this registry, which is useful for managing internal packages within a company or organization.
- **Publish a private package**: [Use a private registry with EAS Build](/build-reference/private-npm-packages/) to manage private modules securely.
Step 4: 
### Test the published module
To test the published module in a new project, create a new app and install the module as a dependency by running the following command:
```sh
$ npx create-expo-app my-app
$ cd my-app
$ npx expo install expo-settings
```
You can now use the module in your app! To test it, edit **app/(tabs)/index.tsx** and render the text message from **expo-settings**.
```tsx app/(tabs)/index.tsx
import React from 'react';
import * as Settings from 'expo-settings';
import { Text, View } from 'react-native';
export default function TabOneScreen() {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>{Settings.hello()}</Text>
    </View>
  );
}
```
Finally, prebuild your project and run the app by executing the following commands:
```sh
$ npx expo prebuild --clean
$ npx expo run:android
$ npx expo run:ios
```
After this configuration, you see the text "Hello world! 👋" displayed in the app.
## Next steps


## Wrap third-party native libraries

Learn how to create a simple wrapper around two separate native libraries using Expo Modules API.

Expo modules make it possible to easily use native, external libraries built for Android and iOS in React Native projects. This tutorial focuses on utilizing the Expo Modules API to create radial charts using two similar libraries accessible on both native platforms.
- [MPAndroidChart by PhilJay](https://github.com/PhilJay/MPAndroidChart)
- [Charts by Daniel Cohen Gindi](https://github.com/danielgindi/Charts)
The iOS library is inspired by the Android library, so they both have similar API and functionality. This makes them a good example for this tutorial.
Video Tutorial: [How to wrap native libraries](https://www.youtube.com/watch?v=M8eNfH1o0eE)
---
Step 1: 
## Create a new module
The following steps assume that the new module is created inside a new Expo project. However, you can create a new module inside an existing project by following the alternative instructions.
For In an existing Expo project: 
Alternatively, you can use the new module as a view inside the existing Expo project directory. Run the following command in your project's directory:
```sh
$ npx create-expo-module --local expo-radial-chart
```
Now, open the newly created `modules/expo-radial-chart` directory to start editing the native code.
For Start with a new module: 
Create a new empty Expo module that can be published on npm and utilized in any Expo app by running the following command:
```sh
$ npx create-expo-module expo-radial-chart
```
> **info** **Tip**: If you aren't going to ship this library, press <kbd>return</kbd> for all the prompts to accept the default values in the terminal window.
Now, open the newly created `expo-radial-chart` directory to start editing the native code.
Step 2: 
## Run the example project
To verify that everything is functioning correctly, let's run the example project.
For In an existing Expo project: 
If you started with an existing Expo project, run the following commands from your Expo project's root directory:
```sh
$ npx expo run:android
$ npx expo run:ios
```
For In a new module: 
If you started with a new module project, open a terminal window, start the TypeScript compiler to watch for changes, and rebuild the module JavaScript:
```sh
$ npm run build
```
In another terminal window, compile and run the example app:
```sh
$ cd example-expo-app
$ npx expo run:android
$ npx expo run:ios
```
Step 3: 
## Add native dependencies
Add the native dependencies to the module by editing the **expo-radial-chart/android/build.gradle** and **expo-radial-chart/ios/ExpoRadialChart.podspec** files:
<DiffBlock source="/static/diffs/third-party-library/android-mpandroidchart-dependency.diff" />
<DiffBlock source="/static/diffs/third-party-library/ios-dgcharts-dependency.diff" />
Note: Are you trying to use a  dependency?
---
  For SDK 52 and later: 
    Inside the **android** directory, create another directory called **libs** and place the **.aar** file inside it. Then, add the file as a Gradle project from autolinking:
<DiffBlock source="/static/diffs/third-party-library/expo-module-config-gradle-aar.diff" />
    Finally, add the dependency to the `dependencies` list in the **android/build.gradle** file, using the dependency's specified name with `${project.name}$` prefix:
<DiffBlock source="/static/diffs/third-party-library/android-build-gradle-aar-project.diff" />
  For SDK 51 and earlier: 
    Inside the **android** directory, create another directory called **libs** and place the **.aar** file inside it. Then, add the directory as a repository:
<DiffBlock source="/static/diffs/third-party-library/android-build-gradle-flatdir.diff" />
Finally, add the dependency to the `dependencies` list. Instead of the filename, use the package path, which includes the `@aar` at the end:
<DiffBlock source="/static/diffs/third-party-library/android-build-gradle-mpandroidchart-aar.diff" />
---
Note: Are you trying to use an  or  dependency?
---
On iOS, you can also use dependencies bundled as a framework by using the `vendored_frameworks` config option.
<DiffBlock source="/static/diffs/third-party-library/ios-podspec-vendored-framework.diff" />
> **info** **Note**: The file pattern used to specify the path to the framework is relative to the podspec file,
> and doesn't support traversing the parent directory (`..`), meaning you need to place the framework inside the **ios** directory
> (or a subdirectory of **ios**).
Once the framework is added, make sure that the `source_files` option file pattern doesn't match any files inside the framework. One way to achieve this is to move your iOS source Swift files (that is `ExpoRadialChartView.swift` and `ExpoRadialChartModule.swift`) into a **src** directory separate from where you placed your framework(s) and update the `source_files` option to only match the **src** directory:
<DiffBlock source="/static/diffs/third-party-library/ios-podspec-source-files-src.diff" />
Your **ios** directory should end up with a file structure similar to this:
```
├── Frameworks/
│   └── MyFramework.framework
├── src/
│   ├── ExpoRadialChartView.swift
│   └── ExpoRadialChartModule.swift
└── ExpoRadialChart.podspec
```
---
Step 4: 
## Define an API
To use the module in the app, define the types for the props. It accepts a list of series &mdash; each with a color and a percentage value.
```ts src/ExpoRadialChart.types.ts
import { ViewStyle } from 'react-native/types';
export type ChangeEventPayload = {
  value: string;
};
type Series = {
  color: string;
  percentage: number;
};
export type ExpoRadialChartViewProps = {
  style?: ViewStyle;
  data: Series[];
};
```
Since the module isn't implemented for web in this example, let's replace the **src/ExpoRadialChartView.web.tsx** file:
```tsx src/ExpoRadialChartView.web.tsx
import * as React from 'react';
export default function ExpoRadialChartView() {
  return <div>Not implemented</div>;
}
```
Step 5: 
## Implement the module on Android
Now you can implement the native functionality by editing the placeholder files with the following changes:
1. Create a `PieChart` instance and set its `layoutParams` to match the parent view. Then, add it to the view hierarchy using the `addView` function.
2. Define a `setChartData` function that accepts a list of `Series` objects. You can iterate over the list, create a `PieEntry` for each series and store the colors in a separate list.
3. Create a `PieDataSet`, use it to create a `PieData` object, and set it as data on the `PieChart` instance.
```kotlin android/src/main/java/expo/modules/radialchart/ExpoRadialChartView.kt
package expo.modules.radialchart
import android.content.Context
import android.graphics.Color
import androidx.annotation.ColorInt
import com.github.mikephil.charting.charts.PieChart
import com.github.mikephil.charting.data.PieData
import com.github.mikephil.charting.data.PieDataSet
import com.github.mikephil.charting.data.PieEntry
import expo.modules.kotlin.AppContext
import expo.modules.kotlin.records.Field
import expo.modules.kotlin.records.Record
import expo.modules.kotlin.views.ExpoView
class Series : Record {
  @Field
  val color: String = "#ff0000"
  @Field
  val percentage: Float = 0.0f
}
class ExpoRadialChartView(context: Context, appContext: AppContext) : ExpoView(context, appContext) {
  internal val chartView = PieChart(context).also {
    it.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)
    addView(it)
  }
  fun setChartData(data: ArrayList<Series>) {
    val entries: ArrayList<PieEntry> = ArrayList()
    val colors: ArrayList<Int> = ArrayList()
    for (series in data) {
      entries.add(PieEntry(series.percentage))
      colors.add(Color.parseColor(series.color))
    }
    val dataSet = PieDataSet(entries, "DataSet");
    dataSet.colors = colors;
    val pieData = PieData(dataSet);
    chartView.data = pieData;
    chartView.invalidate();
  }
}
```
You also need to use the [`Prop`](/modules/module-api/#prop) function to define the `data` prop and call the native `setChartData` function when the prop changes:
```kotlin android/src/main/java/expo/modules/radialchart/ExpoRadialChartModule.kt
package expo.modules.radialchart
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class ExpoRadialChartModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("ExpoRadialChart")
    View(ExpoRadialChartView::class) {
      Prop("data") { view: ExpoRadialChartView, prop: ArrayList<Series> ->
        view.setChartData(prop);
      }
    }
  }
}
```
Step 6: 
## Implement the module on iOS
Now you can implement the native functionality by editing the placeholder files with the following changes:
1. Create a new `PieChartView` instance and use the `addSubview` function to add it to the view hierarchy.
2. Set the `clipsToBounds` property and override the `layoutSubviews` function to make sure the chart view is always the same size as the parent view.
3. Create a `setChartData` function that accepts a list of series, creates a `PieChartDataSet` instance with the data, and assigns it to the `data` property of the `PieChartView` instance.
```swift ios/ExpoRadialChartView.swift
import ExpoModulesCore
import DGCharts
struct Series: Record {
  @Field
  var color: UIColor = UIColor.black
  @Field
  var percentage: Double = 0
}
class ExpoRadialChartView: ExpoView {
  let chartView = PieChartView()
  required init(appContext: AppContext? = nil) {
    super.init(appContext: appContext)
    clipsToBounds = true
    addSubview(chartView)
  }
  override func layoutSubviews() {
    chartView.frame = bounds
  }
  func setChartData(data: [Series]) {
    let set1 = PieChartDataSet(entries: data.map({ (series: Series) -> PieChartDataEntry in
      return PieChartDataEntry(value: series.percentage)
    }))
    set1.colors = data.map({ (series: Series) -> UIColor in
      return series.color
    })
    let chartData: PieChartData = [set1]
    chartView.data = chartData
  }
}
```
You also need to use the [`Prop`](/modules/module-api/#prop) function to define the `data` prop and call the native `setChartData` function when the prop changes:
```swift ios/ExpoRadialChartModule.swift
import ExpoModulesCore
public class ExpoRadialChartModule: Module {
  public func definition() -> ModuleDefinition {
    Name("ExpoRadialChart")
    View(ExpoRadialChartView.self) {
      Prop("data") { (view: ExpoRadialChartView, prop: [Series]) in
        view.setChartData(data: prop)
      }
    }
  }
}
```
Step 7: 
## Write an example app to use the module
You can update the app inside the **app** directory to test the module. Use the `ExpoRadialChartView` component to render a pie chart with three slices:
```tsx app/(tabs)/index.tsx
import { ExpoRadialChartView } from '@/modules/expo-radial-chart';
import { StyleSheet } from 'react-native';
export default function App() {
  return (
    <ExpoRadialChartView
      style={styles.container}
      data={[
        {
          color: '#ff0000',
          percentage: 0.5,
        },
        {
          color: '#00ff00',
          percentage: 0.2,
        },
        {
          color: '#0000ff',
          percentage: 0.3,
        },
      ]}
    />
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
```
> **info** **Tip**: If you created a new module, make sure to update the import statement to: `import { ExpoRadialChartView } from 'expo-radial-chart';`
Step 8: 
## Rebuild and launch your application
To make sure your app builds successfully on both platforms, rerun the build commands from step 2. After the app is successfully built on any of the platform you'll see a pie chart with three slices:
Congratulations! You have created your first simple wrapper around two separate third-party native libraries using Expo Modules API.
## Next step


## Integrate in an existing library

Learn how to integrate Expo Modules API into an existing React Native library.

There are cases where you may want to integrate the Expo Modules API into an existing React Native library. For example, it might be useful to incrementally rewrite your library or to take advantage of [Android lifecycle listeners](/modules/android-lifecycle-listeners/) and [iOS AppDelegate subscribers](/modules/appdelegate-subscribers/) to automatically set up the library.
This guide will help you set up your existing React Native library to access Expo Modules API.
## Prerequisites
Create the [**expo-module.config.json**](/modules/module-config/) file at the root of your project and add an empty object `{}` inside it. You will fill it in later to enable specific features.
Creating this file is necessary for [Expo Autolinking](/modules/autolinking/) to recognize your library as an Expo module and automatically link your native code.
Step 1: 
## Add the `expo-modules-core` native dependency
Add `expo-modules-core` as a dependency in your **build.gradle** and **podspec** files:
```groovy
// ...
dependencies {
  // ...
  implementation project(':expo-modules-core')
}
```
```ruby
# ...
Pod::Spec.new do |s|
  # ...
  s.dependency 'ExpoModulesCore'
end
```
Step 2: 
## Add Expo packages to dependencies
Add `expo` package as a peer dependency in your **package.json** &mdash; we recommend using `*` as a version range so as not to cause any duplicated packages in user's **node_modules** directory.
Your library also needs to depend on `expo-modules-core` but only as a dev dependency &mdash; it's already provided in the projects depending on your library by the `expo` package with the version of core that is compatible with the specific SDK used in the project.
```json package.json
{
  "devDependencies": {
    "expo-modules-core": "^X.Y.Z"
  },
  "peerDependencies": {
    "expo": "*"
  },
  "peerDependenciesMeta": {
    "expo": {
      "optional": true
    }
  }
}
```
Step 3: 
## Create a native module
Create Kotlin and Swift files from the templates below:
```kotlin
package my.module.package
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class MyModule : Module() {
  override fun definition() = ModuleDefinition {
    // Definition components go here
  }
}
```
```swift
import ExpoModulesCore
public class MyModule: Module {
  public func definition() -> ModuleDefinition {
    // Definition components go here
  }
}
```
Then, add your classes to Android and/or iOS `modules` in the [**expo-module.config.json**](/modules/module-config/) file. Expo Autolinking will automatically link these classes as native modules in the user's project.
```json expo-module.config.json
{
  "ios": {
    "modules": ["MyModule"]
  },
  "android": {
    "modules": ["my.module.package.MyModule"]
  }
}
```
If you already have an example app in your workspace, ensure that the module is linked correctly.
- **On Android** the native module class will be linked automatically before building, as part of the Gradle build task.
- **On iOS** you need to run `pod install` to link the new class.
These module classes are now accessible from the JavaScript code using the `requireNativeModule` function from the `expo-modules-core` package. We recommend creating a separate file that exports the native module for simplicity.
```ts MyModule.ts
import { requireNativeModule } from 'expo-modules-core';
export default requireNativeModule('MyModule');
```
Now that the class is set up and linked, you can start to implement its functionality. See the [native module API](/modules/module-api/) reference page and links to [examples](/modules/module-api/#examples) from simple to moderately complex real-world modules to understand how to use the API.


## Additional platform support

Learn how to add support for macOS and tvOS platforms.

Expo Modules API provides first-class support for Android and iOS. However, since all Apple platforms are based on the same foundation and use the same programming language, targeting other [Out-of-Tree platforms](https://reactnative.dev/docs/out-of-tree-platforms) in the Expo module is possible.
Currently, only **macOS** and **tvOS** platforms are supported. This guide will walk you through adding support for these platforms.
Step 1: 
## Use the `"apple"` platform in `expo-module.config.json`
To provide seamless support for other Apple platforms, Expo SDK introduced a universal `"apple"` platform to instruct the [autolinking](/modules/autolinking/) that the module may support any of the Apple platform and whether to link the module in the specific CocoaPods target is moved off to the podspec. If you have used `"ios"` before, you can safely replace it:
```diff
diff --git a/expo-module.config.json b/expo-module.config.json
index 0000000..1111111 100644
--- a/expo-module.config.json
+++ b/expo-module.config.json
@@ -1,5 +1,5 @@
-  "platforms": ["ios"],
-  "ios": {
-    "modules": ["MyModule"]
-  }
+  "platforms": ["apple"],
+  "apple": {
+    "modules": ["MyModule"]
+  }
 }
```
Step 2: 
## Update the podspec to declare support for other platforms
The module's podspec needs to be updated with a list of the supported platforms. Otherwise, CocoaPods would fail to install the pod on targets for the other platforms. As mentioned in the first step, this part of the spec is the source of truth for autolinking when the module is configured with a universal `"apple"` platform.
```diff
diff --git a/YourModule.podspec b/YourModule.podspec
index 0000000..1111111 100644
--- a/YourModule.podspec
+++ b/YourModule.podspec
@@ -1,5 +1,5 @@
- s.platform       = :ios, '13.4'
+ s.platforms = {
+   :ios => '13.4',
+   :tvos => '13.4',
+   :osx => '10.15'
+ }
```
Any changes in the podspec require running `pod install` to have an effect.
Step 3: 
## Set up `react-native-macos` or `react-native-tvos` in the app
If you are writing a local module and your app is already set up, you can skip this step. Otherwise, you will need to set up your app or the example app if you are writing a standalone (non-local) module.
- **For macOS**: follow the official [Install React Native for macOS](https://microsoft.github.io/react-native-windows/docs/rnm-getting-started#install-the-macos-extension) guide from `react-native-macos` documentation.
- **For tvOS**: follow the instructions in the [`react-native-tvos`](https://github.com/react-native-tvos/react-native-tvos) repository. If you are building an Expo app, you should also follow the instructions in the [Build Expo apps for TV guide](/guides/building-for-tv/).
Step 4: 
## Review the code for using APIs not supported on these platforms
Platform APIs may differ between Apple platforms. The most noticeable difference comes from relying on different UI frameworks &mdash;`UIKit` on iOS/tvOS and `AppKit` on macOS.
Both `react-native-macos` and `expo-modules-core` provide aliases and polyfills to reference`UIKit` classes on macOS target (for example, `UIView` is an alias to `NSView`, `UIApplication` is an alias to `NSApplication`), but it's usually not enough for iOS-first libraries to support other platforms out of the box. You may need to write conditionally compiled code that uses different implementations depending on the platform.
To do this, use Swift compiler directives with the `os` condition, which includes a given piece of code when our app is being built for a specific platform. In combination with the `#if` and `#else` directives, lets you set up platform-specific branches within the cross-platform code.
```swift
#if os(iOS)
  // iOS implementation
#elseif os(macOS)
  // macOS implementation
#elseif os(tvOS)
  // tvOS implementation
#endif
```
Your module is now ready to be used on Out-of-Tree platform.


# Reference

## Module API Reference

An API reference of Expo modules API.

The native modules API is an abstraction layer on top of [JSI](https://reactnative.dev/architecture/glossary#javascript-interfaces-jsi) and other low-level primitives that React Native is built upon. It is built with modern languages (Swift and Kotlin) and provides an easy-to-use and convenient API that is consistent across platforms where possible.
## Definition components
As you might have noticed in the snippets on the [Get Started](/modules/get-started) page, each module class must implement the `definition` function.
The module definition consists of the DSL components that describe the module's functionality and behavior.
#### Name
Sets the name of the module that JavaScript code will use to refer to the module. Takes a string as an argument. This can be inferred from the module's class name, but it's recommended to set it explicitly for clarity.
```swift Swift / Kotlin
Name("MyModuleName")
```
#### Constant
Defines a constant property on the JavaScript object. The property is computed only once when it's first accessed, and subsequent accesses return the cached value.
```swift
Constant("PI") {
  Double.pi
}
```
```kotlin
Constant("PI") {
  Math.PI
}
```
#### Function
Defines a native synchronous function that will be exported to JavaScript. Synchronous means that when the function is executed in JavaScript, its native code is run on the same thread and blocks further execution of the script until the native function returns.
#### Arguments
- **name**: `String` — Name of the function that you'll call from JavaScript.
- **body**: `(args...) -> ReturnType` — The closure to run when the function is called.
The function can receive up to 8 arguments. This is due to the limitations of generics in both Swift and Kotlin because this component must be implemented separately for each arity.
See the [Argument types](#argument-types) section for more details on what types can be used in the function body.
```swift
Function("mySyncFunction") { (message: String) in
  return message
}
```
```kotlin
Function("mySyncFunction") { message: String ->
  return@Function message
}
```
```js JavaScript
import { requireNativeModule } from 'expo-modules-core';
// Assume that we have named the module "MyModule"
const MyModule = requireNativeModule('MyModule');
function getMessage() {
  return MyModule.mySyncFunction('bar');
}
```
#### AsyncFunction
Defines a JavaScript function that always returns a `Promise` and whose native code is by default dispatched on a different thread than the JavaScript runtime runs on.
#### Arguments
- **name**: `String` — Name of the function that you'll call from JavaScript.
- **body**: `(args...) -> ReturnType` — The closure to run when the function is called.
If the type of the last argument is `Promise`, the function will wait for the promise to be resolved or rejected before the response is passed back to JavaScript. Otherwise, the function is immediately resolved with the returned value or rejected if it throws an exception.
The function can receive up to 8 arguments (including the promise).
See the [Argument types](#argument-types) section for more details on what types can be used in the function body.
It is recommended to use `AsyncFunction` over `Function` when it:
- does I/O bound tasks such as sending network requests or interacting with the file system
- needs to be run on a different thread, for example, the main UI thread for UI-related tasks
- is an extensive or long-lasting operation that would block the JavaScript thread which in turn would reduce the responsiveness of the application
```swift
AsyncFunction("myAsyncFunction") { (message: String) in
  return message
}
// or
AsyncFunction("myAsyncFunction") { (message: String, promise: Promise) in
  promise.resolve(message)
}
```
```kotlin
AsyncFunction("myAsyncFunction") { message: String ->
  return@AsyncFunction message
}
// or
// Make sure to import `Promise` class from `expo.modules.kotlin` instead of `expo.modules.core`.
AsyncFunction("myAsyncFunction") { message: String, promise: Promise ->
  promise.resolve(message)
}
```
```js JavaScript
import { requireNativeModule } from 'expo-modules-core';
// Assume that we have named the module "MyModule"
const MyModule = requireNativeModule('MyModule');
async function getMessageAsync() {
  return await MyModule.myAsyncFunction('bar');
}
```
It is possible to change the native queue of `AsyncFunction` by calling the `.runOnQueue` function on the result of that component.
```swift
AsyncFunction("myAsyncFunction") { (message: String) in
  return message
}.runOnQueue(.main)
```
```kotlin
AsyncFunction("myAsyncFunction") { message: String ->
  return@AsyncFunction message
}.runOnQueue(Queues.MAIN)
```
---
#### Kotlin coroutines <PlatformTags prefix="" platforms={['android']} /
`AsyncFunction` can receive a suspendable body on Android. However, it has to be passed in the infix notation after the `Coroutine` block. You can read more about suspendable functions and coroutines on [coroutine overview](https://kotlinlang.org/docs/coroutines-overview.html).
`AsyncFunction` with a suspendable body can't receive `Promise` as an argument. It uses a suspension mechanism to execute asynchronous calls.
The function is immediately resolved with the returned value of the provided suspendable block or rejected if it throws an exception. The function can receive up to 8 arguments.
By default, suspend functions are dispatched on the module's coroutine scope. Moreover, every other suspendable function called from the body block is run within the same scope.
This scope's lifecycle is bound to the module's lifecycle - all unfinished suspend functions will be canceled when the module is deallocated.
```kotlin Kotlin
AsyncFunction("suspendFunction") Coroutine { message: String ->
  // You can execute other suspendable functions here.
  // For example, you can use `kotlinx.coroutines.delay` to delay resolving the underlying promise.
  delay(5000)
  return@Coroutine message
}
```
#### Events
Defines event names that the module can send to JavaScript.
> **Note:** This component can be used inside of the [`View`](#view) block to define callback names. See [`View callbacks`](#view-callbacks)
```swift
Events("onCameraReady", "onPictureSaved", "onBarCodeScanned")
```
```kotlin
Events("onCameraReady", "onPictureSaved", "onBarCodeScanned")
```
See [Sending events](#sending-events) to learn how to send events from the native code to JavaScript/TypeScript.
#### Property
Defines a new property directly on the JavaScript object that represents a native module. It is the same as calling [`Object.defineProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) on the module object.
To declare a read-only property, you can use a shorthanded syntax that requires two arguments:
- **name**: `String` — Name of the property that you'll use from JavaScript.
- **getter**: `() -> PropertyType` — The closure to run when the getter for a property was called.
```swift
Property("foo") {
  return "bar"
}
```
```kotlin
Property("foo") {
  return@Property "bar"
}
```
In the case of the mutable property, both the getter and the setter closure are needed (using the syntax below is also possible to declare a property with only a setter):
- **name**: `String` — Name of the property that you'll use from JavaScript.
- **getter**: `() -> PropertyType` — The closure to run when the getter for a property was called.
- **setter**: `(newValue: PropertyType) -> void` — The closure to run when the setter for a property was called.
```swift
Property("foo")
  .get { return "bar" }
  .set { (newValue: String) in
    // do something with new value
  }
```
```kotlin
Property("foo")
  .get { return@get "bar" }
  .set { newValue: String ->
    // do something with new value
  }
```
```js JavaScript
import { requireNativeModule } from 'expo-modules-core';
// Assume that we have named the module "MyModule"
const MyModule = requireNativeModule('MyModule');
// Obtain the property value
MyModule.foo;
// Set a new value
MyModule.foo = 'foobar';
```
#### View
Enables the module to be used as a native view. Definition components that are accepted as part of the view definition: [`Prop`](#prop), [`Events`](#events), [`GroupView`](#groupview) and [`AsyncFunction`](#asyncfunction).
[`AsyncFunction`](#asyncfunction) in the view definition is added to the React ref of the React component representing the native view.
Such async functions automatically receive an instance of the native view as the first argument and run on the UI thread by default.
#### Arguments
- **viewType** — The class of the native view that will be rendered. Note: On Android, the provided class must inherit from the [`ExpoView`](#expoview), on iOS it's optional. See [`Extending ExpoView`](#extending--expoview).
- **definition**: `() -> ViewDefinition` — A builder of the view definition.
```swift
View(UITextView.self) {
  AsyncFunction("focus") { (view: UITextView) in
    view.becomeFirstResponder()
  }
}
```
```kotlin
View(TextView::class) {
  AsyncFunction("focus") { view: TextView ->
    view.requestFocus()
  }
}
```
> **Info** Support for rendering SwiftUI views is planned. For now, you can use [`UIHostingController`](https://developer.apple.com/documentation/swiftui/uihostingcontroller) and add its content view to your UIKit view.
#### OnCreate
Defines module's lifecycle listener that is called right after module initialization. If you need to set up something when the module gets initialized, use this instead of module's class initializer.
#### OnDestroy
Defines module's lifecycle listener that is called when the module is about to be deallocated. Use it instead of module's class destructor.
#### OnStartObserving
Defines the function that is invoked when the first event listener is added.
#### OnStopObserving
Defines the function that is invoked when all event listeners are removed.
#### OnAppContextDestroys
Defines module's lifecycle listener that is called when the app context owning the module is about to be deallocated.
#### OnAppEntersForeground, Android only
Defines the listener that is called when the app is about to enter the foreground mode.
> **Note:** This function is not available on Android — you may want to use [`OnActivityEntersForeground`](#onactivityentersforeground) instead.
#### OnAppEntersBackground, Android only
Defines the listener that is called when the app enters the background mode.
> **Note:** This function is not available on Android — you may want to use [`OnActivityEntersBackground`](#onactivityentersbackground) instead.
#### OnAppBecomesActive, Android only
Defines the listener that is called when the app becomes active again (after `OnAppEntersForeground`).
> **Note:** This function is not available on Android — you may want to use [`OnActivityEntersForeground`](#onactivityentersforeground) instead.
#### OnActivityEntersForeground, Android only
Defines the activity lifecycle listener that is called right after the activity is resumed.
> **Note:** This function is not available on iOS — you may want to use [`OnAppEntersForeground`](#onappentersforeground) instead.
#### OnActivityEntersBackground, Android only
Defines the activity lifecycle listener that is called right after the activity is paused.
> **Note:** This function is not available on iOS — you may want to use [`OnAppEntersBackground`](#onappentersbackground) instead.
#### OnActivityDestroys, Android only
Defines the activity lifecycle listener that is called when the activity owning the JavaScript context is about to be destroyed.
> **Note:** This function is not available on iOS — you may want to use [`OnAppEntersBackground`](#onappentersbackground) instead.
#### OnActivityResult, Android only
Defines the activity lifecycle listener that is called when the activity launched with `startActivityForResult` returns a result.
#### Arguments
- **activity** — The Android activity that received the result.
- **payload** — An object containing data about the activity result.
  - **requestCode**: `Int` — The request code originally supplied to `startActivityForResult`, used to identify the source of the result.
  - **resultCode**: `Int` — The result code returned by the child activity (for example, `Activity.RESULT_OK` or `Activity.RESULT_CANCELED`).
  - **data** — An optional intent that carries the result data returned from the launched activity. Can be `null`.
```kotlin Kotlin
AsyncFunction('someFunc') {
  activity.startActivityForResult(someIntent, SOME_REQUEST_CODE)
}
OnActivityResult { activity, payload ->
}
```
#### Constants
> **warning** **Deprecated:** Use [`Constant`](#constant) instead.
Sets constant properties on the module. Can take a dictionary or a closure that returns a dictionary.
```swift
// Created from the dictionary
Constants([
  "PI": Double.pi
])
// or returned by the closure
Constants {
  return [
    "PI": Double.pi
  ]
}
```
```kotlin
// Passed as arguments
Constants(
  "PI" to kotlin.math.PI
)
// or returned by the closure
Constants {
  return@Constants mapOf(
    "PI" to kotlin.math.PI
  )
}
```
## View definition components
The view definition consists of the DSL components that describe the view's functionality and behavior. Those components can only be used within a [`View`](#view) closure.
#### Name
Sets the name of the view that JavaScript code will use to refer to the view. Takes a string as an argument. This can be inferred from the view's class name, but it's recommended to set it explicitly for clarity.
```swift Swift / Kotlin
Name("MyViewName")
```
#### Prop
Defines a setter for the view prop of given name.
#### Arguments
- **name**: `String` — Name of view prop that you want to define a setter.
- **defaultValue**: `ValueType` — Optional default value used when the setter is called with `null`.
- **setter**: `(view: ViewType, value: ValueType) -> ()` — Closure that is invoked when the view rerenders.
This property can only be used within a [`View`](#view) closure.
```swift
Prop("background") { (view: UIView, color: UIColor) in
  view.backgroundColor = color
}
```
```kotlin
Prop("background") { view: View, @ColorInt color: Int ->
  view.setBackgroundColor(color)
}
```
Prop definition with default value.
```swift
Prop("background", UIColor.black) { (view: UIView, color: UIColor) in
  view.backgroundColor = color
}
```
```kotlin
Prop("background", Color.BLACK) { view: View, @ColorInt color: Int ->
  view.setBackgroundColor(color)
}
```
> **Note:** Props of function type (callbacks) are not supported yet.
#### OnViewDidUpdateProps
Defines the view lifecycle method that is called when the view finished updating all props.
```swift
View(MyView.self) {
  OnViewDidUpdateProps { view: MyView in
  }
}
```
```kotlin
View(MyView::class) {
  OnViewDidUpdateProps { view: MyView ->
  }
}
```
#### (View) AsyncFunction
Similarly to the [`AsyncFunction`](#asyncfunction) inside the module definition, you can define functions attached to the view ref to allow direct modification of the native view.
View async functions will always be dispatched on the main queue and can receive the view instance as the first argument.
```swift
View(MyView.self) {
  AsyncFunction("myAsyncFunction") { (view: MyView, message: String) in
    view.displayMessage(message)
  }
}
```
```kotlin
View(MyView::class) {
  AsyncFunction("myAsyncFunction") { view: MyView, message: String ->
    view.displayMessage(message);
  }
}
```
```js JavaScript
const MyNativeView = requireNativeViewManager('MyView');
function MyComponent() {
  const ref = React.useRef(null);
  React.useEffect(() => {
    ref.current?.myAsyncFunction();
  }, [ref]);
  return <MyNativeView ref={ref} />;
}
```
#### GroupView, Android only
Enables the view to be used as a view group. Definition components that are accepted as part of the group view definition: [`AddChildView`](#addchildview), [`GetChildCount`](#getchildcount), [`GetChildViewAt`](#getchildviewat), [`RemoveChildView`](#removechildview), [`RemoveChildViewAt`](#removechildviewat).
#### Arguments
- **viewType** — The class of the native view. Note that the provided class must inherit from the Android `ViewGroup`.
- **definition**: `() -> ViewGroupDefinition` — A builder of the view group definition.
This property can only be used within a [`View`](#view) closure.
```kotlin Kotlin
GroupView<ViewGroup> {
}
```
#### AddChildView, Android only
Defines action that adds a child view to the view group.
#### Arguments
- **action**: `(parent: ParentType, child: ChildType, index: Int) -> ()` — An action that adds a child view to the view group.
This property can only be used within a [`GroupView`](#groupview) closure.
```kotlin Kotlin
AddChildView { parent, child: View, index ->
  parent.addView(child, index)
}
```
#### GetChildCount, Android only
Defines action the retrieves the number of child views in the view group.
#### Arguments
- **action**: `(parent: ParentType) -> Int` — A function that returns number of child views.
This property can only be used within a [`GroupView`](#groupview) closure.
```kotlin Kotlin
GetChildCount { parent ->
  return@GetChildCount parent.childCount
}
```
#### GetChildViewAt, Android only
Defines action that retrieves a child view at a specific index from the view group.
#### Arguments
- **action**: `(parent: ParentType, index: Int) -> ChildType` — A function that retrieves a child view at a specific index from the view group.
This property can only be used within a [`GroupView`](#groupview) closure.
```kotlin Kotlin
GetChildViewAt { parent, index ->
  parent.getChildAt(index)
}
```
#### RemoveChildView, Android only
Defines action that removes a specific child view from the view group.
#### Arguments
- **action**: `(parent: ParentType, child: ChildType) -> ()` — A function that remove a specific child view from the view group.
This property can only be used within a [`GroupView`](#groupview) closure.
```kotlin Kotlin
RemoveChildView { parent, child: View ->
  parent.removeView(child)
}
```
#### RemoveChildViewAt, Android only
Defines action that removes a child view at a specific index from the view group.
#### Arguments
- **action**: `(parent: ParentType, child: ChildType) -> ()` — A function that removes a child view at a specific index from the view group.
This property can only be used within a [`GroupView`](#groupview) closure.
```kotlin Kotlin
RemoveChildViewAt { parent, index ->
  parent.removeViewAt(child)
}
```
## Argument types
Fundamentally, only primitive and serializable data can be passed back and forth between the runtimes. However, usually native modules need to receive custom data structures — more sophisticated than just the dictionary/map where the values are of unknown (`Any`) type and so each value has to be validated and cast on its own. The Expo Modules API provides protocols to make it more convenient to work with data objects, to provide automatic validation, and finally, to ensure native type-safety on each object member.
#### Primitives
All functions and view prop setters accept all common primitive types in Swift and Kotlin as the arguments. This includes arrays, dictionaries/maps and optionals of these primitive types.
| Language | Supported primitive types                                                                                                      |
| -------- | ------------------------------------------------------------------------------------------------------------------------------ |
| Swift    | `Bool`, `Int`, `Int8`, `Int16`, `Int32`, `Int64`, `UInt`, `UInt8`, `UInt16`, `UInt32`, `UInt64`, `Float32`, `Double`, `String` |
| Kotlin   | `Boolean`, `Int`, `Long`, `Float`, `Double`, `String`, `Pair`                                                                  |
#### Convertibles
_Convertibles_ are native types that can be initialized from certain specific kinds of data received from JavaScript. Such types are allowed to be used as an argument type in `Function`'s body. For example, when the `CGPoint` type is used as a function argument type, its instance can be created from an array of two numbers `(x, y)` or a JavaScript object with numeric `x` and `y` properties.
The built-in Convertibles are documented [further below](#built-in-convertibles). You can define additional Convertibles by making native Swift types conform to the `Convertible` protocol:
#### Convertible, Android only
`Convertible` is a Swift protocol with one static method:
<APIMethod
  name="convert"
  comment="A static method that converts a dynamically typed value from JavaScript to an instance of the Swift type conforming to `Convertible`. Implementers should throw an exception when the given value is invalid or of an unsupported type."
  returnTypeName="Self"
  parameters={[
    {
      name: 'value',
      comment: 'A value from JavaScript to convert',
      typeName: 'Any?',
    },
    {
      name: 'appContext',
      comment: 'The context object for the currently running Expo app instance',
      typeName: 'AppContext',
    },
  ]}
/>
### Example
```swift Swift
import ExpoModulesCore
extension CMTime: @retroactive Convertible {
  public static func convert(from value: Any?, appContext: AppContext) throws -> CMTime {
    if let seconds = value as? Double {
      return CMTime(seconds: seconds, preferredTimescale: .max)
    }
    throw Conversions.ConvertingException<CMTime>(value)
  }
}
```
> **Info** Support for defining Convertibles with Kotlin is planned to be available by SDK 53.
---
## Built-in Convertibles
Some common iOS types from the `CoreGraphics` and `UIKit` system frameworks are already made convertible.
| Native iOS Type         | TypeScript                                                                                                                                                                        |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `URL`                   | `string` with a URL. When a scheme is not provided, it's assumed to be a file URL.                                                                                                |
| `CGFloat`               | `number`                                                                                                                                                                          |
| `CGPoint`               | `{ x: number, y: number }` or `number[]` with _x_ and _y_ coords                                                                                                                  |
| `CGSize`                | `{ width: number, height: number }` or `number[]` with _width_ and _height_                                                                                                       |
| `CGVector`              | `{ dx: number, dy: number }` or `number[]` with _dx_ and _dy_ vector differentials                                                                                                |
| `CGRect`                | `{ x: number, y: number, width: number, height: number }` or `number[]` with _x_, _y_, _width_ and _height_ values                                                                |
| `CGColor``UIColor` | Color hex strings (`#RRGGBB`, `#RRGGBBAA`, `#RGB`, `#RGBA`), named colors following the [CSS3/SVG specification](https://www.w3.org/TR/css-color-3/#svg-color) or `"transparent"` |
| `Data`                  | `Uint8Array` <StatusTag note="SDK 50+" />                                                                                                                                         |
---
Similarly, some common Android types from packages like `java.io`, `java.net`, or `android.graphics` are also made convertible.
> **Note:** On Android, primitive arrays should be used whenever possible.
| Native Android Type                                                                       | TypeScript                                                                                                                                                                        |
| ----------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `java.net.URL`                                                                            | `string` with a URL. Note that the scheme has to be provided (URL should not contain any unencoded `%` character)                                                                 |
| `android.net.Uri``java.net.URI`                                                      | `string` with a URI. Note that the scheme has to be provided (URI should not contain any unencoded `%` character)                                                                 |
| `java.io.File``java.nio.file.Path` (is only available on Android API 26)             | `string` with a path to the file                                                                                                                                                  |
| `android.graphics.Color`                                                                  | Color hex strings (`#RRGGBB`, `#RRGGBBAA`, `#RGB`, `#RGBA`), named colors following the [CSS3/SVG specification](https://www.w3.org/TR/css-color-3/#svg-color) or `"transparent"` |
| `kotlin.Pair<A, B>`                                                                       | Array with two values, where the first one is of type _A_ and the second is of type _B_                                                                                           |
| `kotlin.ByteArray`                                                                        | `Uint8Array` <StatusTag note="SDK 50+" />                                                                                                                                         |
| `kotlin.BooleanArray`                                                                     | `boolean[]`                                                                                                                                                                       |
| `kotlin.IntArray``kotlin.FloatArray``kotlin.LongArray``kotlin.DoubleArray` | `number[]`                                                                                                                                                                        |
| `kotlin.time.Duration`                                                                    | `number` represents a duration in seconds <StatusTag note="SDK 52+" />                                                                                                            |
#### Records
_Record_ is a convertible type and an equivalent of the dictionary (Swift) or map (Kotlin), but represented as a struct where each field can have its type and provide a default value.
It is a better way to represent a JavaScript object with the native type safety.
```swift
struct FileReadOptions: Record {
  @Field
  var encoding: String = "utf8"
  @Field
  var position: Int = 0
  @Field
  var length: Int?
}
// Now this record can be used as an argument of the functions or the view prop setters.
Function("readFile") { (path: String, options: FileReadOptions) -> String in
  // Read the file using given `options`
}
```
```kotlin
class FileReadOptions : Record {
  @Field
  val encoding: String = "utf8"
  @Field
  val position: Int = 0
  @Field
  val length: Int? = null
}
// Now this record can be used as an argument of the functions or the view prop setters.
Function("readFile") { path: String, options: FileReadOptions ->
  // Read the file using given `options`
}
```
#### Enums
With enums, we can go even further with the above example (with `FileReadOptions` record) and limit supported encodings to `"utf8"` and `"base64"`. To use an enum as an argument or record field, it must represent a primitive value (for example, `String`, `Int`) and conform to `Enumerable`.
```swift
enum FileEncoding: String, Enumerable {
  case utf8
  case base64
}
struct FileReadOptions: Record {
  @Field
  var encoding: FileEncoding = .utf8
}
```
```kotlin
// Note: the constructor must have an argument called value.
enum class FileEncoding(val value: String) : Enumerable {
  utf8("utf8"),
  base64("base64")
}
class FileReadOptions : Record {
  @Field
  val encoding: FileEncoding = FileEncoding.utf8
}
```
#### Eithers
There are some use cases where you want to pass various types for a single function argument. This is where Either types might come in handy.
They act as a container for a value of one of a couple of types.
```swift
Function("foo") { (bar: Either<String, Int>) in
  if let bar: String = bar.get() {
    // `bar` is a String
  }
  if let bar: Int = bar.get() {
    // `bar` is an Int
  }
}
```
```kotlin
Function("foo") { bar: Either<String, Int> ->
  bar.get(String::class).let {
    // `it` is a String
  }
  bar.get(Int::class).let {
    // `it` is an Int
  }
}
```
The implementation for three Either types is currently provided out of the box, allowing you to use up to four different subtypes.
- `Either<FirstType, SecondType>` — A container for one of two types.
- `EitherOfThree<FirstType, SecondType, ThirdType>` — A container for one of three types.
- `EitherOfFour<FirstType, SecondType, ThirdType, FourthType>` — A container for one of four types.
#### JavaScript values
It's also possible to use a `JavaScriptValue` type which is a holder for any value that can be represented in JavaScript.
This type is useful when you want to mutate the given argument or when you want to omit type validations and conversions.
Note that using JavaScript-specific types is restricted to synchronous functions as all reads and writes in the JavaScript runtime must happen on the JavaScript thread.
Any access to these values from different threads will result in a crash.
In addition to the raw value, the `JavaScriptObject` type can be used to allow only object types and `JavaScriptFunction<ReturnType>` for callbacks.
```swift
Function("mutateMe") { (value: JavaScriptValue) in
  if value.isObject() {
    let jsObject = value.getObject()
    jsObject.setProperty("expo", value: "modules")
  }
}
// or
Function("mutateMe") { (jsObject: JavaScriptObject) in
  jsObject.setProperty("expo", value: "modules")
}
```
```kotlin
Function("mutateMe") { value: JavaScriptValue ->
  if (value.isObject()) {
    val jsObject = value.getObject()
    jsObject.setProperty("expo", "modules")
  }
}
// or
Function("mutateMe") { jsObject: JavaScriptObject ->
  jsObject.setProperty("expo", "modules")
}
```
## Native classes
#### Module
A base class for a native module.
#### Properties
<APIMethod
  name="appContext"
  comment="Provides access to the [`AppContext`](#appcontext)."
  returnTypeName="AppContext"
  isProperty
  isReturnTypeReference
/>
#### Methods
<APIMethod
  name="sendEvent"
  comment="Sends an event with a given name and a payload to JavaScript. See [`Sending events`](#sending-events)"
  returnTypeName="void"
  parameters={[
    {
      name: 'eventName',
      comment: 'The name of the JavaScript event',
      typeName: 'string',
    },
    {
      name: 'payload',
      comment: 'The event payload',
      typeName: 'Android: Map<String, Any?> | Bundle\niOS: [String: Any?]',
    },
  ]}
/>
#### AppContext
The app context is an interface to a single Expo app.
#### Properties
<APIMethod
  name="constants"
  comment="Provides access to app's constants from legacy module registry."
  returnTypeName="Android: ConstantsInterface? iOS: EXConstantsInterface?"
  isProperty
/>
<APIMethod
  name="permissions"
  comment="Provides access to the permissions manager from legacy module registry."
  returnTypeName="Android: Permissions? iOS: EXPermissionsInterface?"
  isProperty
/>
<APIMethod
  name="imageLoader"
  comment="Provides access to the image loader from the legacy module registry."
  returnTypeName="Android: ImageLoaderInterface? iOS: EXImageLoaderInterface?"
  isProperty
/>
<APIMethod
  name="barcodeScanner"
  comment="Provides access to the bar code scanner manager from the legacy module registry."
  returnTypeName="ImageLoaderInterface?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="camera"
  comment="Provides access to the camera view manager from the legacy module registry."
  returnTypeName="CameraViewInterface?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="font"
  comment="Provides access to the font manager from the legacy module registry."
  returnTypeName="FontManagerInterface?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="sensor"
  comment="Provides access to the sensor manager from the legacy module registry."
  returnTypeName="SensorServiceInterface?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="taskManager"
  comment="Provides access to the task manager from the legacy module registry."
  returnTypeName="TaskManagerInterface?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="activityProvider"
  comment="Provides access to the activity provider from the legacy module registry."
  returnTypeName="ActivityProvider?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="reactContext"
  comment="Provides access to the react application context."
  returnTypeName="Context?"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="hasActiveReactInstance"
  comment="Checks if there is an not-null, alive react native instance."
  returnTypeName="Boolean"
  isProperty
  platforms={['Android']}
/>
<APIMethod
  name="utilities"
  comment="Provides access to the utilities from legacy module registry."
  returnTypeName="EXUtilitiesInterface?"
  isProperty
  platforms={['iOS']}
/>
#### ExpoView
A base class that should be used by all exported views.
On iOS, `ExpoView` extends the `RCTView` which handles some styles (for example, borders) and accessibility.
#### Properties
<APIMethod
  name="appContext"
  comment="Provides access to the [`AppContext`](#appcontext)."
  returnTypeName="AppContext"
  isProperty
  isReturnTypeReference
/>
#### Extending `ExpoView`
To export your view using the [`View`](#view) component, your custom class must inherit from the `ExpoView`. By doing that you will get access to the [`AppContext`](#appcontext) object. It's the only way of communicating with other modules and the JavaScript runtime. Also, you can't change constructor parameters, because provided view will be initialized by `expo-modules-core`.
```swift
class LinearGradientView: ExpoView {}
public class LinearGradientModule: Module {
  public func definition() -> ModuleDefinition {
    View(LinearGradientView.self) {
    }
  }
}
```
```kotlin
class LinearGradientView(
  context: Context,
  appContext: AppContext,
) : ExpoView(context, appContext)
class LinearGradientModule : Module() {
  override fun definition() = ModuleDefinition {
    View(LinearGradientView::class) {
    }
  }
}
```
## Guides
### Sending events
While JavaScript/TypeScript to Native communication is mostly covered by native functions, you might also want to let the JavaScript/TypeScript code know about certain system events, for example, when the clipboard content changes.
To do this, in the module definition, you need to provide the event names that the module can send using the [Events](#events) definition component. After that, you can use the `sendEvent(eventName, payload)` function on the module instance to send the actual event with some payload. For example, a minimal clipboard implementation that sends native events may look like this:
```swift
let CLIPBOARD_CHANGED_EVENT_NAME = "onClipboardChanged"
public class ClipboardModule: Module {
  public func definition() -> ModuleDefinition {
    Events(CLIPBOARD_CHANGED_EVENT_NAME)
    OnStartObserving {
      NotificationCenter.default.addObserver(
        self,
        selector: #selector(self.clipboardChangedListener),
        name: UIPasteboard.changedNotification,
        object: nil
      )
    }
    OnStopObserving {
      NotificationCenter.default.removeObserver(
        self,
        name: UIPasteboard.changedNotification,
        object: nil
      )
    }
  }
  @objc
  private func clipboardChangedListener() {
    sendEvent(CLIPBOARD_CHANGED_EVENT_NAME, [
      "contentTypes": availableContentTypes()
    ])
  }
}
```
```kotlin
const val CLIPBOARD_CHANGED_EVENT_NAME = "onClipboardChanged"
class ClipboardModule : Module() {
  override fun definition() = ModuleDefinition {
    Events(CLIPBOARD_CHANGED_EVENT_NAME)
    OnStartObserving {
      clipboardManager?.addPrimaryClipChangedListener(listener)
    }
    OnStopObserving {
      clipboardManager?.removePrimaryClipChangedListener(listener)
    }
  }
  private val clipboardManager: ClipboardManager?
    get() = appContext.reactContext?.getSystemService(Context.CLIPBOARD_SERVICE) as? ClipboardManager
  private val listener = ClipboardManager.OnPrimaryClipChangedListener {
    clipboardManager?.primaryClipDescription?.let { clip ->
      this@ClipboardModule.sendEvent(
        CLIPBOARD_CHANGED_EVENT_NAME,
        bundleOf(
          "contentTypes" to availableContentTypes(clip)
        )
      )
    }
  }
}
```
To subscribe to these events in JavaScript/TypeScript, use [`addListener`](/versions/latest/sdk/expo/#addlistenereventname-listener) on the module object returned by `requireNativeModule`. Modules are extending the built-in [`EventEmitter`](/versions/latest/sdk/expo/#eventemitter) class.
Alternatively, you can use [`useEvent`](/versions/latest/sdk/expo/#useeventeventemitter-eventname-initialvalue) or [`useEventListener`](/versions/latest/sdk/expo/#useeventlistenereventemitter-eventname-listener) hooks.
```ts TypeScript
import { requireNativeModule, NativeModule } from 'expo';
type ClipboardChangeEvent = {
  contentTypes: string[];
};
type ClipboardModuleEvents = {
  onClipboardChanged(event: ClipboardChangeEvent): void;
};
declare class ClipboardModule extends NativeModule<ClipboardModuleEvents> {}
const Clipboard = requireNativeModule<ClipboardModule>('Clipboard');
Clipboard.addListener('onClipboardChanged', (event: ClipboardChangeEvent) => {
  alert('Clipboard has changed');
});
```
### View callbacks
Some events are connected to a certain view. For example, the touch event should be sent only to the underlying JavaScript view which was pressed. In that case, you can't use `sendEvent` described in [`Sending events`](#sending-events). The `expo-modules-core` introduces a view callbacks mechanism to handle view-bound events.
To use it, in the view definition, you need to provide the event names that the view can send using the [Events](#events) definition component. After that, you need to declare a property of type `EventDispatcher` in your view class. The name of the declared property has to be the same as the name exported in the `Events` component. Later, you can call it as a function and pass a payload of type `[String: Any?]` on iOS and `Map<String, Any?>` on Android.
> **Note:**: On Android, it's possible to specify the payload type. In case of types that don't convert into objects, the payload will be encapsulated and stored under the `payload` key: `{payload: <provided value>}`.
```swift
class CameraViewModule: Module {
  public func definition() -> ModuleDefinition {
    View(CameraView.self) {
      Events(
        "onCameraReady"
      )
    }
  }
}
class CameraView: ExpoView {
  let onCameraReady = EventDispatcher()
  func callOnCameraReady() {
    onCameraReady([
      "message": "Camera was mounted"
    ]);
  }
}
```
```kotlin
class CameraViewModule : Module() {
  override fun definition() = ModuleDefinition {
    View(ExpoCameraView::class) {
      Events(
        "onCameraReady"
      )
    }
  }
}
class CameraView(
  context: Context,
  appContext: AppContext
) : ExpoView(context, appContext) {
  val onCameraReady by EventDispatcher()
  fun callOnCameraReady() {
    onCameraReady(mapOf(
      "message" to "Camera was mounted"
    ));
  }
}
```
To subscribe to these events in JavaScript/TypeScript, you need to pass a function to the native view as shown:
```tsx TypeScript
import { requireNativeViewManager } from 'expo-modules-core';
const CameraView = requireNativeViewManager('CameraView');
export default function MainView() {
  const onCameraReady = event => {
    console.log(event.nativeEvent);
  };
  return <CameraView onCameraReady={onCameraReady} />;
}
```
Provided payload is available under the `nativeEvent` key.
## Examples
```swift
public class MyModule: Module {
  public func definition() -> ModuleDefinition {
    Name("MyFirstExpoModule")
    Function("hello") { (name: String) in
      return "Hello \(name)!"
    }
  }
}
```
```kotlin
class MyModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("MyFirstExpoModule")
    Function("hello") { name: String ->
      return "Hello $name!"
    }
  }
}
```
For more examples from real modules, you can refer to Expo modules that already use this API on GitHub:
```
├── expo-battery  # Swift
├── expo-cellular  # "Kotlin" , "Swift"
├── expo-clipboard  # "Kotlin" , "Swift"
├── expo-crypto  # "Kotlin" , "Swift"
├── expo-device  # Swift
├── expo-haptics  # Swift
├── expo-image-manipulator  # Swift
├── expo-image-picker  # "Kotlin" , "Swift"
├── expo-linear-gradient  # "Kotlin" ,{' '} "Swift"
├── expo-localization  # "Kotlin" , "Swift"
├── expo-store-review  # Swift
├── expo-system-ui  # Swift
├── expo-video-thumbnails  # Swift
└── expo-web-browser  # "Kotlin" , "Swift"
```


## Android lifecycle listeners

Learn about the mechanism that allows your library to hook into Android Activity and Application functions using Expo modules API.

To respond to certain Android system events relevant to an app, such as inbound links and configuration changes, it is necessary to override the corresponding lifecycle callbacks in **MainActivity.java** and/or **MainApplication.java**.
The React Native module API does not provide any mechanism to hook into these, and so setup instructions for React Native libraries often include steps to copy code into these files. To simplify and automate setup and maintenance, the Expo Modules API provides a mechanism that allows your library to hook into `Activity` or `Application` functions.
## Get started
First, you need to have created an Expo module or integrated the Expo modules API in the library using the React Native module API. [Learn more](./overview.mdx#setup).
Inside your module, create a concrete class that implements the [`Package`](https://github.com/expo/expo/tree/main/packages/expo-modules-core/android/src/main/java/expo/modules/core/interfaces/Package.java) interface. For most cases, you only need to implement the `createReactActivityLifecycleListeners` or `createApplicationLifecycleListeners` methods.
## `Activity` lifecycle listeners
You can hook into the `Activity` lifecycle using `ReactActivityLifecycleListener`. `ReactActivityLifecycleListener` hooks into React Native's `ReactActivity` lifecycle using its `ReactActivityDelegate` and provides a similar experience to the Android `Activity` lifecycle.
The following `Activity` lifecycle callbacks are currently supported:
- `onCreate`
- `onResume`
- `onPause`
- `onDestroy`
- `onNewIntent`
- `onBackPressed`
To create a `ReactActivityLifecycleListener`, you should implement `createReactActivityLifecycleListeners` in your derived `Package` class. For example, `MyLibPackage`.
```kotlin
// android/src/main/java/expo/modules/mylib/MyLibPackage.kt
package expo.modules.mylib
import android.content.Context
import expo.modules.core.interfaces.Package
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class MyLibPackage : Package {
  override fun createReactActivityLifecycleListeners(activityContext: Context): List<ReactActivityLifecycleListener> {
    return listOf(MyLibReactActivityLifecycleListener())
  }
}
```
```java
// android/src/main/java/expo/modules/mylib/MyLibPackage.java
package expo.modules.mylib;
import android.content.Context;
import expo.modules.core.interfaces.Package;
import expo.modules.core.interfaces.ReactActivityLifecycleListener;
import java.util.Collections;
import java.util.List;
public class MyLibPackage implements Package {
  @Override
  public List<? extends ReactActivityLifecycleListener> createReactActivityLifecycleListeners(Context activityContext) {
    return Collections.singletonList(new MyLibReactActivityLifecycleListener());
  }
}
```
`MyLibReactActivityLifecycleListener` is a `ReactActivityLifecycleListener` derived class that you can hook into the lifecycles. You can only override the methods you need.
```kotlin
// android/src/main/java/expo/modules/mylib/MyLibReactActivityLifecycleListener.kt
package expo.modules.mylib
import android.app.Activity
import android.os.Bundle
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class MyLibReactActivityLifecycleListener : ReactActivityLifecycleListener {
  override fun onCreate(activity: Activity, savedInstanceState: Bundle?) {
    // Your setup code in `Activity.onCreate`.
    doSomeSetupInActivityOnCreate(activity)
  }
}
```
```java
// android/src/main/java/expo/modules/mylib/MyLibReactActivityLifecycleListener.java
package expo.modules.mylib;
import android.app.Activity;
import android.os.Bundle;
import expo.modules.core.interfaces.ReactActivityLifecycleListener;
public class MyLibReactActivityLifecycleListener implements ReactActivityLifecycleListener {
  @Override
  public void onCreate(Activity activity, Bundle savedInstanceState) {
    // Your setup code in `Activity.onCreate`.
    doSomeSetupInActivityOnCreate(activity);
  }
}
```
You can also override other lifecycle methods. The example below shows how to override multiple lifecycle methods in a single listener class. It is based on `expo-linking` module, which uses different lifecycle methods to handle deep links. You can implement only the methods you need for your use case:
```kotlin
// android/src/main/java/expo/modules/mylib/MyLibReactActivityLifecycleListener.kt
package expo.modules.mylib
import android.app.Activity
import android.content.Intent
import android.os.Bundle
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class MyLibReactActivityLifecycleListener : ReactActivityLifecycleListener {
  override fun onCreate(activity: Activity?, savedInstanceState: Bundle?) {
    // Called when the activity is first created
    // Initialize your setup here, for example handling deep links
    val deepLinkUrl = activity?.intent?.data
    if (deepLinkUrl != null) {
      handleDeepLink(deepLinkUrl.toString())
    }
  }
  override fun onResume(activity: Activity) {
    // Called when the activity comes to the foreground
    // For example, track when user returns to the app
    trackAppStateChange("active")
  }
  override fun onPause(activity: Activity) {
    // Called when the activity goes to the background
    // For example, pause ongoing operations such as track analytics
    trackAppStateChange("inactive")
  }
  override fun onDestroy(activity: Activity) {
    // Called when the activity is being destroyed
    // Clean up resources here
    cleanup()
  }
  override fun onNewIntent(intent: Intent?): Boolean {
    // Called when app receives a new intent while already running
    // For example, handle new deep links while app is open
    val newUrl = intent?.data
    if (newUrl != null) {
      handleDeepLink(newUrl.toString())
      return true
    }
    return false
  }
  override fun onBackPressed(): Boolean {
    // Called when user presses the back button
    // Return true to prevent default back behavior
    return handleCustomBackNavigation()
  }
  // Now, you can add private functions to handle
  // your logic for deep links, app state tracking, clean up, and so on.
}
```
```java
// android/src/main/java/expo/modules/mylib/MyLibReactActivityLifecycleListener.java
package expo.modules.mylib;
import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import expo.modules.core.interfaces.ReactActivityLifecycleListener;
public class MyLibReactActivityLifecycleListener implements ReactActivityLifecycleListener {
  @Override
  public void onCreate(Activity activity, Bundle savedInstanceState) {
    // Called when the activity is first created
    // Initialize your setup here, for example handling deep links
    Uri deepLinkUrl = activity.getIntent().getData();
    if (deepLinkUrl != null) {
      handleDeepLink(deepLinkUrl.toString());
    }
  }
  @Override
  public void onResume(Activity activity) {
    // Called when the activity comes to the foreground
    // For example, track when user returns to the app
    trackAppStateChange("active");
  }
  @Override
  public void onPause(Activity activity) {
    // Called when the activity goes to the background
    // For example, pause ongoing operations such as track analytics
    trackAppStateChange("inactive");
  }
  @Override
  public void onDestroy(Activity activity) {
    // Called when the activity is being destroyed
    // Clean up resources here
    cleanup();
  }
  @Override
  public boolean onNewIntent(Intent intent) {
    // Called when app receives a new intent while already running
    // For example, handle new deep links while app is open
    Uri newUrl = intent.getData();
    if (newUrl != null) {
      handleDeepLink(newUrl.toString());
      return true;
    }
    return false;
  }
  @Override
  public boolean onBackPressed() {
    // Called when user presses the back button
    // Return true to prevent default back behavior
    return handleCustomBackNavigation();
  }
  // Now, you can add private functions to handle
  // your logic for deep links, app state tracking, clean up, and so on.
}
```
## Lifecycle listeners to JavaScript event flow
Lifecycle listeners are singleton classes that exist independently of your Expo module instances. To communicate between a lifecycle listener and your module (for example, to send events to your app's JavaScript code), you need to observe events from your module and notify the lifecycle listener when events occur. A typical flow may consist of the following steps:
- **System integration**: Lifecycle listeners capture Android intents with URL data
- **Observer pattern**: Singleton lifecycle listeners communicate with module instances
- **Event bridging**: Module sends structured events to JavaScript
- **Memory management**: Weak references prevent memory leaks
- **Type safety and React integration**: TypeScript support with proper event types and a custom hook provides easy access to deep link events
Your custom module implementation might not need all of the above from the event flow. However, you can adapt this pattern for other system events like app state changes, configuration changes, or custom business logic that needs to bridge Android lifecycle events to your React Native app.
The following example demonstrates how to use lifecycle listeners to bridge Android system events to your React Native app. It is based on [`expo-linking`](https://github.com/expo/expo/tree/main/packages/expo-linking), which uses lifecycle listeners to create a deep link handler that captures URLs when an app is opened or receives new intents.
Step 1: 
### Module registration
Start by creating a module class that registers your lifecycle listener:
```kotlin
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerPackage.kt
package expo.modules.deeplinkhandler
import android.content.Context
import expo.modules.core.interfaces.Package
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class DeepLinkHandlerPackage : Package {
  override fun createReactActivityLifecycleListeners(activityContext: Context?): List<ReactActivityLifecycleListener> {
    return listOf(DeepLinkHandlerActivityLifecycleListener())
  }
}
```
```java
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerPackage.java
package expo.modules.deeplinkhandler;
import android.content.Context;
import expo.modules.core.interfaces.Package;
import expo.modules.core.interfaces.ReactActivityLifecycleListener;
import java.util.Collections;
import java.util.List;
public class DeepLinkHandlerPackage implements Package {
  @Override
  public List<? extends ReactActivityLifecycleListener> createReactActivityLifecycleListeners(Context activityContext) {
    return Collections.singletonList(new DeepLinkHandlerActivityLifecycleListener());
  }
}
```
Step 2: 
### Activity lifecycle listener with observer notifications
Create a lifecycle listener that captures deep links and notifies the module observers:
```kotlin
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerActivityLifecycleListener.kt
package expo.modules.deeplinkhandler
import android.app.Activity
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import expo.modules.core.interfaces.ReactActivityLifecycleListener
class DeepLinkHandlerActivityLifecycleListener : ReactActivityLifecycleListener {
  override fun onCreate(activity: Activity?, savedInstanceState: Bundle?) {
    handleIntent(activity?.intent)
  }
  override fun onNewIntent(intent: Intent?): Boolean {
    handleIntent(intent)
    return true
  }
  private fun handleIntent(intent: Intent?) {
    val url = intent?.data
    if (url != null) {
      // Store the initial URL for later retrieval
      DeepLinkHandlerModule.initialUrl = url
      // Notify all observers about the new deep link
      DeepLinkHandlerModule.urlReceivedObservers.forEach { observer ->
        observer(url)
      }
    }
  }
}
```
```java
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerActivityLifecycleListener.java
package expo.modules.deeplinkhandler;
import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import expo.modules.core.interfaces.ReactActivityLifecycleListener;
public class DeepLinkHandlerActivityLifecycleListener implements ReactActivityLifecycleListener {
  @Override
  public void onCreate(Activity activity, Bundle savedInstanceState) {
    handleIntent(activity.getIntent());
  }
  @Override
  public boolean onNewIntent(Intent intent) {
    handleIntent(intent);
    return true;
  }
  private void handleIntent(Intent intent) {
    if (intent == null) return;
    Uri url = intent.getData();
    if (url != null) {
      // Store the initial URL for later retrieval
      DeepLinkHandlerModule.initialUrl = url;
      // Notify all observers about the new deep link
      for (java.util.function.Consumer<Uri> observer : DeepLinkHandlerModule.urlReceivedObservers) {
        observer.accept(url);
      }
    }
  }
}
```
Step 3: 
### Expo module with event sending
Create a module that maintains observers and sends events to JavaScript:
```kotlin
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerModule.kt
package expo.modules.deeplinkhandler
import android.net.Uri
import androidx.core.os.bundleOf
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import java.lang.ref.WeakReference
class DeepLinkHandlerModule : Module() {
  companion object {
    var initialUrl: Uri? = null
    var urlReceivedObservers: MutableSet<((Uri) -> Unit)> = mutableSetOf()
  }
  private var urlReceivedObserver: ((Uri) -> Unit)? = null
  override fun definition() = ModuleDefinition {
    Name("DeepLinkHandler")
    Events("onUrlReceived")
    Function("getInitialUrl") {
      initialUrl?.toString()
    }
    OnStartObserving("onUrlReceived") {
      val weakModule = WeakReference(this@DeepLinkHandlerModule)
      val observer: (Uri) -> Unit = { uri ->
        weakModule.get()?.sendEvent(
          "onUrlReceived",
          bundleOf(
            "url" to uri.toString(),
            "scheme" to uri.scheme,
            "host" to uri.host,
            "path" to uri.path
          )
        )
      }
      urlReceivedObservers.add(observer)
      urlReceivedObserver = observer
    }
    OnStopObserving("onUrlReceived") {
      urlReceivedObservers.remove(urlReceivedObserver)
    }
  }
}
```
```java
// android/src/main/java/expo/modules/deeplinkhandler/DeepLinkHandlerModule.java
package expo.modules.deeplinkhandler;
import android.net.Uri;
import androidx.core.os.Bundle;
import expo.modules.kotlin.modules.Module;
import expo.modules.kotlin.modules.ModuleDefinition;
import java.lang.ref.WeakReference;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;
public class DeepLinkHandlerModule extends Module {
  public static Uri initialUrl = null;
  public static Set<Consumer<Uri>> urlReceivedObservers = new HashSet<>();
  private Consumer<Uri> urlReceivedObserver;
  @Override
  public ModuleDefinition definition() {
    return ModuleDefinition.create()
      .name("DeepLinkHandler")
      .events("onUrlReceived")
      .function("getInitialUrl", () -> {
        return initialUrl != null ? initialUrl.toString() : null;
      })
      .onStartObserving("onUrlReceived", () -> {
        WeakReference<DeepLinkHandlerModule> weakModule = new WeakReference<>(this);
        Consumer<Uri> observer = uri -> {
          DeepLinkHandlerModule module = weakModule.get();
          if (module != null) {
            Bundle bundle = new Bundle();
            bundle.putString("url", uri.toString());
            bundle.putString("scheme", uri.getScheme());
            bundle.putString("host", uri.getHost());
            bundle.putString("path", uri.getPath());
            module.sendEvent("onUrlReceived", bundle);
          }
        };
        urlReceivedObservers.add(observer);
        urlReceivedObserver = observer;
      })
      .onStopObserving("onUrlReceived", () -> {
        urlReceivedObservers.remove(urlReceivedObserver);
      });
  }
}
```
Step 4: 
### TypeScript interface and React usage
Define a TypeScript interface for your module to bridge the Android lifecycle events to JavaScript:
```ts DeepLinkHandler.ts
import { requireNativeModule, NativeModule } from 'expo-modules-core';
export type DeepLinkEvent = {
  url: string;
  scheme?: string;
  host?: string;
  path?: string;
};
type DeepLinkHandlerModuleEvents = {
  onUrlReceived(event: DeepLinkEvent): void;
};
declare class DeepLinkHandlerNativeModule extends NativeModule<DeepLinkHandlerModuleEvents> {
  getInitialUrl(): string | null;
}
const DeepLinkHandler = requireNativeModule<DeepLinkHandlerNativeModule>('DeepLinkHandler');
export default DeepLinkHandler;
```
Create a React hook for an easy access to the deep link events:
```tsx useDeepLinkHandler.ts
import { useEffect, useState } from 'react';
import DeepLinkHandler, { DeepLinkEvent } from './DeepLinkHandler';
export function useDeepLinkHandler(): {
  initialUrl: string | null;
  url: string | null;
  event: DeepLinkEvent | null;
} {
  const [initialUrl] = useState<string | null>(DeepLinkHandler.getInitialUrl());
  const [event, setEvent] = useState<DeepLinkEvent | null>(null);
  useEffect(() => {
    const subscription = DeepLinkHandler.addListener('onUrlReceived', event => {
      setEvent(event);
    });
    return () => subscription.remove();
  }, []);
  return {
    initialUrl,
    url: event?.url ?? initialUrl,
    event,
  };
}
```
Use it in your React component:
```tsx App.tsx
import { Text, View, StyleSheet } from 'react-native';
import { useDeepLinkHandler } from './useDeepLinkHandler';
export function App() {
  const { initialUrl, url, event } = useDeepLinkHandler();
  return (
    <View style={styles.container}>
      <Text>Initial URL: {initialUrl || 'None'}</Text>
      <Text>Current URL: {url || 'None'}</Text>
      {event && (
        <View style={styles.textContainer}>
          <Text>Latest Deep Link:</Text>
          <Text>Scheme: {event.scheme}</Text>
          <Text>Host: {event.host}</Text>
          <Text>Path: {event.path}</Text>
        </View>
      )}
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  textContainer: {
    marginTop: 20,
  },
});
```
Step 5: 
### Module configuration
Finally, configure your module in **expo-module.config.json** to connect the module to the lifecycle listener:
```json expo-module.config.json
{
  "platforms": ["android"],
  "android": {
    "modules": ["expo.modules.deeplinkhandler.DeepLinkHandlerModule"]
  }
}
```
## `Application` lifecycle listeners
You can hook into the `Application` lifecycle using `ApplicationLifecycleListener`.
The following `Application` lifecycle callbacks are currently supported:
- `onCreate`
- `onConfigurationChanged`
To create an `ApplicationLifecycleListener`, you should implement `createApplicationLifecycleListeners` in your derived `Package` class. For example, `MyLibPackage`.
```kotlin
// android/src/main/java/expo/modules/mylib/MyLibPackage.kt
package expo.modules.mylib
import android.content.Context
import expo.modules.core.interfaces.ApplicationLifecycleListener
import expo.modules.core.interfaces.Package
class MyLibPackage : Package {
  override fun createApplicationLifecycleListeners(context: Context): List<ApplicationLifecycleListener> {
    return listOf(MyLibApplicationLifecycleListener())
  }
}
```
```java
// android/src/main/java/expo/modules/mylib/MyLibPackage.java
import android.content.Context;
import java.util.Collections;
import java.util.List;
import expo.modules.core.interfaces.ApplicationLifecycleListener;
import expo.modules.core.interfaces.Package;
public class MyLibPackage implements Package {
  @Override
  public List<? extends ApplicationLifecycleListener> createApplicationLifecycleListeners(Context context) {
    return Collections.singletonList(new MyLibApplicationLifecycleListener());
  }
}
```
`MyLibApplicationLifecycleListener` is an `ApplicationLifecycleListener` derived class that can hook into the `Application` lifecycle callbacks. You should only override the methods you need ([due to possible maintenance costs](#interface-stability)).
```kotlin
// android/src/main/java/expo/modules/mylib/MyLibApplicationLifecycleListener.kt
package expo.modules.mylib
import android.app.Application
import expo.modules.core.interfaces.ApplicationLifecycleListener
class MyLibApplicationLifecycleListener : ApplicationLifecycleListener {
  override fun onCreate(application: Application) {
    // Your setup code in `Application.onCreate`.
    doSomeSetupInApplicationOnCreate(application)
  }
}
```
```java
// android/src/main/java/expo/modules/mylib/MyLibApplicationLifecycleListener.java
package expo.modules.mylib;
import android.app.Application;
import expo.modules.core.interfaces.ApplicationLifecycleListener;
public class MyLibApplicationLifecycleListener implements ApplicationLifecycleListener {
  @Override
  public void onCreate(Application application) {
    // Your setup code in `Application.onCreate`.
    doSomeSetupInApplicationOnCreate(application);
  }
}
```
## Known issues
### Why there are no `onStart` and `onStop` Activity listeners
In the current implementation, we do not set up the hooks from `MainActivity` but from [`ReactActivityDelegate`](https://github.com/facebook/react-native/blob/400902093aa3ccfc05712a996c592a86f342253a/ReactAndroid/src/main/java/com/facebook/react/ReactActivityDelegate.java). There are some slight differences between `MainActivity` and `ReactActivityDelegate`. Since `ReactActivityDelegate` does not have `onStart` and `onStop`, we don't yet support them here.
### Interface stability
The listener interfaces may change from time to time between Expo SDK releases. Our strategy for backward compatibility is always to add new interfaces and add `@Deprecated` annotation for interfaces we plan to remove. Our interfaces are all based on Java 8 interface default method; you don't have to and should not implement all methods. Doing this will benefit your module's maintenance cost between Expo SDKs.


## iOS AppDelegate subscribers

Learn how to subscribe to iOS system events relevant to an app, such as inbound links and notifications using Expo modules API.

To respond to certain iOS system events relevant to an app, such as inbound links and notifications, it is necessary to handle the corresponding methods in the `AppDelegate`.
The React Native module API does not provide any mechanism to hook into these methods, and so setup instructions for React Native libraries often include a step to copy code into the `AppDelegate` file. To simplify and automate setup and maintenance, the Expo Modules API provides a mechanism that allows your library to subscribe to calls to `AppDelegate` functions. For this to work, the app `AppDelegate` must inherit from `ExpoAppDelegate`, and this is a requirement for using Expo Modules.
`ExpoAppDelegate` implements most functions from [`UIApplicationDelegate`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate) protocol and forwards their calls to all the subscribers.
## Get started
First, you need to have created an Expo module or integrated the Expo modules API in library using the React Native module API. [Learn more](./overview.mdx#setup).
Create a new public Swift class that extends `ExpoAppDelegateSubscriber` from `ExpoModulesCore` and add its name to the `apple.appDelegateSubscribers` array in the [module config](/modules/module-config/). Run `pod install`, and the subscriber will be generated in the **ExpoModulesProvider.swift** file within the application project.
Now you can subscribe to events by adding delegate functions to your subscriber class. For the full list of functions that you can subscribe to, see the functions that are overridden in [`ExpoAppDelegate.swift`](https://github.com/expo/expo/blob/main/packages/expo/ios/AppDelegates/ExpoAppDelegate.swift). App delegate functions that may cause side effects when provided are not supported yet (for example, [`application(_:viewControllerWithRestorationIdentifierPath:coder:)`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623062-application)).
> Objective-C classes are not supported.
## Result values
Delegate functions that need to return a value have some additional logic to reconcile responses from multiple subscribers and try to satisfy all of them. There are two good examples of such edge cases:
#### `application(_:didFinishLaunchingWithOptions:) -> Bool`
According to the [Apple documentation](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application), you should return `false` if the app cannot handle the URL resource or continue a user activity, otherwise `true` should be returned. The return value is ignored if the app is launched because of a remote notification.
In such situations, if at least one of the subscribers returns `true`, the `ExpoAppDelegate` will return `true` as well.
#### `application(_:didReceiveRemoteNotification:fetchCompletionHandler:)`
This method tells the app delegate that a remote notification arrived and gives the app the opportunity to fetch new data. It receives a completion block to execute when the fetch operation is completed. This block should be called with the fetch result value that best describes the results of your fetch request. Possible values are: `UIBackgroundFetchResult.newData`, `UIBackgroundFetchResult.noData` or `UIBackgroundFetchResult.failed`.
In this scenario, `ExpoAppDelegate` passes a new completion block to each subscriber, waits until all are completed and collects the results before calling the original completion block. The final result depends on the results collected from the subscribers, as follows in the following order:
- If at least one subscriber called the completion block with `failed` result, the delegate returns `failed` as well.
- If there is at least one `newData` result, the delegate returns `newData`.
- Otherwise `noData` is returned.
> To check out how other functions process the result of your subscriber, we recommend reading the code directly: [`ExpoAppDelegate.swift`](https://github.com/expo/expo/blob/main/packages/expo/ios/AppDelegates/ExpoAppDelegate.swift).
## Example
```swift AppLifecycleDelegate.swift
import ExpoModulesCore
public class AppLifecycleDelegate: ExpoAppDelegateSubscriber {
  public func applicationDidBecomeActive(_ application: UIApplication) {
    // The app has become active.
  }
  public func applicationWillResignActive(_ application: UIApplication) {
    // The app is about to become inactive.
  }
  public func applicationDidEnterBackground(_ application: UIApplication) {
    // The app is now in the background.
  }
  public func applicationWillEnterForeground(_ application: UIApplication) {
    // The app is about to enter the foreground.
  }
  public func applicationWillTerminate(_ application: UIApplication) {
    // The app is about to terminate.
  }
  public func applicationDidReceiveMemoryWarning(_ application: UIApplication) {
    // The app has received a memory warning.
  }
}
```
```json expo-module.config.json
{
  "apple": {
    "appDelegateSubscribers": ["AppLifecycleDelegate"]
  }
}
```


## Autolinking

Learn how to use Expo Autolinking to automatically link native dependencies in your Expo project.

Usually, when you're developing a native mobile app and want to install a third-party library, you're asked to add the dependency to the manifest files of your package managers (**build.gradle** on Android, **Podfile** for CocoaPods on iOS, **Package.swift** for SwiftPM on iOS).
In Expo and React Native, you already do that with your **package.json** file by installing the package from the [npm](https://www.npmjs.com) registry. Since most of the React Native libraries come with some native (platform-specific) code,
installing a library will require configuring even up to three different package managers!
Expo Autolinking is a mechanism that automates this process and reduces the library installation process to the minimum — usually just installing the package from `npm` and re-running `pod install`.
The core implementation can be found in the [`expo-modules-autolinking`](https://github.com/expo/expo/tree/main/packages/expo-modules-autolinking) package and is divided into three parts:
1. a CLI command with the module resolution algorithms
2. code that integrates with the Gradle build system for Android
3. code that integrates with CocoaPods for iOS
Since SDK 52, Expo Autolinking not only links Expo modules, but also React Native modules. To use the React Native community CLI autolinking instead, see [opting out of Expo Autolinking for React Native modules](#opting-out-of-expo-autolinking-for-react-native-modules) section.
## Linking behavior
Expo Autolinking is integrated into the Gradle build system for Android and CocoaPods for iOS. When building your app, the Expo Autolinking CLI is called and searches for Expo and React Native modules to autolink.
This module resolution searches for candidate dependencies to autolink in four separate steps:
1. For React Native modules only, it considers any `dependencies` in your project root's **react-native.config.js** that contain an explicit `root` path. This file is optional and doesn't exist in most Expo projects.
2. It searches all directories specified in your autolinking configuration's `searchPaths` option.
3. It searches local modules in the directory specified in your autolinking configuration's `nativeModulesDir` option, which defaults to `./modules/`.
4. It resolves the dependencies of your app and any dependency or peer dependency recursively. This matches the [Node.js resolution algorithm](https://nodejs.org/api/modules.html#loading-from-node_modules-folders).
The autolinked modules are automatically added to the build, which usually means that your app's dependencies that contain native (platform-specific) code are set up automatically.
## Configuration
The behavior of the module resolution can be customized using some configuration options. These options can be defined in three different places, from the lowest to the highest precedence:
- `expo.autolinking` config object in application's **package.json**
- per platform overrides with `expo.autolinking.ios` and `expo.autolinking.android` objects
- options provided to the CLI command, the `use_expo_modules!` method in the **Podfile** or `useExpoModules` function in the **settings.gradle**
#### searchPaths
A list of paths relative to the app's root directory that Expo Autolinking should search for modules to autolink.
Useful when your project has a custom structure or you want to link local packages from directories different than **node_modules**.
The paths you specify must still be structured like **node_modules** directories.
```json package.json
{
  "expo": {
    "autolinking": {
      "searchPaths": ["../../packages"]
    }
  }
}
```
> **info** Before **SDK 54**, this list defaulted to the your app's **node_modules** directory, and all **node_modules** directories above it in monorepos.
> To opt back into to the old behavior, set this list to your app's **node_modules** directories, for example: `["../../node_modules", "./node_modules"]`.
#### nativeModulesDir
A path relative to the app's root directory that Expo Autolinking should search for local modules to autolink. This option defaults to `"./modules"`. Changing this option is only useful if you need to change the path [for local Expo modules](/modules/get-started/).
```json package.json
{
  "expo": {
    "autolinking": {
      "nativeModulesDir": "./modules"
    }
  }
}
```
#### exclude
A list of package names to exclude from autolinking. This is useful if you don't want to link some packages that specific platforms aren't using to reduce the binary size.
The following config in **package.json** will exclude `expo-random` and `third-party-expo-module` from autolinking on Android:
```json package.json
{
  "expo": {
    "autolinking": {
      "android": {
        "exclude": ["expo-random", "third-party-expo-module"]
      }
    }
  }
}
```
React Native modules can also be excluded by creating a **react-native.config.js** in the root directory of your project and setting the platform's configuration that the module should be excluded from to `null`. The following config will exclude `library-name` from autolinking on Android:
```js react-native.config.js
module.exports = {
  dependencies: {
    'library-name': {
      platforms: {
        android: null,
      },
    },
  },
};
```
> **info** Before **SDK 54**, the `exclude` option only applied to Expo modules and not React Native modules. React Native modules could only be excluded using a **react-native.config.js** file in the root directory of your project.
#### flags, Android only
CocoaPods flags to pass to each autolinked pod. `inhibit_warnings` is likely the only flag most developers want to use, to inhibit Xcode warnings produced when compiling the autolinked modules.
You can refer to the [CocoaPods Podfile documentation](https://guides.cocoapods.org/syntax/podfile.html#pod) for available flags.
```ruby
use_expo_modules!({
  flags: {
    :inhibit_warnings => false
  }
})
```
```json
{
  "expo": {
    "autolinking": {
      "ios": {
        "flags": {
          "inhibit_warnings": true
        }
      }
    }
  }
}
```
#### buildFromSource, Android only
A list of package names to opt out of prebuilt Expo modules. For complete reference, see [Prebuilt Expo Modules for Android](/guides/prebuilt-expo-modules/#selectively-opt-out).
#### legacy_shallowReactNativeLinking
When resolving your app's React Native modules, Expo Autolinking searches your app's dependencies, and those dependencies' dependencies recursively (matching the [Node.js resolution algorithm](https://nodejs.org/api/modules.html#loading-from-node_modules-folders)). Before **SDK 54**, Expo Autolinking didn't search dependencies recursively and only resolved your app's direct dependencies.
When enabled, this flag opts you out of the new behavior and restores the behavior from before **SDK 54**, only searching your app's direct dependencies for React Native modules. This option isn't considered when resolving Expo modules.
## CLI commands
#### search
This command is called by the build system to resolve Expo modules during the first phase of autolinking. Its implementation is shared between all platforms. The output from `search` will contain a list of `duplicates` per package, if any duplicates were found.
```sh
$ npx expo-modules-autolinking search
```
The above command returns an object in JSON format with Expo modules that Expo Autolinking found:
```json
{
  "expo-random": {
    "path": "/absolute/path/to/node_modules/expo-random",
    "version": "13.0.0",
    "config": {
      // Contents of `expo-module.config.json`
    },
    "duplicates": [
      // List of conflicting duplicates for this module (with lower precedence)
    ]
  }
  // more modules...
}
```
#### resolve
This command is called by the build system during the second phase of autolinking. It outputs an object with more (platform-specific) details for each Expo module, such as the path to the **build.gradle** or podspec files and module classes to link.
```sh
$ npx expo-modules-autolinking resolve --platform <apple|android>
```
For example, with the `--platform apple` option, it returns an object in JSON format with an array of modules and resolved details for the platform:
```json
{
  "modules": [
    {
      "packageName": "expo-random",
      "packageVersion": "13.0.0",
      "pods": [
        {
          "podName": "ExpoRandom",
          "podspecDir": "/absolute/path/to/node_modules/expo-random/ios"
        }
      ],
      "swiftModuleNames": ["ExpoRandom"],
      "modules": ["RandomModule"],
      "appDelegateSubscribers": [],
      "reactDelegateHandlers": [],
      "debugOnly": false
    }
    // more modules...
  ]
}
```
#### verify
Verifies the autolinked native modules by checking for duplicates. Warnings are shown for each conflicting, duplicate installation.
```sh
$ npx expo-modules-autolinking verify
```
Pass the `--verbose` option to list all autolinked native modules.
#### react-native-config
This command is called by the build system when autolinking React Native modules. It outputs an object with more platform-specific details for each React Native module, such as the path to the gradle or podspec files.
```sh
$ npx expo-modules-autolinking react-native-config
```
For example, with the `--platform ios` option, it returns an object in **react-native.config.js**'s output format with information about each React Native dependency and the path to the React Native installation.
```json
{
  "root": "/absolute/path/to",
  "reactNativePath": "/absolute/path/to/node_modules/react-native",
  "dependencies": {
    "@react-native-async-storage/async-storage": {
      "root": "/absolute/path/to/node_modules/@react-native-async-storage/async-storage",
      "name": "@react-native-async-storage/async-storage",
      "platforms": {
        "ios": {
          "podspecPath": "/absolute/path/to/node_modules/@react-native-async-storage/async-storage/RNCAsyncStorage.podspec",
          "version": "",
          "configurations": [],
          "scriptPhases": []
        }
      }
    }
    // more modules...
  }
}
```
## Dependency resolution and conflicts
> **important** This is an alpha feature starting in SDK 54 and later.
Autolinking and Node resolution have different goals and the module resolution algorithm in Node and Metro can sometimes come into conflict. If your app contains duplicate installations of a native module that is picked up by autolinking, your JavaScript bundle may contain both versions of the native module, while autolinking and your native app will only contain one version. This might cause runtime crashes and risks incompatibilities.
This is an especially common problem with isolated dependencies or monorepos, and you should [check for and deduplicate native modules in your dependencies](/guides/monorepos/#duplicate-native-packages-within-monorepos).
From **SDK 54**, you can set `experiments.autolinkingModuleResolution` to `true` in your [app config](/workflow/configuration/) to apply autolinking to Expo CLI and Metro bundler automatically. This will force dependencies that Metro resolves to match the native modules that **autolinking** resolves.
## Common questions
### How to set up the autolinking in my app?
All projects created with the `npx create-expo-app` command are already configured to use Expo Autolinking. If your project was created using a different tool, see [Installing Expo modules](/bare/installing-expo-modules) to make sure your project includes all necessary changes.
### What do I need to have in my module to make it autolinkable?
The module resolution algorithm searches only for packages that contain the [Expo module config](/modules/module-config/) file (**expo-module.config.json**) at the root directory, next to the **package.json** file.
It's also necessary to include supported platforms in the `platforms` array — if the platform for which the autolinking algorithm is run is not present in this array, it's just skipped in the search results.
### How is it different from React Native community CLI autolinking?
- Expo Autolinking comes with built-in support for monorepos, package manager workspaces, transitive dependencies, and isolated dependencies installations.
- It's also significantly faster, although the module resolution algorithm is more complex to be more reliable and match Node.js's module resolution.
- Expo module resolution is also capable of detecting duplicate dependencies, which is a common issue in monorepos.
- Last but not least, it integrates well with the features offered by Expo Modules APIs and supports React Native modules.
### Opting out of Expo Autolinking for React Native modules
Starting from SDK 52, Expo Autolinking replaces the React Native community CLI autolinking by default. If you would like to use the React Native community CLI's autolinking instead, set the environment variable `EXPO_USE_COMMUNITY_AUTOLINKING=1` and add `@react-native-community/cli` as a dev dependency to your project.
With this environment variable set, Expo Autolinking will not be used to resolve React Native modules, but will continue to autolink Expo modules.


## Using shared objects

Learn how to use a shared object from the Expo Modules API.

Shared objects let you expose long-lived native instances from Android and iOS to your app's JavaScript/TypeScript without giving control of their lifecycle. They can be used to keep heavy state objects, such as a decoded bitmap, alive across React components, rather than spinning up a new native instance every time a component mounts.
In this guide, let's understand what a shared object is and how they are implemented in native platforms.
## What is a shared object?
A shared object is a custom class that bridges a native instance from Android and/or iOS to your app's JavaScript/TypeScript code through an Expo module. On the native side in Kotlin and Swift, you declare the class by inheriting from `SharedObject` and expose it in your module definition using `Class()`. A shared object is deallocated automatically once neither JavaScript nor native holds a reference.
## Why use shared objects?
Large media assets, like images, can exceed several megabytes once decoded into memory. Without shared objects, passing these assets between different parts of your app forces each part to reload from the disk every time and decode the same file multiple times. This can increase memory pressure, create an I/O bottleneck, drop frames, or cause battery drain.
Shared objects solve this by keeping a single native instance alive in memory while multiple JavaScript references point to it.
## Example: Image manipulation without disk I/O
To understand shared objects, consider an example where you need to rotate and flip an image picked by the app user and then display that image in your app after manipulating it.
### Without shared objects
Historically, native modules were often written in a _stateless_ way, where each function operated independently without maintaining state between calls. If you wanted to perform two separate operations on the same object (such as an image file), you would load it from disk in both places and repeat the I/O operation each time.
Without shared objects, `ImagePicker` reads from a file URI such as `"file:///path/to/image.jpg"` and decodes the image into memory. The image manipulator module then reads the same URI and decodes the image into memory again. When the app user calls a transform method (for example, `rotate()`) to rotate the image, the module saves the rotated image to a new file. Finally, when the new URI is passed to the `Image` component, it decodes the image from disk again to render the image. This workflow results in two or more decode and disk read operations.
### With shared objects
The same scenario becomes much more efficient with shared objects. `ImagePicker` reads the URI and decodes the image once into a shared object. When the app user calls a transform method (for example, `rotate()`), the module manipulates the in-memory bitmap without writing to the disk. If you need a file output, call an explicit save function (for example, `saveAsync` in an image manipulator), otherwise the transforms stay in memory only.
Finally, the shared object is passed to the `Image` component and this time the image is rendered from memory. The entire workflow requires just one disk read and one decode operation, with all transformations happening in memory.
The performance gains are significant. By eliminating redundant disk I/O and decode operations, you keep only a single bitmap in memory instead of multiple copies. This reduces CPU usage, which helps preserve battery life, and lowers the risk of crashes from memory pressure.
Shared objects also unlock a more convenient, object-oriented API shape. You can expose methods on a long-lived instance (for example, `rotate()`, `flipX()`, `renderAsync()`) and let callers chain operations on that stateful object, instead of exposing a flat set of stateless functions.
### Implementation with shared objects
Now that you understand why shared objects are useful, let's look into a minimal implementation that demonstrates the core concepts of the previous example.
The example creates a simple image manipulation module that loads an image from a file path, applies transforms (rotate and flip) in memory, and exposes a shared reference that other modules can consume.
### Android implementation
In Android, you create a shared object from `SharedObject` class provided by `expo.modules.kotlin.sharedobjects.SharedObject`. This class manages the decoded bitmap and exposes methods to manipulate it. The implementation keeps only the current image in memory and applies transforms in place, so you allocate a new bitmap only when a transformation like rotation or flip produces one:
```kotlin
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
import expo.modules.kotlin.sharedobjects.SharedObject
class ImageRef : SharedRef<Bitmap>()
class SimpleImageContext(
  runtimeContext: RuntimeContext,
  bitmap: Bitmap
) : SharedObject(runtimeContext) {
  private var current: Bitmap = bitmap
  fun rotate(degrees: Float) = apply {
    val matrix = Matrix().apply { postRotate(degrees) }
    current = Bitmap.createBitmap(current, 0, 0, current.width, current.height, matrix, true)
  }
  fun flipX() = apply {
    val matrix = Matrix().apply { preScale(-1f, 1f) }
    current = Bitmap.createBitmap(current, 0, 0, current.width, current.height, matrix, true)
  }
  fun render(): ImageRef = ImageRef(current, runtimeContext)
  override fun sharedObjectDidRelease() {
    if (!current.isRecycled) current.recycle()
  }
}
```
The above example is quite similar to the iOS implementation. However, there is one difference on Android: the `sharedObjectDidRelease()` method. This lifecycle callback is invoked when JavaScript releases all references to the shared object, providing an opportunity to clean up native resources.
When the result of this class is passed to another module, the `render` method returns an `ImageRef`, which is a specialized `SharedRef<Bitmap>` type that `expo-image` and other image-aware modules already understand.
The module definition exposes an async function to create the context and a class definition to bind methods. The Expo Modules API uses a declarative syntax where you specify the module name, functions to create instances, and a class definition that maps methods to the shared object:
```kotlin
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import expo.modules.kotlin.modules.Module
import expo.modules.kotlin.modules.ModuleDefinition
class SimpleImageModule : Module() {
  override fun definition() = ModuleDefinition {
    Name("SimpleImageModule")
    AsyncFunction("createContextAsync") { path: String ->
      val bitmap = BitmapFactory.decodeFile(path)
        ?: throw Exceptions.IllegalArgument("Unable to decode image at $path")
      SimpleImageContext(runtimeContext, bitmap)
    }
    Class<SimpleImageContext>("Context") {
      Function("rotate") { ctx: SimpleImageContext, degrees: Float -> ctx.rotate(degrees) }
      Function("flipX") { ctx: SimpleImageContext -> ctx.flipX() }
      AsyncFunction("renderAsync") Coroutine { ctx: SimpleImageContext -> ctx.render() }
    }
  }
}
```
In the above example, `createContextAsync` function decodes the bitmap from the file path and returns a new `SimpleImageContext` instance. Once the context exists, the `rotate` and `flipX` functions run synchronously because they only manipulate in memory. The `renderAsync` function is marked async to signal that it might involve copying or preparing the bitmap for consumption by other modules.
### iOS implementation
In iOS, you create a shared object by inheriting from `SharedObject` class provided by `ExpoModulesCore`. This class manages the decoded bitmap and exposes methods to manipulate it. The implementation keeps only the current image in memory and applies transforms in place:
```swift
import ExpoModulesCore
import UIKit
final class ImageRef: SharedRef<UIImage> {}
final class SimpleImageContext: SharedObject {
  private var current: UIImage
  init(path: String) throws {
    guard let data = try? Data(contentsOf: URL(fileURLWithPath: path)),
          let image = UIImage(data: data) else {
      throw Exceptions.InvalidArgument()
    }
    self.current = image
    super.init()
  }
  func rotate(by degrees: Double) {
    current = current.rotated(degrees: degrees)
  }
  func flipX() {
    current = current.withHorizontallyFlippedOrientation()
  }
  func render() -> ImageRef {
    return ImageRef(current)
  }
}
```
In the above example, `SimpleImageContext` reads an image file and keeps a single `UIImage` in memory. The `rotate` and `flipX` methods mutate the current image in memory without touching the disk.
When the result of this class is passed to another module, the `render` method returns an `ImageRef`, which is a specialized `SharedRef<UIImage>` type that `expo-image` and other image-aware modules already understand.
Now, with the shared object class definition, you can expose it through your module definition. The Expo Modules API uses a declarative syntax where you specify the module name, functions to create instances, and a class definition that maps methods to the shared object:
```swift
public final class SimpleImageModule: Module {
  public func definition() -> ModuleDefinition {
    Name("SimpleImageModule")
    AsyncFunction("createContextAsync") { (path: String) -> SimpleImageContext in
      return try SimpleImageContext(path: path)
    }
    Class("Context", SimpleImageContext.self) {
      Function("rotate") { (ctx, degrees: Double) -> SimpleImageContext in
        ctx.rotate(by: degrees)
        return ctx
      }
      Function("flipX") { (ctx: SimpleImageContext) -> SimpleImageContext in
        ctx.flipX()
        return ctx
      }
      AsyncFunction("renderAsync") { (ctx: SimpleImageContext) -> ImageRef in
        return ctx.render()
      }
    }
  }
}
```
In the above example, the `createContextAsync` is an asynchronous function because loading and decoding an image from disk is an I/O operation. Once the context exists, the `rotate` and `flipX` functions run synchronously because they only manipulate in memory. The `renderAsync` function is marked async to signal that it might involve copying or preparing the bitmap for consumption by other modules, though in this simple example, it returns immediately.
### Using a shared object in your app
You can now use the shared object in your app's JavaScript/TypeScript code to load the image from the path, create a context of the loaded image, chain in-memory transforms, render to get a shared reference, and then pass that reference to an `Image` component:
```tsx
import { useState } from 'react';
import { Button } from 'react-native';
import { Image } from 'expo-image';
import type { SharedRef } from 'expo';
import SimpleImageModule from 'simple-image-module'; // The native custom module
import { pickImageAsync } from './pickImage'; // The custom TypeScript function
export function SharedImageExample() {
  const [context, setContext] = useState(null);
  const [result, setResult] = useState<SharedRef<'image'> | null>(null);
  const load = async () => {
    const uri = await pickImageAsync();
    if (!uri) {
      return;
    }
    const ctx = await SimpleImageModule.createContextAsync(uri);
    setContext(ctx);
    setResult(await ctx.renderAsync());
  };
  const rotateAndFlip = async () => {
    if (!context) {
      return;
    }
    setResult(await context.rotate(90).flipX().renderAsync());
  };
  return (
    <>
      <Button title="Pick image" onPress={load} />
      <Button title="Rotate 90° + flip X" onPress={rotateAndFlip} disabled={!context} />
      {result && <Image source={result} style={{ width: 200, height: 200 }} />}
    </>
  );
}
```
In the above example, the React component only consumes the native image transformed by the image manipulator context, which is already in memory and referenced by the shared object (`ImageRef`). As a result, the image view can display the image immediately on the next frame, and chained transforms never touch the file system.
The JavaScript API picks an image using `ImagePicker`, which returns a standard file URI. This URI is handed to a custom native module to create a shared object in `SharedImageExample()`:
```tsx
import * as ImagePicker from 'expo-image-picker';
export async function pickImageAsync() {
  const result = await ImagePicker.launchImageLibraryAsync({
    quality: 1,
    allowsMultipleSelection: false,
  });
  if (result.canceled || !result.assets?.length) {
    return null;
  }
  // At this point we still have a disk URI.
  // The native module will lift it into a shared object.
  return result.assets[0].uri;
}
```
In the above example, `ImagePicker` doesn't need to know about shared objects. It returns what it should, which is a file path. Your native module is responsible for transforming that path into a shared object that other Expo modules can work with, such as `Image` from `expo-image`.
## Expo libraries that use shared objects
Some examples of [Expo SDK libraries](/versions/latest/) that use shared objects and their purpose:
- `expo-image` library uses `SharedObject` to keep a decoded operation alive and the view component accepts `SharedRef<Bitmap>` on Android and `SharedRef<UIImage>` on iOS. This design allows images to be passed between modules without decoding it again. To explore more, see `expo-image` library's source code for [Android](https://github.com/expo/expo/tree/main/packages/expo-image/android/src/main/java/expo/modules/image) and [iOS](https://github.com/expo/expo/tree/main/packages/expo-image/ios).
- `expo-image-manipulator` library demonstrates handling asynchronous operations, queuing multiple operations, and exposing a clean JavaScript API. To explore more, see `expo-image-manipulator` library's source code for [Android](https://github.com/expo/expo/tree/main/packages/expo-image-manipulator/android/src/main/java/expo/modules/imagemanipulator) and [iOS](https://github.com/expo/expo/tree/main/packages/expo-image-manipulator/ios).
- `expo-sqlite` library uses shared objects to keep database, session, and statement handles across calls while coordinating access to the underlying database. To explore more, see `expo-sqlite` library's source code for [Android](https://github.com/expo/expo/tree/main/packages/expo-sqlite/android/src/main/java/expo/modules/sqlite) and [iOS](https://github.com/expo/expo/tree/main/packages/expo-sqlite/ios).
- `expo/fetch` library uses shared objects to keep request and response lifecycles alive for streaming, cancellation, and redirect handling while presenting a JavaScript fetch-compatible API. To explore more, see `expo/fetch` library's source code for [Android](https://github.com/expo/expo/tree/main/packages/expo/android/src/main/java/expo/modules/fetch) and [iOS](https://github.com/expo/expo/tree/main/packages/expo/ios/Fetch).
## Performance benefits of shared objects
Using shared objects provides several performance improvements, such as:
- **Reduced disk I/O:** A single read operation instead of multiple reads across different modules or function calls
- **Fewer decode operations:** Expensive decoding (such as JPEG/PNG to bitmap) happens once, not repeatedly
- **Lower memory pressure:** One decode instance in memory instead of multiple copies
- **Faster operations:** In-memory transformations are significantly faster than disk-based ones
- **Avoid frame drops:** Less I/O blocking means smoother UI interactions
## Additional resources


## expo-module.config.json

Learn about different configuration options available in expo-module.config.json.

Expo modules are configured in **expo-module.config.json**. This file currently is capable of configuring autolinking and module registration. The following properties are available:
- `platforms` — An array of supported platforms. Acceptable values are `android`, `apple` (or use the more granular `ios` / `macos` / `tvos`), `web` and `devtools` (see [Create a dev tools plugin](/debugging/create-devtools-plugins)).
- `apple` — Config with options specific to Apple platforms
  - `modules` — Names of Swift native modules classes to put to the generated modules provider file.
  - `appDelegateSubscribers` — Names of Swift classes that hook into `ExpoAppDelegate` to receive AppDelegate lifecycle events.
- `android` — Config with options specific to Android platform
  - `modules` — Full names (package + class name) of Kotlin native modules classes to put to the generated package provider file.


## Mocking native calls in Expo modules

Learn about mocking native calls in Expo modules.

The recommended way to write unit tests for an Expo project is to use [Jest](https://jestjs.io/) and the `jest-expo` preset.
To write a unit test for an app that uses native code, you need to mock native calls. The term **mocking** means to replace the actual implementation of a function with a fake version that does not perform any actions. This approach is useful for running unit tests on a local computer, as it involves bypassing the need for native code, which can only run on an actual Android or iOS device.
Expo SDK includes a set of default mocks for each of our community packages. You can also mock any JS code yourself using built-in Jest APIs such as [mock functions](https://jestjs.io/docs/mock-functions).
However, to provide default mocks in your Expo Module, we offer a method to bundle them. This ensures that when your module user runs unit tests, they will automatically use a mocked implementation.
## Providing mocks for a module
Create a file with the same name as the native module you want to mock and place it in your module's **mocks** directory. Make sure to export the mock implementation from this file.
The `jest-expo` preset will automatically return the exported functions because of a `requireNativeModule` call when running during a unit test.
For example, the `expo-clipboard` library has a native module called `ExpoClipboard`. You will create a **ExpoClipboard.ts** in the **mocks** directory to mock it.
```ts ExpoClipboard.ts
export async function hasStringAsync(): Promise<boolean> {
  return false;
}
```
Now, in a unit test, calling `ExpoClipboard.hasStringAsync()` returns `false`.
## Automatic generation of mocks
Maintaining mocks for native modules can be a lot of work if the native module has multiple methods. To make this easier, we provide a script that automatically generates mocks for all native functions in a module's **mocks** directory. It works for generating mocks in TypeScript and JavaScript based on the Swift implementation in your module. Methods that exist only on Android (for example, Kotlin-only APIs) will not be generated automatically. In those cases, manually add or adjust the mock in the **mocks** directory.
To use this script, you have to install [SourceKitten](https://github.com/jpsim/SourceKitten) framework. Then, navigate to the module directory (where your module's **expo-module.config.json** is located) and run the `generate-ts-mocks` command.
```sh
$ brew install sourcekitten
$ npx expo-modules-test-core generate-ts-mocks
```
The command above generates **ExpoModuleName.ts** in the **mocks** directory of your module. It contains a mock implementation for each native method and view in your module.
> **info** **Tip:** You can also run `generate-js-mocks` to generate mocks in JavaScript.
## Unit testing with mocked modules
Once you have created mocks for your native modules, you can write comprehensive unit tests to verify that your JavaScript code calls the native functions correctly and handles their responses appropriately. For example, running `npx expo-modules-test-core generate-ts-mocks` command, will generate a mock similar to the example shown below inside **example-module/mocks** directory:
```ts example-module/mocks/ExpoModuleName.ts
/**
 * Automatically generated by expo-modules-test-core.
 *
 * This autogenerated file provides a mock for native Expo module,
 * and works out of the box with the expo jest preset.
 *
 */
export type URL = any;
export function hello(): any {}
export async function setValueAsync(value: string): Promise<any> {}
export type ViewProps = {
  url: URL;
  onLoad: (event: any) => void;
};
export function View(props: ViewProps) {}
```
The examples in the following sections demonstrate comprehensive unit testing patterns using real testing techniques from Expo SDK modules such as [`expo-clipboard`](https://github.com/expo/expo/blob/main/packages/expo-clipboard/src/__tests__/Clipboard-test.native.ts), [`expo-screen-capture`](https://github.com/expo/expo/blob/main/packages/expo-screen-capture/src/__tests__/ScreenCaptureHook-test.native.js), and [`expo-app-integrity`](https://github.com/expo/expo/blob/main/packages/expo-app-integrity/src/__tests__/ExpoAppIntegrity-test.native.ts).
### Basic test setup
Create test files in a **\_\_tests\_\_** directory next to your source files. Import your module and the mocked native module to write assertions:
```js MyModule.test.js
import * as MyModule from '../MyModule';
import ExpoMyModule from '../ExpoMyModule';
describe('MyModule', () => {
  it('calls native module with correct parameters', async () => {
    await MyModule.doSomething('test-param');
    expect(ExpoMyModule.doSomething).toHaveBeenCalledWith('test-param');
  });
});
```
### Testing function calls and return values
Use Jest's mock assertion methods to verify that your JavaScript functions delegate to native implementations correctly:
```js MyModule.test.js
describe('Module functionality', () => {
  it('delegates to native implementation', () => {
    MyModule.setData('test-data');
    expect(ExpoMyModule.setDataAsync).toHaveBeenCalledWith('test-data', {});
  });
  it('handles async operations', async () => {
    await expect(MyModule.getDataAsync()).resolves.not.toThrow();
  });
  it('verifies call count', () => {
    MyModule.performAction();
    MyModule.performAction();
    expect(ExpoMyModule.performAction).toHaveBeenCalledTimes(2);
  });
});
```
### Testing React hooks with native modules
When testing React hooks that use native modules, use React Testing Library's [`renderHook`](https://testing-library.com/docs/react-testing-library/api/#renderhook) function:
```js useMyHook.test.js
import { renderHook } from '@testing-library/react-native';
import { useMyHook } from '../useMyHook';
import ExpoMyModule from '../ExpoMyModule';
jest.mock('../ExpoMyModule', () => ({
  startOperation: jest.fn().mockResolvedValue(),
  stopOperation: jest.fn().mockResolvedValue(),
}));
describe('useMyHook', () => {
  it('calls native methods on mount and unmount', () => {
    const hook = renderHook(useMyHook);
    expect(ExpoMyModule.startOperation).toHaveBeenCalledTimes(1);
    hook.unmount();
    expect(ExpoMyModule.stopOperation).toHaveBeenCalledTimes(1);
  });
  it('handles parameter changes', () => {
    const hook = renderHook(useMyHook, { initialProps: 'param1' });
    hook.rerender('param2');
    expect(ExpoMyModule.startOperation).toHaveBeenCalledTimes(2);
    expect(ExpoMyModule.stopOperation).toHaveBeenCalledTimes(1);
  });
});
```
### Best practices
- **Clean up between tests**: Use `beforeEach` or `afterEach` to reset mocks and avoid test pollution.
- **Test edge cases**: Verify behavior when native functions throw errors or return unexpected values.
- **Use descriptive test names**: Write test descriptions that explain the specific behavior being verified.
- **Group related tests**: Use `describe` blocks to organize tests by functionality or component.
## More


## Expo Modules API: Design considerations

An overview of the design considerations behind the Expo Modules API.

The Expo team maintains a large set of libraries, and maintaining native modules over time and in a constantly changing environment can be challenging. With the Expo Modules API, we set out to build powerful tooling that would make building and maintaining these libraries easier.
### Take advantage of modern language features
After several years of maintaining over 50 native modules in the Expo SDK, we have discovered that many issues were caused by unhandled null values or incorrect types. Modern language features can help developers avoid these bugs; for example, the lack of optional types combined with the dynamism of Objective-C made it tough to catch certain classes of bugs that would have been caught by the compiler in Swift.
Another difficulty of writing React Native modules is context switching between the vastly different languages and paradigms for writing native modules on each platform. Due to the differences between these platforms, it cannot be avoided completely. We feel the need to have just one common API and documentation to simplify the development as much as possible and make it easier for a single developer to maintain a library on multiple platforms.
This is one of the reasons why the Expo Modules ecosystem was designed from the ground up to be used with modern native languages: Swift and Kotlin.
### Make it easy to pass data between runtimes
The Expo Modules API has full knowledge of the argument types the native function expects. It can pre-validate and convert the arguments for you, and dictionaries can be represented as native structs that we call [Records](/modules/module-api/#records).
One big pain point we aimed to solve with the API is the validation of arguments passed from JavaScript to native functions. This is especially error-prone, time-consuming, and difficult to maintain when it comes to `NSDictionary` or `ReadableMap`, where the type of values is unknown in runtime, and each property needs to be validated separately by the developer.
Knowing the argument types, it is also possible to [automatically convert arguments](/modules/module-api/#convertibles) to some platform-specific types (for example, `{ x: number, y: number }` or `[number, number]` can be translated to CoreGraphics's `CGPoint` for your convenience).
In summary, Expo Modules has powerful built-in and extensible type conversion and type safety. It supports automatic of primitive values (for example, `Bool`/`Int`/`UInt`/`Float32`/`Double`/`Pair`/`String`), complex built-in types (for example, `URL`, `CGPoint`, `UIColor`, `Data`, `java.net.URL`, `android.graphics.Color`, `kotlin.ByteArray`), records (user defined types, like a `struct`/`Object`), and enums.
### Support expressive object-oriented APIs
Keep the source of truth for the state of your native module in one place, rather than spreading it across JavaScript and native and doing the associated book-keeping yourself. We call this feature **Shared Objects**. For example, [`expo-sqlite` database instances are backed by Shared Objects](https://github.com/expo/expo/blob/718a9ac107231475ca4b2e6427317ade9d1e70fa/packages/expo-sqlite/src/SQLiteDatabase.ts#L421). Detailed documentation for Shared Objects is coming soon.
### Provide a safe and composable mechanism to hook into app lifecycle events
[Android lifecycle listeners](/modules/android-lifecycle-listeners/) and [iOS AppDelegate subscribers](/modules/appdelegate-subscribers/) are a powerful feature that allows you to hook into the lifecycle of your app, without needing to spread the code out for your module across your `MainActivity` and `AppDelegate` classes or require that users of your library do the same. This is particularly useful for smooth integration with [Continuous Native Generation](/workflow/continuous-native-generation/) because it provides libraries with a mechanism to hook into app lifecycle events in a composable way &mdash; without having to be concerned about what other libraries might be doing.
### Support the New Architecture while remaining backwards compatible
React Native version 0.68 introduced the [New Architecture](https://reactnative.dev/docs/the-new-architecture/landing-page), which offers developers new capabilities for building mobile apps. It consists of the new native modules system called [Turbo Modules](https://reactnative.dev/docs/the-new-architecture/pillars-turbomodules) and the new rendering system called [Fabric](https://reactnative.dev/architecture/fabric-renderer).
Native libraries need to be adapted to take advantage of these new systems. For Fabric, it needs even more work as it doesn't provide any compatibility layer, which means that view managers written in the old way don't work with Fabric and the other way around — Fabric native components don't work with the old renderer. It basically implies that existing libraries have to provide support for both architectures for a while, increasing the technical debt.
The new architecture is mostly written in C++, so you may end up writing some C++ code for your library as well. As we all React Native developers, use high-level JavaScript on a daily basis, we are rather reluctant to write C++, which is on the opposite side of the spectrum. Moreover, including C++ code in the library has a negative impact on build times, especially on Android, and can be more difficult to debug.
We took these into account when designing the Expo Modules API with the goal in mind to make it renderer-agnostic, so that the module doesn't need to know whether the app is run on the new architecture or not, significantly reducing the cost for library developers.


# Push notifications

## Expo push notifications: Overview

An overview of Expo push notification service.

Expo simplifies implementing push notifications by handling much of the complexity involved in communicating with Firebase Cloud Messaging (FCM) or Apple Push Notification Service (APNs). This allows you to treat Android and iOS notifications in the same way and save time both on the front-end and back-end.
Follow the video or links below to learn how to set up push notifications, send them, and handle incoming notifications in your app.
Video Tutorial: [Expo Notifications with EAS | Complete Guide](https://www.youtube.com/watch?v=BCCjGtKtBjE)


## What you need to know about notifications

Learn about notification types and their behavior before you get started.

Notifications are alerts that inform users of new information or events, even when the app isn't actively in use. They have a large surface area and differences across platforms can make implementing notifications intimidating.
Whether you are starting with notifications or have existing knowledge, this document explains the different types of notification and their behaviors.
Expo's notification support builds on top of the native functionality provided by Android and iOS. The same concepts and behaviors from native platforms apply to Expo apps. If you are unsure about a specific notification feature, see each platform's [official documentation](#external-references).
## Remote and Local notifications
1. **Push Notifications**: (also known as "remote notifications") Notifications that are sent to a user's device from a remote server.
2. **Local Notifications**: (also known as "in-app notifications") Notifications that are created and displayed from within the app. Since many of the APIs that create these notifications will create them at a particular time, these may also sometimes be called "scheduled notifications".
`expo-notifications` supports both push and local notifications. You must use a [development build](/develop/development-builds/introduction/) to use push notifications since the capability is not built into Expo Go.
See [in-app notifications](/versions/latest/sdk/notifications/#present-a-local-in-app-notification-to-the-user) on how to create and display a local notification. The rest of this guide focuses on push notifications.
## Push Notification delivery
When a push notification arrives to your app, its behavior depends on the app's state and the type of notification. Let's clarify the terminology:
### Application states
- **Foreground**: The app is actively running in the foreground. Its interface is currently being displayed on the screen.
- **Background**: The app is running in the background, "minimized". Its interface is not currently being displayed on the screen.
- **Terminated**: The app was "killed", usually by a swipe-away gesture in the app switcher. On Android, if the user force-stops the app from device settings, it must be manually reopened for notifications to start working (this is a limitation of Android).
### Push Notification behaviors
For any kind of notification, when the app is in the foreground, the app is in control of how an incoming notification is handled. The app may present it directly, show some custom in-app UI, or even ignore it (this is controlled by [`NotificationHandler`](/versions/latest/sdk/notifications/#setnotificationhandlerhandler)). When the app is not in the foreground, the behavior depends on the type of notification.
The table below summarizes what happens when a push notification is delivered to the device:
| Notification Type                                                                                                                                                                                                       | App in Foreground                                                                                                                                                                                        | App in Background                                                                      | App Terminated                                                                         |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| [Notification Message](/push-notifications/what-you-need-to-know/#notification-message) and [Notification Message with data payload](/push-notifications/what-you-need-to-know/#notification-message-with-data-payload) | delivery runs [`NotificationReceivedListener`](/versions/latest/sdk/notifications/#addnotificationreceivedlistenerlistener) and [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname) | OS shows notification                                                                  | OS shows notification                                                                  |
| [Headless Background Notification](/push-notifications/what-you-need-to-know/#headless-background-notifications)                                                                                                        | delivery runs [`NotificationReceivedListener`](/versions/latest/sdk/notifications/#addnotificationreceivedlistenerlistener) and [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname) | delivery runs [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname) | delivery runs [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname) |
For the cases when the user interacts with the notification (for example, by pressing an action button), the following handlers are made available to you.
| App state  | iOS Listener(s) triggered              | Android Listener(s) triggered                                                                                       |
| ---------- | -------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| Foreground | `NotificationResponseReceivedListener` | `NotificationResponseReceivedListener`                                                                              |
| Background | `NotificationResponseReceivedListener` | `NotificationResponseReceivedListener` and [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname) |
| Terminated | `NotificationResponseReceivedListener` | [JS task](/versions/latest/sdk/notifications/#registertaskasynctaskname)                                            |
In the table above, whenever `NotificationResponseReceivedListener` is triggered, also `useLastNotificationResponse` return value would change.
> **info** When the app is not running or killed and is started by tapping on a notification, the `NotificationResponseReceivedListener` should be registered early (module top-level) to be triggered on iOS. For action buttons that bring the app to the foreground, we recommend to capture the response using `useLastNotificationResponse` or `getLastNotificationResponse` after the app starts.
## Push Notification types
### Notification Message
A Notification Message is a notification that specifies presentational information, such as a title or body text.
- On Android, this corresponds to a push notification request that contains [`AndroidNotification`](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification)
- On iOS, this corresponds to a push notification request that contains [`aps.alert` dictionary](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Create-the-JSON-payload) and the `apns-push-type` header set to `alert`.
When you use the Expo Push Service, and specify `title`, `subtitle`, `body`, `icon`, or `channelId`, the resulting push notification request is a Notification Message.
[//]: # 'TODO vonovak clarify what fields make a notification to be considered a Notification Message'
The typical use case for a Notification Message is to have it presented to the user immediately without any extra processing being done.
### Notification Message with data payload
This is an Android-only term ([see the official docs](https://firebase.google.com/docs/cloud-messaging/concept-options#data_messages)) where a push notification request contains both `data` field and a `notification` field.
On iOS, extra data may be part of a regular Notification Message request. Apple doesn't distinguish between Notification Message which does and does not carry data.
### Headless Background Notifications
Headless Notification is a remote notification that doesn't directly specify presentational information such as the title or body text. With the exception below\*, headless notifications are not presented to users. Instead, they carry data (JSON) which is processed by a JavaScript task defined in your app via [`registerTaskAsync`](/versions/latest/sdk/notifications/#registertaskasynctaskname). The task may perform arbitrary logic. For example, write to `AsyncStorage`, make an api request, or present a local notification whose content is taken from the push notification's data.
> **info** We use the term "Headless Background Notification" to refer to the [Data Message](https://firebase.google.com/docs/cloud-messaging/concept-options#data_messages) on Android and the [background notification](https://developer.apple.com/documentation/usernotifications/pushing-background-updates-to-your-app#Create-a-background-notification) on iOS. Their key similarities are that both of these notification types allow sending only JSON data, and background processing by the app.
Headless Background Notifications have the ability to run custom JavaScript in response to a notification _even when the app is terminated_. This is powerful but comes with a limitation: even when the notification is delivered to the device, the OS does not guarantee its delivery to your app. This may happen due to a variety of reasons, such as when [Doze mode](https://developer.android.com/training/monitoring-device-state/doze-standby) is enabled on Android, or when you send too many background notifications &mdash; Apple recommends not to [send more than two or three per hour](https://developer.apple.com/documentation/usernotifications/pushing-background-updates-to-your-app#overview).
When you use the Expo Push Service, and specify only `data` and `_contentAvailable: true` (and other non-interactive fields such as `ttl`), the resulting push notification request produces a Headless Background Notification.
[//]: # 'TODO vonovak clarify how setting priority behaves here, because apns-priority field should be 5 on iOS but can be specified on Android'
> To use Headless Background Notifications on iOS, you have to [configure](/versions/latest/sdk/notifications/#background-notification-configuration) them first.
The rule of thumb is to prefer a regular Notification Message if you don't require running JavaScript in the background.
\* The exception is when you specify `title` or `message` inside of [`data`](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidConfig). In that case, `expo-notifications` package automatically presents the headless notification on Android, but not on iOS. We plan to make this behavior more consistent across platforms in a future release.
### Data-only notifications
Android has a concept of [Data Messages](https://firebase.google.com/docs/cloud-messaging/concept-options#data_messages). iOS does not have exactly the same concept, but a close equivalent is [Headless Background Notifications](#headless-background-notifications).
You may also come across the term "silent notification", which is yet another name for notifications that don't present anything to the user &mdash; we describe these as [Headless Background Notifications](#headless-background-notifications).
## External references
This is a non-exhaustive list of official resources for push notifications on Android and iOS:
- [Android - Firebase Cloud Messaging message types](https://firebase.google.com/docs/cloud-messaging/customize-messages/set-message-type)
- [iOS - Generating a remote notification](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification)
- [iOS - Pushing background updates to your app](https://developer.apple.com/documentation/usernotifications/pushing-background-updates-to-your-app)


## Expo push notifications setup

Learn how to set up push notifications, get credentials for development and production, and send a testing push notification.

To utilize Expo push notification service, you must configure your app by installing a set of libraries, implement functions to handle notifications, and set up credentials for Android and iOS.
Complete the steps outlined in this guide or follow the more detailed video below. At the end, you'll be able to send a push notification and receive it on a device.
Video Tutorial: [Expo Notifications with EAS | Complete Guide](https://www.youtube.com/watch?v=BCCjGtKtBjE)
To get the client-side ready for push notifications, the following things are required:
- The user's permission to send them push notifications.
- The app's [`ExpoPushToken`](/versions/latest/sdk/notifications/#expopushtoken).
Note: Do you want to use FCM / APNs directly, instead of the Expo push notification service?
---
If you need finer-grained control over your notifications, communicating directly with FCM and APNs may be necessary. Expo does not lock you into using Expo Application Services, and the `expo-notifications` API is push-service agnostic. Learn how to ["Send notifications with FCM and APNs"](/push-notifications/sending-notifications-custom/).
---
## Prerequisites
> **warning** **Important:** Push notifications are not supported on Android Emulators and iOS Simulators. A real device is required.
The following steps described in this guide use [EAS Build](/build/introduction/). This is the easiest way to set up notifications since your EAS project will also contain the [notification credentials](#get-credentials-for-development-builds). However, you can use the `expo-notifications` library without EAS Build by building [your project locally](/guides/local-app-development/).
Step 1: 
## Install libraries
Run the following command to install the `expo-notifications`, `expo-device` and `expo-constants` libraries:
```sh
$ npx expo install expo-notifications expo-device expo-constants
```
- [`expo-notifications`](/versions/latest/sdk/notifications) library is used to request a user's permission and to obtain the `ExpoPushToken` for sending push notifications.
- [`expo-device`](/versions/latest/sdk/device) is used to check whether the app is running on a physical device.
- [`expo-constants`](/versions/latest/sdk/constants) is used to get the `projectId` value from the app config.
Step 2: 
## Add config plugin
Add the `expo-notifications` plugin in the `plugins` array of your [app config](/workflow/configuration/):
```json app.json
{
  "expo": {
    "plugins": [
      "expo-notifications"
      ]
  }
}
```
Step 3: 
## Add a minimal working example
The code below shows a working example of how to register for, send, and receive push notifications in a React Native app. Copy and paste it into your project:
```tsx App.tsx
import { useState, useEffect, useRef } from 'react';
import { Text, View, Button, Platform } from 'react-native';
import * as Device from 'expo-device';
import * as Notifications from 'expo-notifications';
import Constants from 'expo-constants';
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldPlaySound: true,
    shouldSetBadge: true,
    shouldShowBanner: true,
    shouldShowList: true,
  }),
});
async function sendPushNotification(expoPushToken: string) {
  const message = {
    to: expoPushToken,
    sound: 'default',
    title: 'Original Title',
    body: 'And here is the body!',
    data: { someData: 'goes here' },
  };
  await fetch('https://exp.host/--/api/v2/push/send', {
    method: 'POST',
    headers: {
      Accept: 'application/json',
      'Accept-encoding': 'gzip, deflate',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(message),
  });
}
function handleRegistrationError(errorMessage: string) {
  alert(errorMessage);
  throw new Error(errorMessage);
}
async function registerForPushNotificationsAsync() {
  if (Platform.OS === 'android') {
    await Notifications.setNotificationChannelAsync('default', {
      name: 'default',
      importance: Notifications.AndroidImportance.MAX,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });
  }
  if (Device.isDevice) {
    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    if (finalStatus !== 'granted') {
      handleRegistrationError('Permission not granted to get push token for push notification!');
      return;
    }
    const projectId =
      Constants?.expoConfig?.extra?.eas?.projectId ?? Constants?.easConfig?.projectId;
    if (!projectId) {
      handleRegistrationError('Project ID not found');
    }
    try {
      const pushTokenString = (
        await Notifications.getExpoPushTokenAsync({
          projectId,
        })
      ).data;
      console.log(pushTokenString);
      return pushTokenString;
    } catch (e: unknown) {
      handleRegistrationError(`${e}`);
    }
  } else {
    handleRegistrationError('Must use physical device for push notifications');
  }
}
export default function App() {
  const [expoPushToken, setExpoPushToken] = useState('');
  const [notification, setNotification] = useState<Notifications.Notification | undefined>(
    undefined
  );
  useEffect(() => {
    registerForPushNotificationsAsync()
      .then(token => setExpoPushToken(token ?? ''))
      .catch((error: any) => setExpoPushToken(`${error}`));
    const notificationListener = Notifications.addNotificationReceivedListener(notification => {
      setNotification(notification);
    });
    const responseListener = Notifications.addNotificationResponseReceivedListener(response => {
      console.log(response);
    });
    return () => {
      notificationListener.remove();
      responseListener.remove();
    };
  }, []);
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'space-around' }}>
      <Text>Your Expo push token: {expoPushToken}</Text>
      <View style={{ alignItems: 'center', justifyContent: 'center' }}>
        <Text>Title: {notification && notification.request.content.title} </Text>
        <Text>Body: {notification && notification.request.content.body}</Text>
        <Text>Data: {notification && JSON.stringify(notification.request.content.data)}</Text>
      </View>
      <Button
        title="Press to Send Notification"
        onPress={async () => {
          await sendPushNotification(expoPushToken);
        }}
      />
    </View>
  );
}
```
### Configure `projectId`
Using the previous example, when you are registering for push notifications, you need to use [`projectId`](/versions/latest/sdk/constants/#easconfig). This property is used to attribute Expo push token to the specific project. For projects using EAS, the `projectId` property represents the Universally Unique Identifier (UUID) of that project.
`projectId` is set automatically when you create a development build. However, **we recommend setting it manually in your project's code**. To do so, you can use [`expo-constants`](/versions/latest/sdk/constants/) to get the `projectId` value from the app config.
```ts
const projectId = Constants?.expoConfig?.extra?.eas?.projectId ?? Constants?.easConfig?.projectId;
const pushTokenString = (await Notifications.getExpoPushTokenAsync({ projectId })).data;
```
One advantage of attributing the Expo push token to your project's ID is that it doesn't change when a project is transferred between different accounts or the existing account gets renamed.
Step 4: 
## Get credentials for development builds
For Android and iOS, there are different requirements to set up your credentials.
    For Android, you need to configure **Firebase Cloud Messaging (FCM)** to get credentials and set up your Expo project.
    Follow the steps in [Add Android FCM V1 credentials](/push-notifications/fcm-credentials) to set up your credentials.
    > **warning** A paid Apple Developer Account is required to generate credentials.
    For iOS, make sure you have [registered your iOS device](/develop/development-builds/create-a-build/#create-a-development-build-for-the-device) on which you want to test before running the `eas build` command for the first time.
    If you create a development build for the first time, you'll be asked to enable push notifications. Answer yes to the following questions when prompted by the EAS CLI:
    - Setup Push Notifications for your project
    - Generating a new Apple Push Notifications service key
> If you are not using EAS Build, run `eas credentials` manually.
Step 5: 
## Build the app
```sh
$ eas build
```
Step 6: 
## Test using the push notifications tool
After creating and installing the development build, you can use [Expo push notifications tool](https://expo.dev/notifications) to quickly send a test notification to your device.
1. Start the development server for your project:
   ```sh
$ npx expo start
```
2. Open the development build on your device.
3. After the `ExpoPushToken` is generated, enter the value in the Expo push notifications tool with other details (for example, a message title and body).
4. Click on the **Send a Notification** button.
After sending the notification from the tool, you should see the notification on your device. Below is an example of an Android device receiving a push notification.


## Send notifications with the Expo Push Service

Learn how to call Expo Push Service API to send push notifications from your server.

The [`expo-notifications`](/versions/latest/sdk/notifications) library provides all the client-side functionality for push notifications. Expo also handles sending push notifications off to FCM and APNs which then send them to particular devices. All you need to do is send a request to Expo Push API with the `ExpoPushToken` you obtain with [`getExpoPushTokenAsync`](/versions/latest/sdk/notifications/#getexpopushtokenasyncoptions).
> If you'd rather build a server that communicates with APNs and FCM directly, see [Send notifications with FCM and APNs](/push-notifications/sending-notifications-custom/). It's more complex than using Expo Push Service, but allows finer-grained control, and full access to all FCM and APNs features.
## Send push notifications using a server
After you setup your push notification credentials and add logic to get the `ExpoPushToken`, you can send it to the Expo API using an HTTPS POST request. You can do this by setting up a server with a database (or you can also write a command line tool to send them or send them straight from your app).
The Expo team and community have taken care of creating back-ends for you in a few different languages:
| SDKs                                                                                                     | Back-end | Maintained by |
| -------------------------------------------------------------------------------------------------------- | -------- | ------------- |
| [expo-server-sdk-node](https://github.com/expo/expo-server-sdk-node)                                     | Node.js  | Expo team     |
| [expo-server-sdk-python](https://github.com/expo/expo-server-sdk-python)                                 | Python   | Community     |
| [expo-server-sdk-ruby](https://github.com/expo/expo-server-sdk-ruby)                                     | Ruby     | Community     |
| [expo-push-notification-client-rust](https://github.com/katayama8000/expo-push-notification-client-rust) | Rust     | Community     |
| [expo-notifier](https://github.com/symfony/expo-notifier)                                                | Symfony  | Symfony       |
| [exponent-server-sdk-php](https://github.com/Alymosul/exponent-server-sdk-php)                           | PHP      | Community     |
| [expo-server-sdk-php](https://github.com/ctwillie/expo-server-sdk-php)                                   | PHP      | Community     |
| [exponent-server-sdk-golang](https://github.com/oliveroneill/exponent-server-sdk-golang)                 | Golang   | Community     |
| [exponent](https://github.com/9ssi7/exponent)                                                            | Golang   | Community     |
| [exponent-server-sdk-elixir](https://github.com/pachun/exponent-server-sdk-elixir)                       | Elixir   | Community     |
| [expo-server-sdk-dotnet](https://github.com/glyphard/expo-server-sdk-dotnet)                             | dotnet   | Community     |
| [expo-server-sdk-java](https://github.com/hlspablo/expo-server-sdk-java)                                 | Java     | Community     |
| [laravel-expo-notifier](https://github.com/YieldStudio/laravel-expo-notifier)                            | Laravel  | Community     |
Each of the example servers above is a wrapper around Expo Push Service API.
## Implement push notifications reliably
Push Notifications travel through several systems from your server to recipient devices. Notifications are delivered most of the time. However, occasionally there are issues with systems along the way and the network connections between them. Handling errors helps push notifications to arrive at their destinations more reliably.
### Limit concurrent connections
When sending a large number of push notifications at once, limit the number of your concurrent connections. The [Node SDK](https://github.com/expo/expo-server-sdk-node) implements this for you and opens a maximum of six concurrent connections. This smooths out your peak load and helps the Expo push notification service receive push notification requests successfully.
### Retry on failure
The first step in sending push notifications is to deliver them to the Expo push notification service, which internally adds them to a queue for delivery to Google (FCM v1) and Apple (APNs). This first step can fail for several reasons:
- network issues between your server and the Expo push notification service
- an outage or degraded availability of the Expo notification service
- misconfigured push credentials
- an invalid notification payload
Some of these failures are temporary. For example, if the Expo push notification service is down or unreachable and you get a network error - a HTTP 429 error (Too Many Requests), or a HTTP 5xx error (Server Errors) - use [exponential backoff](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/) to wait a few seconds before retrying. If the first retry attempt is unsuccessful, wait for longer (follow exponential backoff) and retry again. This lets the temporarily unavailable service recover before you retry.
Other failures will not resolve themselves. For example, if your push notification payload is malformed, you may get an HTTP 400 response explaining the issue with the payload. You will also get an error if there are no push credentials for your project or if you send push notifications for different projects in the same request.
### Check push receipts for errors
The Expo push notification service responds with [**push tickets**](#push-tickets) upon successfully receiving notifications. A push ticket indicates that Expo has received your notification payload but may still need to send it. Each push ticket contains a ticket ID, which you later use to look up a [push receipt](#push-receipts). A push receipt is available after Expo has tried to deliver the notification to FCM or APNs. It tells you whether delivery to the push notification provider was successful.
You must check your push receipts. If there is an issue delivering push notifications, the push receipts are the best way to get information about the underlying cause. For example, the receipts may indicate a problem with FCMs or APNs, the Expo push notification service, or your notification payload.
Push receipts may also tell you if a recipient device has unsubscribed from notifications (for example, by revoking notification permissions or uninstalling your app) if APNs or FCM responds with that information. The push receipt will contain a `details` → `error` field set to `DeviceNotRegistered`. In this scenario, stop sending notifications to this device's push token until it re-registers with your server, so your app remains a good citizen. The `DeviceNotRegistered` error appears in push receipts only when Google or Apple deems the device to be unregistered. It takes an undefined amount of time and is often impossible to test by uninstalling your app and sending a push notification shortly after.
We recommend checking push receipts 15 minutes after sending your push notifications. While push receipts are often available much sooner, a 15-minute window gives the Expo push notification service a comfortable amount of time to make the receipts available to you. If after 15 minutes there is no push receipt, this likely indicates an error with the Expo push notification service. Lastly, push receipts are cleared after 24 hours.
### SLAs
The Expo push notification service does not have an SLA and the FCM and APNs services also may have occasional outages. By following the guidance above, you can make your application robust against temporary service interruptions.
## HTTP/2 API
Instead of using one of the libraries listed earlier, you may want to send requests directly to our HTTP/2 API (this API currently does not require any authentication).
To do so, send a POST request to `https://exp.host/--/api/v2/push/send` with the following HTTP headers:
```text
host: exp.host
accept: application/json
accept-encoding: gzip, deflate
content-type: application/json
```
This is a "hello world" push notification using cURL that you can send using your terminal (replace the placeholder push token with your own):
```sh
curl -H "Content-Type: application/json" -X POST "https://exp.host/--/api/v2/push/send" -d '{
  "to": "ExponentPushToken[xxxxxxxxxxxxxxxxxxxxxx]",
  "title":"hello",
  "body": "world"
}'
```
The request body must be JSON. It may either be a single [message object](#message-request-format) (as shown in the example above) or an array of up to 100 message objects, as long as they are all for the same project as shown below. **We recommend using an array when you want to send multiple messages to efficiently minimize the number of requests you need to make to Expo servers.** Here's an example request body that sends four messages:
```json
[
  {
    "to": "ExponentPushToken[xxxxxxxxxxxxxxxxxxxxxx]",
    "sound": "default",
    "body": "Hello world!"
  },
  {
    "to": "ExponentPushToken[yyyyyyyyyyyyyyyyyyyyyy]",
    "badge": 1,
    "body": "You've got mail"
  },
  {
    "to": [
      "ExponentPushToken[zzzzzzzzzzzzzzzzzzzzzz]",
      "ExponentPushToken[aaaaaaaaaaaaaaaaaaaaaa]"
    ],
    "body": "Breaking news!"
  }
]
```
The Expo Push Service also optionally accepts gzip-compressed request bodies. This can greatly reduce the amount of upload bandwidth needed to send large numbers of notifications. The [Node Expo Server SDK](https://github.com/expo/expo-server-sdk-node) automatically gzips requests for you and automatically throttles your requests to smooth out the load, so we highly recommend it.
### Push tickets
The requests above will respond with a JSON object with two optional fields, `data` and `errors`. `data` will contain an array of [**push tickets**](#push-ticket-format) in the same order in which the messages were sent (or one push ticket object, if you send a single message to a single recipient). Each ticket includes a `status` field indicating whether Expo successfully received the notification and, if successful, an `id` field that can be used to retrieve a push receipt later.
> A status of `ok` along with a receipt ID means that the message was received by Expo's servers, **not** that it was received by the user (for that you will need to check the [push receipt](#push-receipts)).
Continuing the above example, this is what a successful response body looks like:
```json
{
  "data": [
    { "status": "ok", "id": "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX" },
    { "status": "ok", "id": "YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY" },
    { "status": "ok", "id": "ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ" },
    { "status": "ok", "id": "AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA" }
  ]
}
```
If there were errors with individual messages, but not the entire request, the bad messages' corresponding push tickets will have a status of `error`, and fields that describe the error as shown below:
```json
{
  "data": [
    {
      "status": "error",
      "message": "\"ExponentPushToken[xxxxxxxxxxxxxxxxxxxxxx]\" is not a registered push notification recipient",
      "details": {
        "error": "DeviceNotRegistered"
      }
    },
    {
      "status": "ok",
      "id": "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
    }
  ]
}
```
If the entire request failed, the HTTP status code is 4xx or 5xx and the `errors` field will be an array of error objects (usually just one). Otherwise, the HTTP status code will be 200 and your messages will be on their way to the Android and iOS push notification services.
### Push receipts
After receiving a batch of notifications, Expo enqueues each notification to deliver to the Android and iOS push notification services (FCM and APNs, respectively). Most notifications are typically delivered within a few seconds. However, sometimes it may take longer to deliver notifications, particularly if the Android or iOS push notification services take longer than usual to receive and deliver notifications or if Expo's Push Service infrastructure is under high load.
Once Expo delivers a notification to the Android or iOS push notification service, Expo creates a [**push receipt**](#push-receipt-response-format) that indicates whether the Android or iOS push notification service successfully received the notification. If there was an error in delivering the notification, perhaps due to faulty credentials or service downtime, the push receipt will contain more information regarding that error.
To fetch the push receipts, send a POST request to `https://exp.host/--/api/v2/push/getReceipts`. The [request body](#push-receipt-request-format) must be a JSON object with a field name `ids` that is an array of ticket ID strings:
```sh
curl -H "Content-Type: application/json" -X POST "https://exp.host/--/api/v2/push/getReceipts" -d '{
  "ids": [
    "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX",
    "YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY",
    "ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ"
  ]
}'
```
The [response body](#push-receipt-response-format) for push receipts is very similar to that of push tickets; it is a JSON object with two optional fields, `data` and `errors`. `data` contains a mapping of receipt IDs to receipts. Receipts include a `status` field, and two optional `message` and `details` fields (in the case where `"status": "error"`). If there is no push receipt for a requested receipt ID, the mapping won't contain that ID. This is what a successful response to the above request looks like:
```json
{
  "data": {
    "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX": { "status": "ok" },
    "ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ": { "status": "ok" }
    // When there is no receipt with a given ID (YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY in this
    // example), the ID is omitted from the response.
  }
}
```
**You must check each push receipt, since it may contain information about errors you need to resolve.** For example, if a device is no longer eligible to receive notifications, Apple's documentation asks that you stop sending notifications to that device. The push receipts contain information about these errors.
> Even if a receipt's `status` says `ok`, this doesn't guarantee that the device has received the message; "ok" in a push receipt means that the Android (FCM) or iOS (APNs) push notification service successfully received the notification. If the recipient device is turned off, for example, the iOS or Android push notification service will try to deliver the message but the device won't necessarily receive it.
If the entire request failed, the HTTP status code will be 4xx or 5xx and the `errors` field will be an array of error objects (usually just one). Otherwise, the HTTP status code will be 200 and your messages will be on their way to your users' devices.
## Errors
Expo provides details regarding any errors that occur during this entire process. We'll cover some of the most common errors below so that you can implement logic to handle them automatically on your server.
If for whatever reason, Expo couldn't deliver the message to the Android or iOS push notification service, the push receipt's details may also include service-specific information. This is useful mostly for debugging and reporting possible bugs to Expo.
### Individual errors
Inside both push tickets and push receipts, look for a `details` object with an `error` field. If present, it may be one of the following values, and you should handle these errors like so:
### Push ticket errors
- `DeviceNotRegistered`: The device cannot receive push notifications anymore and you should stop sending messages to the corresponding Expo push token.
### Push receipt errors
- `DeviceNotRegistered`: The device cannot receive push notifications anymore and you should stop sending messages to the corresponding Expo push token.
- `MessageTooBig`: The total notification payload was too large. On Android and iOS, the total payload must be at most 4096 bytes.
- `MessageRateExceeded`: You are sending messages too frequently to the given device. Implement exponential backoff and slowly retry sending messages.
- `MismatchSenderId`: This indicates that there is an issue with your FCM push credentials. There are two pieces to FCM push credentials: your FCM server key, and your **google-services.json** file. Both must be associated with the same sender ID. You can find your sender ID in the [same place you find your server key](/push-notifications/push-notifications-setup/#upload-server-credentials). Check that the server key from your project's EAS dashboard under **Credentials** > **Application identifier** > **Service Credentials** > **FCM V1 service account key** and that the sender ID from your project's **google-services.json** > `project_number` is the same as shown in the Firebase console under **Project Settings** > **Cloud Messaging** tab > **Cloud Messaging API (Legacy)**.
- `InvalidCredentials`: Your push notification credentials for your standalone app are invalid (for example, you may have revoked them).
  - **Android**: Make sure that you have correctly uploaded the server key from the Firebase Console as specified in [uploading FCM V1 server credentials](/push-notifications/fcm-credentials).
  - **iOS**: Run `eas credentials` and follow the prompts to regenerate new push notification credentials. If you revoke an APN key, all apps that rely on that key will no longer be able to send or receive push notifications until you upload a new key to replace it. Uploading a new APN key will **not** change your users' Expo Push Tokens. Sometimes, these errors will contain further details claiming an `InvalidProviderToken` error. This is actually tied to both your APN key **and** your provisioning profile. To resolve this error, you should rebuild the app and regenerate a new push key and provisioning profile.
> For a better understanding of iOS credentials, including push notification credentials, read our [App Signing docs](/app-signing/app-credentials#ios).
### Request errors
If there's an error with the entire request for either push tickets or push receipts, the `errors` object might have one of the following values, and you should handle these errors:
- `TOO_MANY_REQUESTS`: You are exceeding the request limit of 600 notifications per second per project. We recommend implementing rate-limiting in your server to prevent sending more than 600 notifications per second (note that if you use [expo-server-sdk-node](https://github.com/expo/expo-server-sdk-node), this is already implemented along with exponential backoffs for retries).
- `PUSH_TOO_MANY_EXPERIENCE_IDS`: You are trying to send push notifications to different Expo experiences, for example, `@username/projectAAA` and `@username/projectBBB`. Check the `details` field for a mapping of experience names to their associated push tokens from the request, and remove any from another experience.
- `PUSH_TOO_MANY_NOTIFICATIONS`: You are trying to send more than 100 push notifications in one request. Make sure you are only sending 100 (or fewer) notifications in each request.
- `PUSH_TOO_MANY_RECEIPTS`: You are trying to get more than 1000 push receipts in one request. Make sure you are only sending an array of 1000 (or fewer) ticket ID strings to get your push receipts.
## Additional security
You can require any push requests to be sent with a valid [access token](/accounts/programmatic-access) before we will deliver them to your users. You can enable this enhanced push security from your [EAS Dashboard](https://expo.dev/settings/access-tokens).
By default, you can send a notification to your users by sending their Expo Push Token and any text or additional data needed for the message. This is easy to set up, but **if the tokens are leaked, a malicious user would be able to impersonate your server and send their message to your users.** We have never had an instance of this report. However, to follow best security practices, we offer the use of an access token alongside the push token as an additional layer of security.
If you're using the [`expo-server-sdk-node`](https://github.com/expo/expo-server-sdk-node#usage), upgrade to at least `v3.6.0` and pass your `accessToken` as an option in the constructor. Otherwise, pass in the header `'Authorization': 'Bearer ${accessToken}'` with any requests to our push API.
Any requests sent _without_ a valid access token _after_ you enable push security will result in an error with code: `UNAUTHORIZED`.
## Formats
### Message request format
Each message must be a JSON object with the given fields (only the `to` field is required):
| Field               | Platform        | Type                                                      | Description                                                                                                                                                                                                                                                                                                                                                               |
| ------------------- | --------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `to`                | Android and iOS | `string \| string[]`                                      | An Expo push token or an array of Expo push tokens specifying the recipient(s) of this message.                                                                                                                                                                                                                                                                           |
| `_contentAvailable` | iOS Only        | `boolean \| undefined`                                    | When this is set to true, the notification will cause the iOS app to start in the background to run a [background task](/versions/latest/sdk/notifications/#background-notifications). Your app needs to be [configured](/versions/latest/sdk/notifications/#background-notification-configuration) to support this.                                                      |
| `data`              | Android and iOS | `Object`                                                  | A JSON object delivered to your app. It may be up to about 4KiB; the total notification payload sent to Apple and Google must be at most 4KiB or else you will get a "Message Too Big" error.                                                                                                                                                                             |
| `title`             | Android and iOS | `string`                                                  | The title to display in the notification. Often displayed above the notification body. Maps to [`AndroidNotification.title`](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification) and [`aps.alert.title`](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Payload-key-reference).   |
| `body`              | Android and iOS | `string`                                                  | The message to display in the notification. Maps to [`AndroidNotification.body`](https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification) and [`aps.alert.body`](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Payload-key-reference).                                                |
| `ttl`               | Android and iOS | `number`                                                  | Time to Live: the number of seconds for which the message may be kept around for redelivery if it hasn't been delivered yet. Defaults to `undefined` to use the respective defaults of each provider (1 month for Android/FCM as well as iOS/APNs).                                                                                                                       |
| `expiration`        | Android and iOS | `number`                                                  | Timestamp since the Unix epoch specifying when the message expires. Same effect as `ttl` (`ttl` takes precedence over `expiration`).                                                                                                                                                                                                                                      |
| `priority`          | Android and iOS | `'default' \| 'normal' \| 'high'`                         | The delivery priority of the message. Specify `default` or omit this field to use the default priority on each platform ("normal" on Android and "high" on iOS).                                                                                                                                                                                                          |
| `subtitle`          | iOS Only        | `string`                                                  | The subtitle to display in the notification below the title. Maps to [`aps.alert.subtitle`](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Payload-key-reference).                                                                                                                                                          |
| `sound`             | iOS Only        | `string \| null`                                          | Play a sound when the recipient receives this notification. Specify `default` to play the device's default notification sound, or omit this field to play no sound. Custom sounds need to be [configured](/versions/latest/sdk/notifications/#configurable-properties) via the config plugin and then specified including the file extension. Example: `bells_sound.wav`. |
| `badge`             | iOS Only        | `number`                                                  | Number to display in the badge on the app icon. Specify zero to clear the badge.                                                                                                                                                                                                                                                                                          |
| `interruptionLevel` | iOS Only        | `'active' \| 'critical' \| 'passive' \| 'time-sensitive'` | The importance and delivery timing of a notification. The string values correspond to the [`UNNotificationInterruptionLevel`](https://developer.apple.com/documentation/usernotifications/unnotificationinterruptionlevel) enumeration cases.                                                                                                                             |
| `channelId`         | Android Only    | `string`                                                  | ID of the Notification Channel through which to display this notification. If an ID is specified but the corresponding channel does not exist on the device (that has not yet been created by your app), the notification will not be displayed to the user.                                                                                                              |
| `icon`              | Android Only    | `string`                                                  | The notification's icon. Name of an Android drawable resource (example: `myicon`). Defaults to the icon specified in the [config plugin](/versions/latest/sdk/notifications/#configurable-properties).                                                                                                                                                                    |
| `richContent`       | Android and iOS | `Object`                                                  | Currently supports setting a notification image. Provide an object with key `image` and value of type `string`, which is the image URL. Android will show the image out of the box. On iOS, you need to add a Notification Service Extension target to your app. See [this example](https://github.com/expo/expo/pull/36202) on how to do that.                           |
| `categoryId`        | Android and iOS | `string`                                                  | ID of the notification category that this notification is associated with. [Find out more about notification categories here](/versions/latest/sdk/notifications/#manage-notification-categories-interactive-notifications).                                                                                                                                              |
| `mutableContent`    | iOS Only        | `boolean`                                                 | Specifies whether this notification can be [intercepted by the client app](https://developer.apple.com/documentation/usernotifications/modifying_content_in_newly_delivered_notifications?language=objc). Defaults to `false`.                                                                                                                                            |
**Note on `ttl`**: On Android, we make our best effort to deliver messages with zero TTL immediately and do not throttle them. However, setting TTL to a low value (for example, zero) can prevent normal-priority notifications from ever reaching Android devices that are in doze mode. To guarantee that a notification is delivered, TTL must be long enough for the device to wake from doze mode. This field takes precedence over `expiration` when both are specified.
**Note on `priority`**: On Android, normal-priority messages won't open network connections on sleeping devices and their delivery may be delayed to conserve the battery. High-priority messages are more likely to be delivered immediately and may wake sleeping devices to open network connections, consuming energy. On iOS, normal-priority messages are sent at a time that takes into account power considerations for the device and may be grouped and delivered in bursts. They are throttled and may not be delivered by Apple. High-priority messages are usually sent immediately. Normal priority corresponds to APNs priority level 5 and high priority to 10.
**Note on `channelId`**: If left null, a "Default" channel is used, and Expo creates the channel on the device if it does not yet exist. However, use caution, as the "Default" channel is user-facing and you may not be able to fully delete it.
### Push ticket format
```js
{
  "data": [
    {
      "status": "error" | "ok",
      "id": string, // this is the Receipt ID
      // if status === "error"
      "message": string,
      "details": JSON
    },
    ...
  ],
  // only populated if there was an error with the entire request
  "errors": [{
    "code": string,
    "message": string
  }]
}
```
### Push receipt request format
```js
{
  "ids": string[]
}
```
### Push receipt response format
```js
{
  "data": {
    Receipt ID: {
      "status": "error" | "ok",
      // if status === "error"
      "message": string,
      "details": JSON
    },
    ...
  },
  // only populated if there was an error with the entire request
  "errors": [{
    "code": string,
    "message": string
  }]
}
```
## Delivery guarantees
Expo makes a best effort to deliver notifications to the push notification services operated by Google and Apple. Expo's infrastructure is designed for at least one attempt at delivery to the underlying push notification services. It is more likely for a notification to be delivered to Google or Apple more than once rather than not at all; however, both these results are uncommon.
After a notification has been handed off to an underlying push notification service, Expo creates a "push receipt" that records whether the handoff was successful. A push receipt denotes whether the underlying push notification service received the notification.
Finally, the push notification services from Google and Apple follow their own policies to deliver the notifications to the device.
## Troubleshooting
Note: Network connectivity issues
---
This section helps you diagnose and resolve common network issues. Your server must have connectivity to Google Cloud Platform services in the United States region, as this is where Expo's push notification service is hosted.
#### DNS resolution
Test if your server can resolve Expo's push service domain name:
```bash
dig exp.host
# Check with a public DNS server
dig @8.8.8.8 exp.host
```
#### Network routing and connectivity
Verify your server can reach Expo's endpoints:
```bash
# Use traceroute to identify routing issues
traceroute exp.host
# Test basic connectivity
ping exp.host
# Test HTTPS connectivity to the push server.
# You should receive HTTP response headers with a 200 status code.
curl --verbose https://exp.host/
```
Common issues to check:
- Firewall rules blocking outbound HTTPS (port 443) traffic
- Corporate proxy servers that may require authentication or special configuration
- Network ACLs or security groups (in cloud environments) restricting outbound connections
- Packet fragmentation due to MTU size issues
#### TLS certificate validation
Ensure your server can validate the server's TLS certificate:
```bash
openssl s_client -connect exp.host:443 -servername exp.host
```
We use standard TLS certificates signed by major service providers including Cloudflare, Google, and Let's Encrypt.
---


## Handle incoming notifications

Learn how to respond to a notification received by your app and take action based on the event.

The [`expo-notifications`](/versions/latest/sdk/notifications) library contains event listeners that handle how your app responds when receiving a notification.
## Notification event listeners
The [`addNotificationReceivedListener`](/versions/latest/sdk/notifications/#addnotificationreceivedlistenerlistener) and [`addNotificationResponseReceivedListener`](/versions/latest/sdk/notifications/#addnotificationresponsereceivedlistenerlistener) event listeners receive an object when a notification is received or interacted with.
These listeners allow you to add behavior when notifications are received while your app is open and foregrounded and when your app is backgrounded or closed and the user taps on the notification.
```js
useEffect(() => {
  registerForPushNotificationsAsync().then(token => setExpoPushToken(token));
  const notificationListener = Notifications.addNotificationReceivedListener(notification => {
    console.log(notification);
  });
  const responseListener = Notifications.addNotificationResponseReceivedListener(response => {
    console.log(response);
  });
  return () => {
    notificationListener.remove();
    responseListener.remove();
  };
}, []);
```
Note: Android notification object example from 
---
Sample of the `notification` object received by the callback function when using `Notifications.addNotificationReceivedListener`:
```json
// console.log(notification);
{
  "request": {
    "trigger": {
      "remoteMessage": {
        "originalPriority": 2,
        "sentTime": 1724782348210,
        "notification": {
          "usesDefaultVibrateSettings": false,
          "color": null,
          "channelId": null,
          "visibility": null,
          "sound": null,
          "tag": null,
          "bodyLocalizationArgs": null,
          "imageUrl": null,
          "title": "Chat App",
          "ticker": null,
          "eventTime": null,
          "body": "New message from John Doe",
          "titleLocalizationKey": null,
          "notificationPriority": null,
          "icon": null,
          "usesDefaultLightSettings": false,
          "sticky": false,
          "link": null,
          "titleLocalizationArgs": null,
          "bodyLocalizationKey": null,
          "usesDefaultSound": false,
          "clickAction": null,
          "localOnly": false,
          "lightSettings": null,
          "notificationCount": null
        },
        "data": {
          "channelId": "default",
          "message": "New message from John Doe",
          "title": "Chat App",
          "body": "{\"senderId\":\"user123\",\"senderName\":\"John Doe\",\"messageId\":\"msg789\",\"conversationId\":\"conversation-456\",\"messageType\":\"text\",\"timestamp\":1724766427}",
          "scopeKey": "@betoatexpo/expo-notifications-app",
          "experienceId": "@betoatexpo/expo-notifications-app",
          "projectId": "51092087-87a4-4b12-8008-145625477434"
        },
        "to": null,
        "ttl": 0,
        "collapseKey": "dev.expo.notificationsapp",
        "messageType": null,
        "priority": 2,
        "from": "115310547649",
        "messageId": "0:1724782348220771%0f02879c0f02879c"
      },
      "channelId": "default",
      "type": "push"
    },
    "content": {
      "autoDismiss": true,
      "title": "Chat App",
      "badge": null,
      "sticky": false,
      "sound": "default",
      "body": "New message from John Doe",
      "subtitle": null,
      "data": {
        "senderId": "user123",
        "senderName": "John Doe",
        "messageId": "msg789",
        "conversationId": "conversation-456",
        "messageType": "text",
        "timestamp": 1724766427
      }
    },
    "identifier": "0:1724782348220771%0f02879c0f02879c"
  },
  "date": 1724782348210
}
```
You can directly access the notification custom data by logging the `notification.request.content.data` object:
```json
// console.log(notification.request.content.data);
{
  "senderId": "user123",
  "senderName": "John Doe",
  "messageId": "msg789",
  "conversationId": "conversation-456",
  "messageType": "text",
  "timestamp": 1724766427
}
```
---
Note: iOS notification object example from 
---
Sample of the `notification` object received by the callback function when using `Notifications.addNotificationReceivedListener`:
```json
// console.log(notification);
{
  "request": {
    "trigger": {
      "class": "UNPushNotificationTrigger",
      "type": "push",
      "payload": {
        "experienceId": "@betoatexpo/expo-notifications-app",
        "projectId": "51092087-87a4-4b12-8008-145625477434",
        "scopeKey": "@betoatexpo/expo-notifications-app",
        "aps": {
          "thread-id": "",
          "category": "",
          "badge": 1,
          "alert": {
            "subtitle": "Hey there! How's your day going?",
            "title": "Chat App",
            "launch-image": "",
            "body": "New message from John Doe"
          },
          "sound": "default"
        },
        "body": {
          "messageId": "msg789",
          "timestamp": 1724766427,
          "messageType": "text",
          "senderId": "user123",
          "senderName": "John Doe",
          "conversationId": "conversation-456"
        }
      }
    },
    "identifier": "3AEB849E-9059-4D09-BC3B-9A0B104CF062",
    "content": {
      "body": "New message from John Doe",
      "sound": "default",
      "launchImageName": "",
      "badge": 1,
      "subtitle": "Hey there! How's your day going?",
      "title": "Chat App",
      "data": {
        "conversationId": "conversation-456",
        "senderName": "John Doe",
        "senderId": "user123",
        "messageType": "text",
        "timestamp": 1724766427,
        "messageId": "msg789"
      },
      "summaryArgument": null,
      "categoryIdentifier": "",
      "attachments": [],
      "interruptionLevel": "active",
      "threadIdentifier": "",
      "targetContentIdentifier": null,
      "summaryArgumentCount": 0
    }
  },
  "date": 1724798493.0589335
}
```
You can directly access the notification custom data by logging the `notification.request.content.data` object:
```json
// console.log(notification.request.content.data);
{
  "senderId": "user123",
  "senderName": "John Doe",
  "messageId": "msg789",
  "conversationId": "conversation-456",
  "messageType": "text",
  "timestamp": 1724766427
}
```
---
For more information on these objects, see [`Notification`](/versions/latest/sdk/notifications/#notification) documentation.
## Foreground notification behavior
To handle the behavior when notifications are received when your app is **foregrounded**, use [`Notifications.setNotificationHandler`](/versions/latest/sdk/notifications/#handling-incoming-notifications-when-the-app-is) with the `handleNotification()` callback to set the following options:
- `shouldPlaySound`
- `shouldSetBadge`
- `shouldShowBanner`
- `shouldShowList`
```jsx
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldPlaySound: false,
    shouldSetBadge: false,
    shouldShowBanner: true,
    shouldShowList: true,
  }),
});
```
## Closed notification behavior
On Android, users can set certain OS-level settings, usually revolving around performance and battery optimization, that can prevent notifications from being delivered when the app is closed. For example, one such setting is the **Deep Clear** option on OnePlus devices using Android 9 and lower versions.


# Reference

## Obtain Google Service Account Keys using FCM V1

Learn how to create or use a Google Service Account Key for sending Android Notifications using FCM.

## Create a new Google Service Account Key
Here are the steps to configure a new Google Service Account Key in EAS for sending Android Notifications using FCM V1.
Step 1: 
Create a new Firebase project for your app in the [Firebase Console](https://console.firebase.google.com). If you already have a Firebase project for your app, continue to the next step.
Step 2: 
In the Firebase console, open **Project settings** > [**Service accounts**](https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk) for your project.
Step 3: 
Click **Generate New Private Key**, then confirm by clicking **Generate Key**. Securely store the JSON file containing the private key.
Step 4: 
Upload the JSON file to EAS and configure it for sending Android notifications. This can be done using EAS CLI or in [EAS dashboard](https://expo.dev).
- Run `eas credentials`
- Select `Android` > `production` > `Google Service Account`
- Select `Manage your Google Service Account Key for Push Notifications (FCM V1)`
- Select `Set up a Google Service Account Key for Push Notifications (FCM V1)` > `Upload a new service account key`
- If you've previously stored the JSON file in your project directory, the EAS CLI automatically detects the file and prompts you to select it. Press <kbd>Y</kbd> to continue.
> **Note**: Add the JSON file to your version source control's ignore file (for example, **.gitignore**) to avoid committing it to your repository since it contains sensitive data.
- Under **Project settings**, click [**Credentials**](https://expo.dev/accounts/[account]/projects/[project]/credentials) in the navigation menu
- For **Android**, click **Add Application Identifier** or select an existing **Application identifier**
- Under **Service Credentials** > **FCM V1 service account key**, click **Add a service account key**
- Under **Upload new key**, upload your JSON credential and click **Save**
Step 5: 
Configure the **google-services.json** file in your project. Download it from the Firebase Console and place it at the root of your project directory.
This file is required for your Android app to be registered with FCM. You may commit this file to your repository since it contains public-facing identifiers from your Firebase project.
**Note**: You can skip this step if **google-services.json** has already been set up.
In **app.json**, add [`expo.android.googleServicesFile`](/versions/latest/config/app/#googleservicesfile) with its value as the path of the **google-services.json**.
```json app.json
{
  "expo": {
  "android": {
    "googleServicesFile": "./path/to/google-services.json"
  }
}
```
Step 6: 
You're all set! You can now send notifications to Android devices via Expo Push Notifications using the FCM V1 protocol.
## Use an existing Google Service Account Key
Step 1: 
Open the [IAM Admin page](https://console.cloud.google.com/iam-admin/iam?authuser=0) in Google Cloud Console. In the Permissions tab, locate the **Principal** you intend to modify and click the pencil icon for **Edit Principal**.
Step 2: 
Click **Add Role** and select the **Firebase Messaging API Admin** role from the dropdown. Click **Save**.
Step 3: 
You have to specify to EAS which JSON credential file to use for sending FCM V1 notifications, using EAS CLI or in [EAS dashboard](https://expo.dev). You can upload a new JSON file or select a previously uploaded file.
- Run `eas credentials`
- Select `Android` > `production` > `Google Service Account`
- Select `Manage your Google Service Account Key for Push Notifications (FCM V1)`
- Select `Set up a Google Service Account Key for Push Notifications (FCM V1)` > `Upload a new service account key`
- The EAS CLI automatically detects the file on your local machine and prompts you to select it. Press <kbd>Y</kbd> to continue.
> **Note**: Add the JSON file to your version source control's ignore file (for example, **.gitignore**) to avoid committing it to your repository since it contains sensitive data.
- Under **Project settings**, click [**Credentials**](https://expo.dev/accounts/[account]/projects/[project]/credentials) in the navigation menu
- For **Android**, click **Add Application Identifier** or select an existing **Application identifier**
- Under **Service Credentials** > **FCM V1 service account key**, click **Add a service account key**
- Under **Upload new key**, upload your JSON credential and click **Save**
Step 4: 
Configure the **google-services.json** file in your project. Download it from the Firebase Console and place it at the root of your project directory.
This file is required for your Android app to be registered with FCM. You may commit this file to your repository since it contains public-facing identifiers from your Firebase project.
**Note**: You can skip this step if **google-services.json** has already been set up.
In **app.json**, add [`expo.android.googleServicesFile`](/versions/latest/config/app/#googleservicesfile) with its value as the path of the **google-services.json**.
```json app.json
{
  "expo": {
    "android": {
    }
  }
}
```
Step 5: 
You're all set! You can now send notifications to Android devices via Expo Push Notifications using the FCM V1 protocol.


## Send notifications with FCM and APNs

Learn how to send notifications with FCM and APNs.

You may need finer-grained control over your notifications, in which case communicating directly with FCM and APNs may be necessary. The Expo platform does not lock you into using Expo Application Services, and the `expo-notifications` API is push-service agnostic.
> **Note**: This guide does not aim to be a comprehensive resource for sending notifications via FCM or APNs. We recommend you read the official documentation to make sure you're following the latest instructions.
## Obtaining a device token for FCM or APNs
When using Expo notification service, you use the `ExpoPushToken` obtained with [`getExpoPushTokenAsync`](/versions/latest/sdk/notifications/#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken).
If you instead want to send notifications via FCM or APNs, you need to obtain the native device token with [`getDevicePushTokenAsync`](/versions/latest/sdk/notifications/#getdevicepushtokenasync-devicepushtoken).
```diff
diff --git a/App.js b/App.js
index 0000000..1111111 100644
--- a/App.js
+++ b/App.js
@@ -1,4 +1,4 @@
 import * as Notifications from 'expo-notifications';
 // ...
-const token = (await Notifications.getExpoPushTokenAsync()).data;
+const token = (await Notifications.getDevicePushTokenAsync()).data;
 // send token to your server
```
## FCMv1 server
This guide is based on [Firebase official documentation](https://firebase.google.com/docs/cloud-messaging/server).
Communicating with FCM is done by sending a POST request. However, before sending or receiving any notifications, you'll need to follow the steps to [configure FCM](/push-notifications/fcm-credentials/) and get your `FCM-SERVER-KEY`.
### Getting an authentication token
FCM requires an Oauth 2.0 access token, which must be obtained via one of the methods described in ["Update authorization of send requests"](https://firebase.google.com/docs/cloud-messaging/migrate-v1#update-authorization-of-send-requests).
For testing purposes, you can use the Google Auth Library and your private key file obtained above, to obtain a short lived token for a single notification, as in this Node example adapted from Firebase documentation:
```ts
import { JWT } from 'google-auth-library';
function getAccessTokenAsync(
  key: string // Contents of your FCM private key file
) {
  return new Promise(function (resolve, reject) {
    const jwtClient = new JWT(
      key.client_email,
      null,
      key.private_key,
      ['https://www.googleapis.com/auth/cloud-platform'],
      null
    );
    jwtClient.authorize(function (err, tokens) {
      if (err) {
        reject(err);
        return;
      }
      resolve(tokens.access_token);
    });
  });
}
```
### Sending the notification
The example code below calls `getAccessTokenAsync()` above to get the Oauth 2.0 token, then constructs and sends the notification POST request. Note that unlike FCM legacy protocol, the endpoint for the request includes the name of your Firebase project.
```ts
// FCM_SERVER_KEY: Environment variable with the path to your FCM private key file
// FCM_PROJECT_NAME: Your Firebase project name
// FCM_DEVICE_TOKEN: The client's device token (see above in this document)
async function sendFCMv1Notification() {
  const key = require(process.env.FCM_SERVER_KEY);
  const firebaseAccessToken = await getAccessTokenAsync(key);
  const fcmToken = process.env.FCM_DEVICE_TOKEN;
  const messageBody = {
    message: {
      token: fcmToken,
      data: {
        channelId: 'default',
        message: 'Testing',
        title: `This is an FCM notification message`,
        body: JSON.stringify({ title: 'bodyTitle', body: 'bodyBody' }),
        scopeKey: '@yourExpoUsername/yourProjectSlug',
        experienceId: '@yourExpoUsername/yourProjectSlug',
      },
    },
  };
  const response = await fetch(
    `https://fcm.googleapis.com/v1/projects/${process.env.FCM_PROJECT_NAME}/messages:send`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${firebaseAccessToken}`,
        Accept: 'application/json',
        'Accept-encoding': 'gzip, deflate',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(messageBody),
    }
  );
  const readResponse = (response: Response) => response.json();
  const json = await readResponse(response);
  console.log(`Response JSON: ${JSON.stringify(json, null, 2)}`);
}
```
The `experienceId` and `scopeKey` fields are only applicable when using Expo Go (from SDK 53, push notifications support is removed from Expo Go). Otherwise, your notifications will not go through to your app. FCM has a list of supported fields in the [notification payload](https://firebase.google.com/docs/cloud-messaging/http-server-ref#notification-payload-support), and you can see which ones are supported by `expo-notifications` on Android by looking at the [FirebaseRemoteMessage](/versions/latest/sdk/notifications/#firebaseremotemessage).
FCM also provides some [server-side libraries in a few different languages](https://firebase.google.com/docs/cloud-messaging/send-message#node.js) you can use instead of raw `fetch` requests.
### How to find FCM server key
Your FCM server key can be found by making sure you've followed the [configuration steps](/push-notifications/push-notifications-setup/#android), and instead of uploading your FCM key to Expo, you would use that key directly in your server (as the `FCM-SERVER-KEY` in the previous example).
## APNs server
> **info** This documentation is based on [Apple's documentation](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html), and this section covers the basics to get you started.
Communicating with APNs is a little more complicated than with FCM. Some libraries wrap all of this functionality into one or two function calls such as [`node-apn`](https://github.com/node-apn/node-apn). However, in the examples below, a minimum set of libraries are used.
### Client APNs entitlement
Receiving push notifications only works if your iOS app has the APNs entitlement. For apps using [CNG](/workflow/continuous-native-generation/),
the Expo config needs to be modified in one of two ways:
- **Recommended**: Add the `expo-notifications` library to your app, and ensure that its plugin appears in the `plugins` array of your [app config](/workflow/configuration/):
```json app.json
{
  "expo": {
    "plugins": [
      "expo-notifications"
      ]
  }
}
```
- If you do not plan to use the `expo-notifications` library, then you should [add the `aps-environment` entitlement manually to the Expo configuration](/build-reference/ios-capabilities/#entitlements),
  as in the example below:
```json app.json
{
  "expo": {
    "ios": {
      "entitlements": {
        "aps-environment": "development"
      }
    }
  }
}
```
If you are not using CNG, then you should [add the push notification entitlement in Xcode](https://developer.apple.com/documentation/usernotifications/registering-your-app-with-apns).
> **Note**: If you are upgrading an Expo app from a version from SDK 51 and earlier, you should refer to [this FYI document](https://expo.fyi/apns-entitlement-sdk-51).
### Authorization
Initially, before sending requests to APNS, you need permission to send notifications to your app. This is granted via a JSON web token which is generated using iOS developer credentials:
- APN key (`.p8` file) associated with your app
- Key ID of the above `.p8` file
- Your Apple Team ID
```js
const jwt = require("jsonwebtoken");
const authorizationToken = jwt.sign(
  {
    iss: "YOUR-APPLE-TEAM-ID"
    iat: Math.round(new Date().getTime() / 1000),
  },
  fs.readFileSync("./path/to/appName_apns_key.p8", "utf8"),
  {
    header: {
      alg: "ES256",
      kid: "YOUR-P8-KEY-ID",
    },
  }
);
```
### HTTP/2 connection
After getting the `authorizationToken`, you can open up an HTTP/2 connection to Apple's servers. In development, send requests to `api.sandbox.push.apple.com`. In production, send requests to `api.push.apple.com`.
Here's how to construct the request:
```js
const http2 = require('http2');
const client = http2.connect(
  IS_PRODUCTION ? 'https://api.push.apple.com' : 'https://api.sandbox.push.apple.com'
);
const request = client.request({
  ':method': 'POST',
  ':scheme': 'https',
  'apns-topic': 'YOUR-BUNDLE-IDENTIFIER',
  ':path': '/3/device/' + nativeDeviceToken, // This is the native device token you grabbed client-side
  authorization: `bearer ${authorizationToken}`, // This is the JSON web token generated in the "Authorization" step
});
request.setEncoding('utf8');
request.write(
  JSON.stringify({
    aps: {
      alert: {
        title: "\uD83D\uDCE7 You've got mail!",
        body: 'Hello world! \uD83C\uDF10',
      },
    },
    experienceId: '@yourExpoUsername/yourProjectSlug', // Required only when testing in legacy Expo Go (in SDK 52 and earlier)
    scopeKey: '@yourExpoUsername/yourProjectSlug', // Required only when testing in legacy Expo Go (in SDK 52 and earlier)
  })
);
request.end();
```
> This example is minimal and includes no error handling and connection pooling. For testing purposes, you can refer to [`sendNotificationToAPNS`](https://github.com/expo/expo/blob/main/docs/public/static/examples/sendNotificationToAPNS.js) example code.
APNs provide their full list of supported fields in the [notification payload](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Payload-key-reference).


## Push notifications troubleshooting and FAQ

A collection of common questions about Expo push notification service.

A collection of common issues and FAQs when setting up push notifications with the `expo-notifications` library and Expo push notification service.
## Expo push notification service FAQ
### Cost of the push notification service
There is no cost associated with sending notifications through Expo push notification service.
### Limit of sending notifications
There is a limit of 600 notifications per second per project that can be sent. If you exceed this rate, subsequent requests will fail until the rate falls below 600 per second again.
For best results, we recommend you add throttling (which is handled automatically in the [`expo-server-sdk-node`](https://github.com/expo/expo-server-sdk-node)) and retry logic to your server.
### Using Expo push notification service is not mandatory
You can use any push notification service for Expo projects. The [`getDevicePushTokenAsync` method from `expo-notifications`](/versions/latest/sdk/notifications/#getdevicepushtokenasync-devicepushtoken) allows you to get the native device push token, which you can then use with other services, or even [send your notifications directly through FCM and APNs](/push-notifications/sending-notifications-custom).
### Connections to notification service are encrypted
Expo's connections to Apple and Google are encrypted and use HTTPS.
### Contents of the notification are not stored
Expo doesn't store the contents of push notifications any longer than it takes to deliver them to the push notification services operated by Google and Apple. Notifications are stored only in memory and in message queues, not in databases.
### Contents of the notifications may be seen by Expo staff
If the Expo team is actively debugging the push notifications service, we may see notification contents (for example, at a breakpoint) but Expo cannot see push notification contents otherwise.
### Delivery guarantees
Expo makes the best effort to deliver notifications to the push notification services operated by Google and Apple. Expo's infrastructure is designed for at-least-once delivery to the underlying push notification services. In some cases, a notification may be delivered to Google or Apple more than once or not at all, although these cases are rare.
After a notification has been handed off to an underlying push notification service, Expo creates a "push receipt" that records whether the handoff was successful. A push receipt denotes whether the underlying push notification service received the notification.
Finally, the push notification services from Google and Apple follow their policies to deliver the notification to the device.
### When and why does the `ExpoPushToken` change
The `ExpoPushToken` remains the same across app upgrades. On Android, reinstalling the app may result in the token changing. On iOS, the token also remains the same even after uninstalling the app and reinstalling it.
It also changes if you change your [`applicationId`](/versions/latest/sdk/application/#applicationapplicationid) or `experienceId` (usually `@expoUsername/projectSlug`).
The `ExpoPushToken` never expires. However, if one of your users uninstalls the app, you'll receive a `DeviceNotRegistered` error back from Expo's servers. This means you should stop sending notifications to this token.
## Push notifications troubleshooting
### Notifications aren't working
Push notifications have a lot of moving parts, so this can be due to a wide variety of reasons. To narrow things down, check the [push ticket](/push-notifications/sending-notifications/#push-tickets) and [push receipt](/push-notifications/sending-notifications/#push-receipts) for error messages.
You can also narrow things even further by testing [local notifications](/versions/latest/sdk/notifications/#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) in your app. This ensures all of your client-side logic is correct, and narrow things down to the server side or app credentials.
Note: See here for some quick terminal commands you can use to get the push receipt
---
1. Send a notification:
```sh
curl -H "Content-Type: application/json" -X POST "https://exp.host/--/api/v2/push/send" -d '{
  "to": "ExponentPushToken[xxxxxxxxxxxxxxxxxxxxxx]",
  "title":"hello",
  "body": "world"
}'
```
2. Use the resulting ticket `id` to request the push receipt:
```sh
curl -H "Content-Type: application/json" -X POST "https://exp.host/--/api/v2/push/getReceipts" -d '{
  "ids": [
    "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
  ]
}'
```
---
### Notifications work in development, but not in release mode
This indicates that you have either misconfigured your credentials or didn't configure them at all in your production app. In SDK 53 and later, Expo Go does not support push notifications functionality, so to test push you should use a [development build](/develop/development-builds/introduction/). In SDK 52 and earlier, Expo Go used Expo's credentials, which allowed push notifications to work in development without setting up your own credentials.
When you build your app for the app stores, you need to generate and use your own credentials. On Android, follow [this guide](/push-notifications/fcm-credentials). On iOS, this is handled by your [push key](/app-signing/app-credentials/#push-notification-keys) (revoking the push key associated with your app results in your notifications failing to be delivered. To fix that, add a new push key with `eas credentials`).
For more information, see [app signing](/app-signing/app-credentials).
### Notifications occasionally stop coming through on Android
This is likely due to the `priority` level of the notifications you're sending. You can learn more about [Android priority](https://firebase.google.com/docs/cloud-messaging/http-server-ref#downstream-http-messages-json). [Expo accepts four priorities](/push-notifications/sending-notifications/#message-request-format):
- `default`: manually mapped to the default priority documented by Apple and Google
- `high`: mapped to the high priority level documented by Apple and Google
- `normal`: mapped to the normal priority level documented by Apple and Google
- (priority omitted): treated exactly as if `default` were specified
Setting the priority to `high` gives your notification the greatest likelihood that Android will display the notification.
### Handle expired push notification credentials
When your push notification credentials have expired, run `eas credentials`, choose iOS and a build profile, then remove your push notification key and generate a new one.
### No valid aps-environment entitlement string found error for iOS
This error occurs if you haven't set up a push notification key for your iOS project. To check, go to the [Project Credentials page](https://expo.dev/accounts/[account]/projects/[project]/credentials/ios).
To generate a new push notification key, trigger a new build by running:
```sh
$ eas build --profile [profile] --platform ios
```
For a visual guide, see the [Expo Notifications with EAS video](https://youtu.be/BCCjGtKtBjE?t=2123).
### Error message when sending a notification
Check the `details` property of the returned push ticket or receipt for more information. [Read this](/push-notifications/sending-notifications/#errors) for common error code responses and their associated solutions.
### Fetching a push token takes a long time on iOS
`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [Troubleshooting Push Notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html) technical note:
> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.
Here are some ways our community members have resolved this issue:
Note: Read the Apple's Technical Note on troubleshooting push notifications
---
Read Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This is the single most reliable source of information on this problem. To help you grasp what they're suggesting:
- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling the firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).
- **Bare React Native apps** must [manually enable the **Push Notifications** capability](/build-reference/ios-capabilities#manual-setup). If you have trouble setting this up, refer to [this Stack Overflow answer](https://stackoverflow.com/a/10791240/1123156). You may also want to try to debug this even further by logging persistent connection debug information as outlined by [this Stack Overflow answer](https://stackoverflow.com/a/8036052/1123156).
---
Note: Try again in a little while
---
- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!
- Try again in a few days as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).
---
Note: Disable network sharing on your device
---
You may need to disable network sharing as this may impact the registration as suggested by [this Stack Overflow answer](https://stackoverflow.com/a/59156989/1123156).
---
Note: Restart your device
---
If you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this Stack Overflow answer](https://stackoverflow.com/a/59864028/1123156).
---
Note: Setup your device with a SIM card
---
If the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this Stack Overflow answer](https://stackoverflow.com/a/19432504/1123156).
---
## Miscellaneous
### Sending notifications directly through FCM and APNs
If you are not using [Expo push notification service](/push-notifications/sending-notifications) and instead, would like to communicate with Google and Apple directly, see [Send notifications with FCM and APNs](/push-notifications/sending-notifications-custom).
### Notification icon on Android is a gray or white square
This indicates an issue with the image asset you're providing. The image should be all white with a transparent background (this is required and enforced by Google, not Expo). For more information, see [this article](https://clevertap.com/blog/fixing-notification-icon-for-android-lollipop-and-above/).


# Integrations

# Analytics and error reports

## React Native analytics SDKs and libraries

An overview of analytics services available in the Expo and React Native ecosystem.

An analytics service allows you to track how users interact with your app. With this data, you can take a measured approach when improving your app.
The following list provides common analytics providers that are available in the Expo and React Native ecosystem.
> Most analytics SDK requires configuring custom native code. Native code is not configurable when using Expo Go. However, you can create a [development build](/develop/development-builds/introduction/), which will allow you to use any of the services below.


## Using Sentry

A guide on installing and configuring Sentry for crash reporting.

[Sentry](http://getsentry.com/) is a crash reporting platform that provides you with **real-time insight into production deployments with info to reproduce and fix crashes**.
It notifies you of exceptions or errors that your users run into while using your app and organizes them for you on a web dashboard. Reported exceptions include stacktraces, device info, version, and other relevant context automatically. You can also provide additional context that is specific to your application such as the current route and user id.
## What you'll learn
This guide covers three main aspects of integrating Sentry with your Expo projects:
- [Install and configure Sentry](#install-and-configure-sentry) in your React Native app
- Using Sentry with EAS:
  - [EAS Build](#usage-with-eas-build) for building your app
  - [EAS Update](#usage-with-eas-update) for over-the-air updates
- [Setting up the Sentry-Expo integration](#sentry-integration-with-eas-dashboard) to view crash reports and session replays directly in your EAS dashboard
## Install and configure Sentry
Step 1: 
### Sign up for a Sentry account and create a project
Before proceeding with installing Sentry, you'll need to make sure you have created a Sentry account and project:
Step 1.1: 
[Sign up for Sentry](https://sentry.io/signup/) (the free tier supports up to 5,000 events per month), and create a project in your
Dashboard. Take note of your **organization slug**, **project name**, and **DSN** as you'll need
them later:
- **organization slug** is available in your **Organization settings** tab
- **project name** is available in your project's **Settings** > **Projects** tab (find it in the list)
- **DSN** is available in your project's **Settings** > **Projects** > **Project name** > Under **SDK Setup** section > **Client Keys (DSN)** tab.
Step 1.2: 
Go to the [Developer Settings > Auth Tokens](https://sentry.io/settings/auth-tokens/) page and create a new [Organization Auth Token](https://docs.sentry.io/account/auth-tokens/#organization-auth-tokens). The token is automatically scoped for Source Map Upload and Release Creation. Save it.
Once you have each of these: **organization slug**, **project name**, **DSN**, and **auth token**, you're all set to proceed.
Step 2: 
### Use the Sentry wizard to set up your project
The easiest way to set up Sentry in your Expo project is to use the Sentry wizard. This tool will automatically configure your project with the right settings.
Run the following command in your project directory:
```sh
$ npx @sentry/wizard@latest -i reactNative
```
The wizard will:
- Install the required dependencies
- Configure your project to use Sentry
- Set up the Metro configuration automatically
- Add the necessary initialization code to your app
Follow the prompts in the wizard to complete the setup process. The wizard will guide you to log in to your Sentry account and fetch all the correct information regarding your project.
Step 3: 
### Verify the configuration
Create a new release build of your app and verify that it uploads source maps correctly. You may want to add a button in your app to test that it is working and sourcemaps are wired up as expected, for example:
```jsx
import { Button } from 'react-native';
// Inside some component
<Button title="Press me" onPress={() => { throw new Error('Hello, again, Sentry!'); }}/>
```
## Usage with EAS Build
Ensure that `SENTRY_AUTH_TOKEN` is set in your build environment, and Sentry will automatically upload source maps for you. If you use environment variables rather than properties in your app config, ensure that those are set as well.
Using the above instructions, no additional work is needed to integrate Sentry into your project when using EAS Build.
## Usage with EAS Update
After running `eas update`, upload the source maps to Sentry:
```sh
$ npx sentry-expo-upload-sourcemaps dist
```
That's it! Errors for your updates will now be properly symbolicated in Sentry.
Note: Do you want to publish an update and the sourcemaps in one command?
---
You can chain the commands together with `&&` to publish an update and upload the sourcemaps in one step:
```sh
$ eas update --branch <branch> && npx sentry-expo-upload-sourcemaps dist
```
---
Note: Do you want to append additional update-related metadata to error reports?
---
Configuring Sentry to tag your scope with information about your update allows you to see errors happening on certain updates in the Sentry dashboard.
Add the following snippet in the global scope as early as possible in your application's lifecycle.
```js
import * as Sentry from '@sentry/react-native';
import * as Updates from 'expo-updates';
const manifest = Updates.manifest;
const metadata = 'metadata' in manifest ? manifest.metadata : undefined;
const extra = 'extra' in manifest ? manifest.extra : undefined;
const updateGroup = metadata && 'updateGroup' in metadata ? metadata.updateGroup : undefined;
Sentry.init({
  // dsn, release, dist, etc...
});
const scope = Sentry.getGlobalScope();
scope.setTag('expo-update-id', Updates.updateId);
scope.setTag('expo-is-embedded-update', Updates.isEmbeddedLaunch);
if (typeof updateGroup === 'string') {
  scope.setTag('expo-update-group-id', updateGroup);
  const owner = extra?.expoClient?.owner ?? '[account]';
  const slug = extra?.expoClient?.slug ?? '[project]';
  scope.setTag(
    'expo-update-debug-url',
    `https://expo.dev/accounts/${owner}/projects/${slug}/updates/${updateGroup}`
  );
} else if (Updates.isEmbeddedLaunch) {
  // This will be `true` if the update is the one embedded in the build, and not one downloaded from the updates server.
  scope.setTag('expo-update-debug-url', 'not applicable for embedded updates');
}
```
Once configured, information about the associated update will show up in an error's tag section:
---
## Sentry integration with EAS dashboard
The Sentry integration with Expo allows you to view crash reports and Session Replays for your Expo app deployments directly within your EAS dashboard. This integration provides a direct link to Sentry stack traces with full context, session replays, and debugging capabilities.
### Install
> **info** Sentry owner, manager, or admin permissions are required to install this integration.
1. Log in to you Expo account and open [**Account settings > Overview**](https://expo.dev/accounts/[your-account]/settings).
2. Under **Connections** and click **Connect** next to Sentry.
3. Log in to your Sentry account and accept the integration into your organization. You will be redirected back to **Account settings**.
### Link your project
After connecting your accounts, you need to link your EAS Project to your Sentry Project:
1. Open **Projects > [Your Project] > Configuration > Project settings** in EAS.
2. Click **Link** and select your Sentry Project from the dropdown.
### Usage
To see your Sentry data in EAS dashboard, open **Projects > [Your Project] > Updates > Deployments > [Deployment]** to view Sentry data from a Release.
With this integration, you can:
- View crash reports directly in your EAS dashboard
- Access Session Replays to see exactly what happened before an error occurred
- Get detailed stack traces with full context
- Navigate seamlessly between EAS and Sentry for debugging
## Learn more about Sentry
Sentry does more than just catch fatal errors, learn more about how to use Sentry from their [JavaScript usage](https://docs.sentry.io/platforms/javascript/) documentation.


## Using BugSnag

A guide on installing and configuring BugSnag for end-to-end error reporting and analytics.

[BugSnag](https://www.bugsnag.com) is a stability monitoring solution that provides rich, end-to-end error reporting and analytics to reproduce and fix errors with speed and precision. BugSnag supports the full stack with open-source libraries for more than [50 platforms](https://www.bugsnag.com/platforms), including [React Native](https://docs.bugsnag.com/platforms/react-native/react-native/).
With BugSnag, developers and engineering organizations can:
- **Stabilize:** Innovate faster by knowing when to build new features versus fix bugs. Use the release health dashboard, stability scores and targets, and built-in alerts via email, Slack, PagerDuty, and more.
- **Prioritize:** Improve customer experience by identifying and prioritizing bugs that have the greatest impact on app stability. Analyze issues grouped by root cause and sorted by business impact, customer segmentation, A/B testing and experiment results.
- **Fix:** Increase productivity by spending less time on reproducing and fixing bugs. Utilize powerful diagnostic data, full stacktraces and automatic breadcrumbs.
## Integration
See the integration guide below for instructions on adding BugSnag to your Expo apps to report JavaScript errors. It also includes instructions for uploading source maps for updates published with [EAS Update](/eas-update/introduction/).
If you're new to BugSnag, you can [create an account](https://app.bugsnag.com/user/new/) or [request a demo](https://www.bugsnag.com/demo-request).


## Using LogRocket

A guide on installing and configuring LogRocket for session replays and error monitoring.

[LogRocket](https://logrocket.com) records user sessions and identifies bugs as your users use your app. You can filter sessions by update IDs and also connect to your LogRocket account on the EAS dashboard to get quick access to your app's session data.
## Install and configure LogRocket
You can install the LogRocket SDK with the following command:
```sh
$ npx expo install @logrocket/react-native expo-build-properties
```
Then, in your [app config](/workflow/configuration/), include the LogRocket config plugin:
```json app.json
{
  "plugins": [
    [
      "expo-build-properties",
      {
        "android": {
          "minSdkVersion": 25
        }
      }
    ],
    "@logrocket/react-native"
  ]
}
```
Finally, initialize LogRocket in your app in a top-level file, like **app/\_layout.tsx**:
```tsx app/_layout.tsx
import { useEffect } from 'react';
import * as Updates from 'expo-updates';
import LogRocket from '@logrocket/react-native';
const App = () => {
  useEffect(() => {
    LogRocket.init('<App ID>', {
      updateId: Updates.isEmbeddedLaunch ? null : Updates.updateId,
      expoChannel: Updates.channel,
    });
  }, []);
};
```
In the code above, replace `<App ID>` with your [LogRocket App ID](https://app.logrocket.com/r/settings/setup).
## Connecting LogRocket on the EAS dashboard
You can link your LogRocket account and project to your Expo account and project on Expo's dashboard, so that you can see the last few sessions from your app in the deployments and updates dashboards.
Go to your **Account settings** > [**Overview**](https://expo.dev/accounts/%5Baccount%5D/settings) > **Connections** and click **Connect** to authenticate with LogRocket:
Then, go to your project, under **Project settings** > [**General**](https://expo.dev/accounts/%5Baccount%5D/projects/%5BprojectName%5D/settings) and click **Connect** to link your LogRocket project with your project on Expo:
Then, you'll start to see **View on LogRocket** buttons in the EAS dashboard in the Native Deployments and Updates dashboards, along with the last few sessions from your app.
## Learn more about LogRocket
To learn more about how to use LogRocket with Expo, check out the [LogRocket documentation](https://docs.logrocket.com/reference/react-native-expo-adding-the-sdk).


## Using Vexo

A guide on installing and configuring Vexo for real-time user analytics.

[Vexo](https://www.vexo.co/) provides real-time user analytics for your Expo application, helping you understand how users interact with your app, identify friction points, and improve engagement.
With a two-line integration, Vexo starts collecting data automatically, giving you actionable insights to optimize your app's user experience. If needed, you can also create custom events.
## Features
1. **Complete Dashboard**
   - Active Users
   - Session Time
   - Downloads
   - OS Distribution
   - Version Adoption
   - Geographic Insights
   - Popular Screens
2. **Session Replays**
   - Watch real user sessions to understand their interactions.
3. **Heatmaps**
   - Identify the most engaged areas of your app.
4. **Funnels**
   - Analyze user flows and optimize conversion rates.
5. **Custom Events and Dashboard Personalization**
   - Track specific user actions by creating custom events.
   - Customize your dashboard to visualize key metrics.
## Getting started
1. Create an account: Sign up for a [Vexo account](https://www.vexo.co/).
2. Create a new app: You'll be prompted to create a new app. Give it a name (you can change it later), and once you submit it, you'll receive an API key.
3. Install the Vexo package: Run the following command in your project:
     For npm: 
       ```sh
$ npm install vexo-analytics
```
     For yarn: 
       ```sh
$ yarn add vexo-analytics
```
4. Initialize Vexo: Add the following code in your app's entry file (for example, **index.js**, **App.js**, or **app/\_layout.tsx** if using Expo Router):
   ```tsx app/_layout.tsx
   import { vexo } from 'vexo-analytics';
   // You may want to wrap this with `if (!__DEV__) { ... }` to only run Vexo in production.
   vexo('YOUR_API_KEY');
   ```
5. Rebuild and run your app: Since `vexo-analytics` includes native code, you need to rebuild your application.
6. Verify integration: Go to your app's page on Vexo and you should see your first event!
## Compatibility
- Expo: Vexo is compatible with [Development builds](/development/introduction/) and does not require additional configuration plugins.
- Expo Go: Not supported, as Vexo requires custom native code.
## Learn more about Vexo
To learn more about using Vexo with Expo, check out the [Vexo documentation](https://docs.vexo.co/).


# Authentication

## Using authentication SDKs and libraries

An overview of authentication integrations available in the Expo and React Native ecosystem.

Authentication in mobile apps refers to how you identify who a user is, manage sign-up or sign-in flows, and maintain their authenticated session across app launches and across multiple devices. Authentication SDKs and libraries help you add these flows, so you do not need to build your own custom auth backend. The guides below highlight popular SDKs and providers for your Expo and React Native projects.
> **warning** Some providers require custom native code and aren't supported in Expo Go. Use a [development build](/develop/development-builds/introduction/) when needed.


## Using Clerk

Learn how to integrate Clerk authentication in your Expo and React Native projects.

[Clerk](https://clerk.com/) is a full stack authentication and user management platform that helps you add sign-up, sign-in, and account management without building your own auth backend. It supports multiple authentication strategies, session management, and organizations for multi-tenant apps.
Clerk provides hooks, UI, and control components so you can build completely custom authentication screens. Pair it with `expo-secure-store` to keep session tokens encrypted on device, and configure your projects's providers and policies in the Clerk's dashboard.
> **Note:** Clerk's [prebuilt UI components](https://clerk.com/docs/expo/reference/components/overview) are available for web only. For native platforms, Clerk recommends building custom flows.
## Features
- **Authentication flows:** Sign-up and sign-in with email verification code, magic links, passwords, social providers (20+), passkeys, phone number verification, SAML, OpenID Connect, Web3 (MetaMask), and authenticator apps for multi-factor authentication.
- **Session management:** Secure token handling with [`expo-secure-store`](/versions/latest/sdk/secure-store/).
- **User management:** Profile data, account settings, and organization membership for multi-tenant apps.
## Get started
To get started, follow the instructions in the Clerk's documentation:


## Using Facebook authentication

A guide on using react-native-fbsdk-next library to integrate Facebook authentication in your Expo project.

The [`react-native-fbsdk-next`](https://github.com/thebergamo/react-native-fbsdk-next/) library provides a wrapper around Facebook's Android and iOS SDKs. It allows integrating Facebook authentication into your Expo project and provide access to native components.
This guide provides additional information on configuring the library with Expo for Android.
## Prerequisites
The `react-native-fbsdk-next` library can't be used in the Expo Go app because it requires custom native code. Learn more about [adding custom native code to your app](/workflow/customizing/).
## Installation
See `react-native-fbsdk-next` documentation for instructions on how to install and configure the library:
## Configuration for Android
Adding Android as a platform in your Facebook project requires you to have your app approved by Google Play Store so that it has a valid Play Store URL, and the [`package`](/versions/latest/config/app/#package) name associated with your app. Otherwise, you'll run into the following error:
See the following guides for more information on how to build your project for app stores:
Once you have uploaded the app to the Play Store you can submit your app review. When it is approved the Facebook project will be able to access it at a Play Store URL.
After that, go to your Facebook project's **Settings** > **Basic** and add the **Android** platform. You'll need to provide the Key hash, Package name and Class name.
- To add Key hash, go to your Play Store Console to obtain the SHA-1 certificate fingerprint from **Release** > **Setup** > **App Integrity** > **App signing key certificate**. Then, [convert the value of the Hex value of the certificate to Base64](https://base64.guru/converter/encode/hex) and add it under the **Android** > **Key hashes** in your Facebook project.
- You can find the Package name in your [app config](/versions/latest/config/app) under the [`android.package`](/versions/latest/config/app/#package) field.
- The Class name is `MainActivity` by default, and you can use `package.MainActivity` where `package` is the `android.package` in your project's app config. For example, `com.myapp.example.MainActivity`, where `com.myapp.example` is the `package` name of your app.
- Then, click **Save changes** to save the configuration.
Now, you can use your Facebook project for development or release builds and production apps.


## Using Google authentication

A guide on using @react-native-google-signin/google-signin library to integrate Google authentication in your Expo project.

The [`@react-native-google-signin/google-signin`](https://github.com/react-native-google-signin/google-signin) library provides a way to integrate Google authentication in your Expo app. It also provides native sign-in buttons and supports authenticating the user as well as obtaining their authorization to use Google APIs. You can use the library in your project by adding the [config plugin](/config-plugins/introduction/) in the [app config](/versions/latest/config/app/).
This guide provides information on how to configure the library for your project.
## Prerequisites
The `@react-native-google-signin/google-signin` library can't be used in the Expo Go app because it requires custom native code. Learn more about [adding custom native code to your app](/workflow/customizing/).
## Installation
See `@react-native-google-signin/google-signin` documentation for instructions on how to install and configure the library:
## Configure Google project for Android and iOS
Below are instructions on how to configure your Google project for Android and iOS.
### Upload app to Google Play Store
We recommend uploading the app to the Google Play Store if your app intends to run in production. You can submit your app to the stores for testing even if your project is still in development. This allows you to test Google Sign In when your app is signed by EAS for testing, and when it is signed by [Google Play App Signing](https://support.google.com/googleplay/android-developer/answer/9842756?hl=en) for store deployment. To learn more about the app submission process, see the guides below in the order they are specified:
### Configure your Firebase or Google Cloud Console project
> Refer to the [library's documentation](https://react-native-google-signin.github.io/docs/setting-up/get-config-file) for a more in-depth configuration guide.
For Android, once you have uploaded your app, you need to provide the SHA-1 certificate fingerprint values when asked while configuring the project in Firebase or Google Cloud Console. There are two types of values that you can provide:
- Fingerprint of the **.apk** you built (on your machine or using EAS Build). You can find the SHA-1 certificate fingerprint in the Google Play Console under **Release** > **Setup** > **App Integrity** > **Upload key certificate**.
- Fingerprint(s) of a **production app** downloaded from the play store. You can find the SHA-1 certificate fingerprint(s) in the Google Play Console under **Release** > **Setup** > **App Integrity** > **App signing key certificate**.
### With Firebase
For more instructions on how to configure your project for Android and iOS with Firebase:
#### Upload google-services.json and GoogleService-Info.plist to EAS
If you use the Firebase method for Android and iOS (as shared in sections above), you'll need to make sure **google-services.json** and **GoogleService-Info.plist** are available in EAS for building the app. You can check them into your repository because the files should not contain sensitive values, or you can treat the files as secrets, add them to **.gitignore** and use the guide below to make them available in EAS.
### With Google Cloud Console
This is an alternate method to configure a Google project when you are not using [Firebase](#with-firebase).
For more instructions on how to configure your Google project Android and iOS with Google Cloud Console:


# CMS

## Using a Content Management System (CMS)

An overview of Content Management Systems (CMS) available in the Expo and React Native ecosystem.

A **Content Management System (CMS)** is a platform that allows you to create, manage, and organize digital content such as blog posts, images, and product information without the need to write custom backend code. Using a CMS can save you significant development time and enable non-technical users (such as editors and marketers) to update app content easily through a user-friendly interface.
Integrating a CMS into your Expo and React Native app lets you remotely manage and update content, push out new information to users instantly, and scale your content operations without releasing new app updates.
Here are some popular CMS options to consider for Expo and React Native projects:


# Database and SDKs

## Using Firebase

A guide on getting started and using Firebase JS SDK and React Native Firebase library.

[Firebase](https://firebase.google.com/) is a Backend-as-a-Service (BaaS) app development platform that provides hosted backend services such as real-time database, cloud storage, authentication, crash reporting, analytics, and so on.
It is built on Google's infrastructure and scales automatically.
There are two different ways you can use Firebase in your projects:
- Using [Firebase JS SDK](#using-firebase-js-sdk)
- Using [React Native Firebase](#using-react-native-firebase)
React Native supports both the JS SDK and the native SDK. The following sections will guide you through when to use which SDK and all the configuration steps required to use Firebase in your Expo projects.
## Prerequisites
Before proceeding, make sure that you have created a new Firebase project or have an existing one using the [Firebase console](https://console.firebase.google.com/).
## Using Firebase JS SDK
The [Firebase JS SDK](https://firebase.google.com/docs/web/setup) is a JavaScript library that allows you to interact with Firebase services in your project.
It supports services such as [Authentication](https://firebase.google.com/docs/auth), [Firestore](https://firebase.google.com/docs/firestore), [Realtime Database](https://firebase.google.com/docs/database), and [Storage](https://firebase.google.com/docs/storage) in a React Native app.
### When to use Firebase JS SDK
You can consider using the Firebase JS SDK when you:
- Want to use Firebase services such as Authentication, Firestore, Realtime Database, and Storage in your app and want to develop your app with [**Expo Go**](/get-started/set-up-your-environment/).
- Want a quick start with Firebase services.
- Want to create a universal app for Android, iOS, and the web.
#### Caveats
Firebase JS SDK does not support all services for mobile apps. Some of these services are Analytics, Dynamic Links and Crashlytics. See the [React Native Firebase](#using-react-native-firebase) section if you want to use these services.
### Install and initialize Firebase JS SDK
> **warning** Expo SDK 53 and later only support `firebase@^12.0.0`. Versions before this version cause ES module resolution errors.
Step 1: 
#### Install the SDK
After you have created your [Expo project](/get-started/create-a-project/), you can install the Firebase JS SDK using the following command:
```sh
$ npx expo install firebase
```
Step 2: 
#### Initialize the SDK in your project
To initialize the Firebase instance in your Expo project, you must create a config object and pass it to the `initializeApp()` method imported from the `firebase/app` module.
The config object requires an API key and other unique identifiers. To obtain these values, you will have to register a web app in your Firebase project. You can find these instructions in the [Firebase documentation](https://firebase.google.com/docs/web/setup#register-app).
After you have the API key and other identifiers, you can paste the following code snippet by creating a new **firebaseConfig.js** file in your project's root directory or any other directory where you keep the configuration files.
```js firebaseConfig.js
import { initializeApp } from 'firebase/app';
// Optionally import the services that you want to use
// import {...} from 'firebase/auth';
// import {...} from 'firebase/database';
// import {...} from 'firebase/firestore';
// import {...} from 'firebase/functions';
// import {...} from 'firebase/storage';
// Initialize Firebase
const firebaseConfig = {
  apiKey: 'api-key',
  authDomain: 'project-id.firebaseapp.com',
  databaseURL: 'https://project-id.firebaseio.com',
  projectId: 'project-id',
  storageBucket: 'project-id.appspot.com',
  messagingSenderId: 'sender-id',
  appId: 'app-id',
  measurementId: 'G-measurement-id',
};
const app = initializeApp(firebaseConfig);
// For more information on how to access Firebase in your project,
// see the Firebase documentation: https://firebase.google.com/docs/web/setup#access-firebase
```
You do not have to install other plugins or configurations to use Firebase JS SDK.
Firebase version 9 and above provide a modular API. You can directly import any service you want to use from the `firebase` package. For example, if you want to use an authentication service in your project, you can import the `auth` module from the `firebase/auth` package.
> **info** **Troubleshooting tip:** If you encounter issues related to authentication persistence with Firebase JS SDK, see the guide for [setting up persistence to keep users logged in between reloads](https://expo.fyi/firebase-js-auth-setup).
### Next steps
## Using React Native Firebase
[React Native Firebase](https://rnfirebase.io/) provides access to native code by wrapping the native SDKs for Android and iOS into a JavaScript API.
Each Firebase service is available as a module that can be added as a dependency to your project. For example, the `auth` module provides access to the Firebase Authentication service.
### When to use React Native Firebase
You can consider using React Native Firebase when:
- Your app requires access to Firebase services not supported by the Firebase JS SDK, such as [Dynamic Links](https://rnfirebase.io/dynamic-links/usage), [Crashlytics](https://rnfirebase.io/crashlytics/usage), and so on.
  For more information on the additional capabilities offered by the native SDK's, see [React Native Firebase documentation](https://rnfirebase.io/faqs-and-tips#why-react-native-firebase-over-firebase-js-sdk).
- You want to use native SDKs in your app.
- You have a bare React Native app with React Native Firebase already configured but are migrating to use Expo SDK.
- You want to use [Firebase Analytics](https://rnfirebase.io/analytics/usage) in your app.
Note: Migrating from Expo Firebase packages?
---
If your project has been previously using `expo-firebase-analytics` and `expo-firebase-recaptcha` packages, you can migrate to the React Native Firebase library. For more information, see [Firebase migration guide](https://expo.fyi/firebase-migration-guide).
---
#### Caveats
React Native Firebase requires [custom native code and cannot be used with Expo Go](/workflow/customizing/).
### Install and initialize React Native Firebase
Step 1: 
#### Install expo-dev-client
Since React Native Firebase requires custom native code, you need to install the `expo-dev-client` library in your project.
It allows configuring any native code required by React Native Firebase using [Config plugins](/config-plugins/introduction/) without writing native code yourself.
To install [`expo-dev-client`](/development/getting-started/#installing--expo-dev-client--in-your-project), run the following command in your project:
```sh
$ npx expo install expo-dev-client
```
Step 2: 
#### Install React Native Firebase
To use React Native Firebase, it is necessary to install the `@react-native-firebase/app` module. This module provides the core functionality for all other modules.
It also adds custom native code in your project using a config plugin. You can install it using the following command:
```sh
$ npx expo install @react-native-firebase/app
```
**At this point, you must follow the instructions from [React Native Firebase documentation](https://rnfirebase.io/#managed-workflow)** as it covers all the steps required to configure your project with the library.
Once you have configured the React Native Firebase library in your project, come back to this guide to learn how to run your project in the next step.
Step 3: 
#### Run the project
If you are using **[EAS Build](/build/introduction/), you can create and install a development build** on your devices. You do not need to run the project locally before creating a development build.
For more information on creating a development build, see the section on [installing a development build](/develop/development-builds/create-a-build/).
Note: Run project locally?
---
If you want to run the project locally, you need both Android Studio and Xcode installed and configured on your machine. See [Local app development](/guides/local-app-development/) guide for more information.
If a particular React Native Firebase module requires custom native configuration steps, you must add it as a `plugin` to [app config](/workflow/configuration/) file. Then, to run the project locally, run the `npx expo prebuild --clean` command to apply the native changes before the `npx expo run` commands.
---
### Next steps
After configuring React Native Firebase library, you can use any module it provides in your Expo project.


## Using Supabase

Add a Postgres Database and user authentication to your React Native app with Supabase.

[Supabase](https://supabase.com/?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) is a Backend-as-a-Service (BaaS) app development platform that provides hosted backend services such as a Postgres database, user authentication, file storage, edge functions, realtime syncing, and a vector and AI toolkit. It's an open-source alternative to Google's Firebase.
Supabase automatically [generates a REST API](https://supabase.com/docs/guides/api?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) from your database and employs a concept called [row level security (RLS)](https://supabase.com/docs/guides/auth/row-level-security?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) to secure your data, making it possible to directly interact with your database from your React Native application without needing to go through a server!
Supabase provides a TypeScript client library called [`supabase-js`](https://supabase.com/docs/reference/javascript/introduction?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) to interact with the REST API. Alternatively, Supabase also exposes a [GraphQL API](https://supabase.com/docs/guides/database/extensions/pg_graphql?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) allowing you to use your favorite GraphQL client (for example, [Apollo Client](https://supabase.github.io/pg_graphql/usage_with_apollo/)) should you wish to.
## Prerequisites
Head over to [database.new](https://database.new?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) to create a new Supabase project.
### Get the API Keys
Get the **Project URL** from the API settings and **Publishable key** from the API Keys:
1. Go to the [API Settings](https://supabase.com/dashboard/project/_/settings/api) page in the Dashboard.
2. Find your Project `URL` and `service_role` keys on this page.
3. Then go to the [API Keys](https://supabase.com/dashboard/project/_/settings/api-keys)
4. Find your Project **Publishable key** on this page under the API Keys tab.
## Using the Supabase TypeScript SDK
Using [`supabase-js`](https://supabase.com/docs/reference/javascript/introduction?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) is the most convenient way of leveraging the full power of the Supabase stack as it conveniently combines all the different services (database, auth, realtime, storage, edge functions) together.
### Install and initialize the Supabase TypeScript SDK
Step 1: 
After you have created your [Expo project](/get-started/create-a-project/), install `@supabase/supabase-js` and the required dependencies using the following command:
```sh
$ npx expo install @supabase/supabase-js expo-sqlite
```
Step 2: 
Create a helper file to initialize the Supabase client (`@supabase/supabase-js`). You need the API URL and the `Publishable` key copied [earlier](#get-the-api-keys). These variables are safe to expose in your Expo app since Supabase has [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security?utm_source=expo&utm_medium=referral&utm_term=expo-react-native) enabled in the Database.
```ts utils/supabase.ts
import 'expo-sqlite/localStorage/install';
import { createClient } from '@supabase/supabase-js';
const supabaseUrl = YOUR_REACT_NATIVE_SUPABASE_URL;
const supabasePublishableKey = YOUR_REACT_NATIVE_SUPABASE_PUBLISHABLE_KEY;
export const supabase = createClient(supabaseUrl, supabasePublishableKey, {
  auth: {
    storage: localStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
```
Now you can `import { supabase } from '/utils/supabase'` throughout your application to leverage the full power of Supabase!
## Next steps


# Emails

## Using Resend

Learn how to integrate Resend in your Expo and React Native app to programmatically send emails with Expo Router's API Routes.

[Resend](https://resend.com/) is an email API platform designed for developers. It allows you to send, receive, and manage emails programmatically through an API. You can use it to send transactional emails for use cases like newsletters, marketing emails, and more. The API also allows you to set up webhooks for email events, manage domains for deliverability, and receive emails via webhooks.
This guide demonstrates the **essential steps to integrate Resend with your Expo and React Native project**.
Video Tutorial: [How to send emails with Resend from your Expo app](https://www.youtube.com/watch?v=8sPD8SNcUFA)
## Prerequisites
Before you get started, you need to have the following:
- A project using [Expo Router](/router/installation/)
- An [Expo account](https://expo.dev/signup) to deploy the API route using EAS Hosting
- EAS CLI installed globally (`npm install -g eas-cli`)
- A [Resend account](https://resend.com/)
Step 1: 
## Create a Resend API key
Go to the [Resend dashboard](https://resend.com/api-keys) > **API Keys** and click on **Create API Key** to generate an API key.
Once you have generated the API key, save it to **.env.local** file in your Expo project:
```shell .env.local
RESEND_API_KEY=YOUR_RESEND_API_KEY
```
> **Note:** Do not commit **.env.local** file to your Version Control System (VCS) like Git. The API key is sensitive and should not be exposed to the public. You must add the file to your **.gitignore** file to ignore it.
Step 2: 
## Install Resend SDK
In your Expo project, install the Resend SDK using the following command:
```sh
$ npx expo install resend
```
The resend SDK library is a server-only library. It allows you to send emails from the server-side code of your app. Since this guide uses [API Routes](/router/web/api-routes/) to handle email submissions, you need to install the resend as part of your Expo project.
Step 3: 
## Enable and create an API route
To enable using API Routes in your Expo project, you need to set the web.output to server in your [app config](/workflow/configuration/) file:
```json app.json
{
  "web": {
    "output": "server"
  }
}
```
Then, [create an API route](/router/web/api-routes/#create-an-api-route) to handle email submissions. Inside the **app** directory, create a new file called **api/audience+api.ts**. The `+api.ts` extension is used by Expo Router to identify the file as an API Route. To test the integration, you can add the minimal code below to send an email to a recipient using Resend SDK:
```tsx app/api/audience+api.ts
import { Resend } from 'resend';
const resend = new Resend(process.env.RESEND_API_KEY);
export async function POST(request: Request) {
  const body = await request.json();
  const { email } = body;
  if (!email) {
    return Response.json({ success: false });
  }
  await resend.contacts.create({
    email: email,
    // Provide dynamic values on your own
    firstName: 'Steve',
    lastName: 'Wozniak',
    unsubscribed: false,
  });
  return Response.json({ success: true });
}
```
In the above code snippet, the `POST` [request function](/router/web/api-routes/#request-body) is executed when the `/api/audience` route is matched. The function receives a `Request` object as an argument, which contains the HTTP request body. Then, the function extracts the `email` from the request body and sends it to the Resend API to add it to the audience.
Step 4: 
## Add a base URL
To make the API route accessible from your Expo app, you need to add the base URL as an environment variable in your Expo project. Add the following code to your **.env.local** file:
```shell .env.local
EXPO_PUBLIC_BASE_URL=https://example-resend.expo.app # Deployed URL via EAS Hosting
EXPO_PUBLIC_BASE_URL_LOCAL=http://localhost:8081 # Only required for testing locally
```
To test Resend integration locally, you can use `EXPO_PUBLIC_BASE_URL_LOCAL` to point to your local development server, whose URL is provided when you run `npx expo start`. Later in this guide, when you deploy your app to EAS Hosting, ensure to update the `EXPO_PUBLIC_BASE_URL` to the deployed URL.
Note that only variables prefixed with `EXPO_PUBLIC_` can be used in the frontend code, so you can have the above as well as the Resend API key in the same **.env** file, but the `RESEND_API_KEY` will only be accessible from the server-side code (that is, files ending with **+api**).
Step 5: 
## Add a form to your Expo project
The following example code shows a simple form to collect email addresses from app users. In a real-world scenario, you would want to add validation and error handling to the form. For example, the following code is added to the **app/index.tsx** file:
```tsx app/index.tsx
import { useRef, useState } from 'react';
import { Alert, Pressable, StyleSheet, Text, TextInput, View } from 'react-native';
export default function Index() {
  const [email, setEmail] = useState('');
  const inputRef = useRef<TextInput>(null);
  const handleSubmit = async () => {
    if (!email) {
      alert('Email is required.');
      return;
    }
    if (inputRef.current) {
      inputRef.current.blur();
    }
    try {
      const response = await fetch(
        `${process.env.EXPO_PUBLIC_BASE_URL_LOCAL}/api/audience`, // Switch to `EXPO_PUBLIC_BASE_URL` after deploying to EAS Hosting
        {
          method: 'POST',
          body: JSON.stringify({ email }),
        }
      );
      // You can handle other response validations here.
      await response.json();
      Alert.alert('Success', 'Email sent successfully.', [
        {
          text: 'Continue',
        },
      ]);
    } catch (error) {
      alert('Something went wrong.');
      console.error(error);
    }
  };
  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        ref={inputRef}
        autoCapitalize="none"
        keyboardType="email-address"
        style={styles.input}
      />
      <Pressable style={styles.button} onPress={handleSubmit}>
        <Text style={styles.buttonText}>Send email</Text>
      </Pressable>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: 'gray',
    padding: 10,
    width: '60%',
    height: '6%',
    borderRadius: 10,
    marginBottom: 10,
    margin: 20,
  },
  button: {
    padding: 10,
    backgroundColor: '#000000',
    borderRadius: 10,
  },
  buttonText: {
    color: 'white',
    textAlign: 'center',
  },
});
```
Step 6: 
## Deploy the API route to EAS Hosting
To make the API route (`/api/audience`) accessible from a URL, you can deploy it to [EAS Hosting](/eas/hosting/get-started/).
1. Run the following command to export the web and API assets. The exported files are saved inside a **dist** directory and the API route file is part of this directory:
```sh
$ npx expo export --platform web
```
2. Run the following to create a production deployment via EAS Hosting:
```sh
$ eas deploy --prod
```
The `eas deploy --prod` command will:
- Automatically create an EAS project if you haven't already
- Prompt you to choose the preview URL for your project. Ensure that this URL is the same as the value of `EXPO_PUBLIC_BASE_URL` in your **.env.local** file. This will make the API route accessible from your Expo app while deployed in production
> **Note:** Before deployment, you need to use the `EXPO_PUBLIC_BASE_URL` as your hosted domain in your form screen (**app/index.tsx**).
## Learn more about Resend
For more information about Resend's API and usage, see [Resend's official documentation](https://resend.com/docs/introduction).


# Feature flags

## React Native feature flag services

An overview of feature flag services available in the Expo and React Native ecosystem.

A feature flag (also known as a _feature gate_) is a mechanism that enables and disables features remotely. They are a safe way to rollout new features to your app users without deploying additional code. You can use them for testing in production, A/B testing, or to ship new app features such as UI elements.
## Feature flag services
The following libraries provide robust support for feature flag functionality and out-of-the-box compatibility with Expo apps using [Continuous Native Generation (CNG)](/workflow/continuous-native-generation/) and [config plugins](/config-plugins/introduction/) for seamless integration in your app.
### Posthog
[PostHog](https://posthog.com/) is an open-source product analytics platform that provides comprehensive feature flagging capabilities alongside analytics, session recordings, and A/B testing. It supports real-time feature toggles with user segmentation and the ability to roll back features instantly, making it an excellent choice for teams that want analytics and feature management in a single platform. It includes built-in A/B testing and multivariate testing functionality, allowing you to run experiments directly through feature flags while collecting detailed analytics on feature adoption and performance metrics. The service also supports bootstrap flags to eliminate loading states and improve user experience.
### Statsig
[Statsig](https://statsig.com/) is a feature management platform designed for data-driven product development that provides advanced statistical analysis, gradual rollouts, and sophisticated targeting capabilities with built-in metrics and performance monitoring for feature releases. The platform offers a robust SDK for React Native and Expo, with automatic event logging and dynamic configurations, making it particularly well-suited for teams focused on rigorous experimentation and data-driven decision-making.
### LaunchDarkly
[LaunchDarkly](https://launchdarkly.com/) is an enterprise-grade feature management platform that enables instant feature toggles and targeted rollouts with comprehensive dashboard controls, advanced user targeting, and robust experimentation tools that provide real-time flag updates. The SDK includes advanced features such as hooks for React integration, context identification and modification, comprehensive logging, support for multiple environments in development workflows, private attributes for handling sensitive data, and relay proxy configuration for enhanced security and performance.
### Firebase Remote Config
[Firebase Remote Config](https://firebase.google.com/docs/remote-config) is a cloud service allows you to change the appearance and functionality of your app without requiring an app update. Remote Config values are managed through the Firebase console and accessed via a JavaScript API, which gives you full control over when and how these values affect your app. The service supports conditional targeting based on user properties, app versions, custom attributes and real-time updates.


# In-app purchases

## Using in-app purchases

Learn about how to use in-app purchases in your Expo app.

In-app purchases (IAP) are transactions within a mobile or desktop application where users can buy digital goods or additional features. This guide provides a list of popular libraries and tutorials for implementing IAP in your Expo app.
> In-app purchase libraries require configuring custom native code. Native code is not configurable when using Expo Go. Instead, create a [development build](/develop/development-builds/introduction/), which allows using a native library in your project.
## Tutorial
Video Tutorial: [Watch: How to Implement In-App Purchases in Expo](https://www.youtube.com/watch?v=R3fLKC-2Qh0)
## Libraries
The following libraries provide robust support for in-app purchase functionality and out-of-the-box compatibility with Expo apps using [CNG](/workflow/continuous-native-generation/) and [Config Plugins](/config-plugins/introduction/) for seamless integration in your app.


# Push notifications

## Using push notifications

Learn about push notification services that are compatible with Expo and React Native apps.

Expo apps can work with any notification service or any of the notification capabilities offered by the Android and iOS operating systems. Even if a package doesn't yet exist for a feature, native code can be written to access it via the [Expo Modules API](/modules/overview/), and native project configurations can be automated using [config plugins](/config-plugins/introduction/). The following options provide purpose-built Expo integrations, including config plugins where necessary, for implementing push notifications in your app:
> The [`expo-notifications`](/versions/latest/sdk/notifications/) library is designed and tested to work with Expo's push notification service and notifications sent directly from FCM and APNS. Some advanced features may not be compatible with third-party providers, as they often have their own native and React Native SDKs optimized for their services.
## Expo push notifications
[Expo Notifications](/versions/latest/sdk/notifications/) provides a unified API for handling push notifications across Android and iOS. It integrates seamlessly with your Expo account and is free to use.
### Key capabilities
- Fully compatible with the [`expo-notifications`](/versions/latest/sdk/notifications/) library
- Includes an EAS dashboard to track notification delivery to FCM and APNs
- Supports testing notifications with the [Expo Notifications Tool](https://expo.dev/notifications)
### Considerations and limitations
- iOS Notification Service Extension for adding additional content to notifications, such as images, is not formally included, but you can add it using a config plugin with custom native code and configuration ([example](https://github.com/expo/expo/pull/36202)).
- Volumes are limited to 600 notifications per second per project.
For implementation details, see the following guides:
## OneSignal
[OneSignal](https://onesignal.com/) is a customer engagement platform that provides push notifications, in-app messaging, SMS, and email services for web and mobile apps. OneSignal supports rich media in notifications and engagement analytics. It includes an [Expo config plugin](https://github.com/OneSignal/onesignal-expo-plugin) for direct integration into your Expo project.
## Braze
[Braze](https://www.braze.com/) is a customer engagement platform that delivers personalized, cross-channel messaging through push notifications, in-app messaging, email, SMS, and web. Braze supports rich notification content, push notification campaigns, and support for resending notifications after failed deliveries on Android. It provides a [React Native SDK](https://github.com/braze-inc/braze-react-native-sdk) and a [config plugin](https://github.com/braze-inc/braze-expo-plugin/tree/main). Check out the [Expo example app](https://github.com/braze-inc/braze-expo-plugin/tree/main/example) for more details.
## Customer.io
[Customer.io](http://Customer.io) is a customer engagement platform that allows you to design powerful automated workflows utilizing push notifications, in-app messaging, email, SMS capabilities, and more. Its visual workflow builder allows you to automate complex, data-driven campaigns across multiple channels. Customer.io supports device-side metrics collection that can be used to customize push notifications tailored to user behaviors and preferences. Customer.io provides an [Expo plugin](https://github.com/customerio/customerio-expo-plugin) for direct integration with your Expo project and documentation for using Customer.io push notifications alongside other providers.
## CleverTap
[CleverTap](https://clevertap.com/) is an all-in-one customer engagement platform that helps you deliver personalized, real-time, omnichannel messaging across push notifications, in-app messages, email, and more. It offers advanced segmentation, analytics, and campaign automation &mdash; built to scale with your business. The [CleverTap React Native SDK](https://developer.clevertap.com/docs/react-native) and [Expo config plugin](https://github.com/CleverTap/clevertap-expo-plugin) make it easy to integrate CleverTap into your Expo projects. The config plugin handles all the native module setup during the prebuild process, allowing you to configure CleverTap through your app config without having to manually modify native code. For more information, check out the [CleverTap Example Plugin](https://github.com/CleverTap/clevertap-expo-plugin/tree/main/CTExample).
## Send notifications directly via FCM and APNs
You may choose to send directly to platform push API's from your backend. In this case, you can still use [`expo-notifications`](/versions/latest/sdk/notifications/) to retrieve the native push token and configure notifications separately for each platform.
Although the client-side code remains cross-platform with [`expo-notifications`](/versions/latest/sdk/notifications/), you will need to implement server-side logic to interact with the [FCM](https://firebase.google.com/docs/cloud-messaging) and [APNs](https://developer.apple.com/documentation/usernotifications) APIs individually.
## React Native Firebase messaging
[React Native Firebase](https://rnfirebase.io/) provides a messaging module that lets you use [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging) as a unified push notification service for both Android and iOS. While FCM is often associated with Android notifications, it also supports iOS by routing messages through Apple Push Notification service (APNs) behind the scenes.
This approach differs from using FCM solely for Android notifications. Instead, Firebase's cross-platform SDK handles notifications for both platforms through a single service.
> Even though FCM handles notifications for both platforms, iOS notifications still go through APNs. Firebase automatically manages this routing. Learn more in the [React Native Firebase messaging documentation](https://rnfirebase.io/messaging/usage).
## Tips and important considerations
- **Avoid mixing client-side implementations**: Different notification services may have conflicting client-side implementations. Use a consistent approach to prevent potential issues.
- **Web notifications**: Expo notifications do not support web notifications. However, some third-party solutions may offer this capability. Consider your app's requirements when choosing a service.
- **Token management**: Track both Expo push tokens and native device tokens in your database. This provides flexibility for future integrations, especially with marketing tools that send notifications directly via FCM or APNs.


# Tools

## Using ESLint and Prettier

A guide on configuring ESLint and Prettier to format Expo apps.

[ESLint](https://eslint.org/) is a JavaScript linter that helps you find and fix errors in your code. It's a great tool to help you write better code and catch mistakes before they make it to production. In conjunction, you can use [Prettier](https://prettier.io/docs/en/), a code formatter that ensures all the code files follow a consistent styling.
This guide provides steps to set up and configure ESLint and Prettier.
## ESLint
### Setup
> **info** **From SDK 53 onwards**, the default ESLint config file uses the [Flat config](https://eslint.org/blog/2022/08/new-config-system-part-2/) format. It also supports legacy config. **For SDK 52 and earlier**, the default ESLint config file uses legacy config and does not support Flat config.
To set up ESLint in your Expo project, you can use the Expo CLI to install the necessary dependencies. Running this command also creates a **eslint.config.js** file at the root of your project which extends configuration from [`eslint-config-expo`](https://github.com/expo/expo/tree/main/packages/eslint-config-expo).
```sh
$ npx expo lint
```
### Usage
> **info** **Recommended:** If you're using VS Code, install the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) to lint your code as you type.
You can lint your code manually from the command line with the `npx expo lint` script:
```sh
run the command again to lint your code.
$ npx expo lint
```
Running the above command will run the `lint` script from **package.json**.
```sh
/app/components/HelloWave.tsx
  22:6 warning React Hook useEffect has a missing dependency: "rotateAnimation".
       Either include it or remove the dependency array react-hooks/exhaustive-deps
✖ 1 problem (0 errors
1 warning)
```
### Environment configuration
ESLint is generally configured for a single environment. However, the source code is written in JavaScript in an Expo app that runs in multiple different environments. For example, the **app.config.js**, **metro.config.js**, **babel.config.js**, and **app/+html.tsx** files are run in a Node.js environment. It means they have access to the global `__dirname` variable and can use Node.js modules such as `path`. Standard Expo project files like **app/index.js** can be run in Hermes, Node.js, or the web browser.
The approach to configure environment-specific globals differs between Flat config and legacy config:
For Flat config: 
For Flat config, **metro.config.js** files already work with Node.js globals because of the built-in support in `eslint-config-expo`. For other configuration files that might need Node.js globals, use [`languageOptions.globals`](https://eslint.org/docs/latest/use/configure/language-options#predefined-global-variables) in your **eslint.config.js**:
```js eslint.config.js
const { defineConfig, globalIgnores } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');
module.exports = defineConfig([
  globalIgnores(['dist/*']),
  expoConfig,
  {
    files: ['babel.config.js'],
    languageOptions: {
      globals: globals.node,
    },
  },
]);
```
For example, with this setup, you can now use Node.js globals in **babel.config.js**:
```js babel.config.js
import path from 'path';
const __dirname = path.dirname(__filename);
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};
```
For Legacy config: 
For legacy config, you can add the `eslint-env` comment to the top of a file to tell ESLint which environment the file is running in:
```js metro.config.js
/* eslint-env node */
const { getDefaultConfig } = require('expo/metro-config');
/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(
);
module.exports = config;
```
## Prettier
### Installation
To install Prettier in your project:
For macOS/Linux: 
```sh
$ npx expo install prettier eslint-config-prettier eslint-plugin-prettier --dev
```
For Windows: 
```sh
$ npx expo install prettier eslint-config-prettier eslint-plugin-prettier "--" --dev
```
### Setup
For Flat config: 
To integrate Prettier with ESLint, update your **eslint.config.js**:
```js eslint.config.js
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');
const eslintPluginPrettierRecommended = require('eslint-plugin-prettier/recommended');
module.exports = defineConfig([
  expoConfig,
  eslintPluginPrettierRecommended,
  {
    ignores: ['dist/*'],
  },
]);
```
For Legacy config: 
To integrate Prettier with ESlint, update your **.eslintrc.js**:
```js .eslintrc.js
module.exports = {
  extends: ['expo', 'prettier'],
  ignorePatterns: ['/dist/*'],
  plugins: ['prettier'],
  rules: {
    'prettier/prettier': 'error',
  },
};
```
> **Note:** In the above configuration, you can use `"prettier/prettier": "warn"` if you prefer these formatting issues as warnings instead of errors.
Now, when you run `npx expo lint`, anything that is not aligned with Prettier formatting will be caught as an error.
To customize Prettier settings, create a **.prettierrc** file at the root of your project and add your configuration.
## Troubleshooting
### ESLint is not updating in VS Code
If you're using VS Code, install the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) to lint your code as you type. You can try restarting the ESLint server by running the command `ESLint: Restart ESLint Server` from the [command palette](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).
### ESLint is slow
ESLint can be slow to run on large projects. The easiest way to speed up the process is to lint fewer files. Add a **.eslintignore** file to your project root to ignore certain files and directories such as:
```sh .eslintignore
# @info Ignore the root <b>.expo</b> directory. #
/.expo
# @end #
node_modules
```
## Migration to Flat config
> **info** **Note:** Flat config is supported in Expo SDK 53 and later.
Upgrade ESLint and `eslint-config-expo`:
For macOS/Linux: 
```sh
$ npx expo install eslint eslint-config-expo  --dev
```
For Windows: 
```sh
$ npx expo install eslint eslint-config-expo "--" --dev
```
If you haven't customized your ESLint config at all, delete your **.eslintrc.js** and generate the new config with:
```sh
$ npx expo lint
```
Alternatively, migrate your config based on the [ESLint's migration guide](https://eslint.org/docs/latest/use/configure/migration-guide). `npx expo lint` supports both legacy and flat config, so the new config will automatically be picked up by the CLI.


## Using TypeScript

An in-depth guide on configuring an Expo project with TypeScript.

Expo has first-class support for [TypeScript](https://www.typescriptlang.org/). The JavaScript interface of Expo SDK is written in TypeScript.
This guide provides a quick way to get started for a new project and also steps to migrate your existing JavaScript based Expo project to use TypeScript.
## Quick start
To create a new project, use the default template which includes base TypeScript configuration, example code, and basic navigation structure:
```sh
$ npx create-expo-app@latest
```
After you create a new project using the command above, make sure to follow instructions from:
- [Set up your environment](/get-started/set-up-your-environment/) which provides required steps for setting local development environment.
- [Start developing](/get-started/start-developing/) which provides information on triggering a development server, file structure, and details about other features.
## Migrating existing JavaScript project
To migrate your existing JavaScript based project to use TypeScript, follow the instructions below:
Step 1: 
### Rename files to use .tsx or .ts extension
Rename files to convert them to TypeScript. For example, start with the root component file such as **App.js** and rename it to **App.tsx**:
```sh
$ mv App.js App.tsx
```
> **info** **Tip:** Use the **.tsx** extension if the file includes React components (JSX). If the file does not include any JSX, you can use the **.ts** file extension.
Step 2: 
### Install required development dependencies
To install required `devDependencies` such as `typescript` and `@types/react` in **package.json**:
For macOS/Linux: 
```sh
$ npx expo install typescript @types/react --dev
```
For Windows: 
```sh
$ npx expo install typescript @types/react "--" --dev
```
> **info** Alternatively, run `npx expo start` command to install `typescript` and `@types/react` dev dependencies.
Note: Type checking project files with 
---
To type check your project's files run `tsc` command within the root of your project directory:
```sh
$ npm run tsc
$ yarn tsc
```
---
Step 3: 
### Add base configuration with tsconfig.json
A project's **tsconfig.json** should extend `expo/tsconfig.base` by default. You can automatically generate a **tsconfig.json** file by running the command:
```sh
$ npx expo customize tsconfig.json
```
The default configuration in **tsconfig.json** is user-friendly and encourages adoption. If you prefer **strict type checking** and reduce the chances of runtime errors, enable `strict` under [`compilerOptions`](https://www.typescriptlang.org/docs/handbook/compiler-options.html):
```json tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  }
}
```
Step 4: 
### Path aliases (Optional)
Expo CLI supports [path aliases](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) in **tsconfig.json** automatically. It allows importing modules with custom aliases instead of relative paths.
For example, to import `Button` component from **src/components/Button.tsx** using the alias **@/components/Button**, add the alias `@/*` in **tsconfig.json** and set it to the **src** directory:
```json tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```
Note: Disable path aliases
---
`tsconfigPaths` is enabled by default which allows you to set path aliases. You can disable it by setting `tsconfigPaths` to `false` in the project's [app config](/workflow/configuration/):
```json app.json
{
  "expo": {
    "experiments": {
      "tsconfigPaths": false
    }
  }
}
```
---
#### Considerations
When using path aliases, consider the following:
- Restart Expo CLI after modifying **tsconfig.json** to update path aliases. You don't need to clear the Metro cache when the aliases change.
- If not using TypeScript, **jsconfig.json** can serve as an alternative to **tsconfig.json**.
- Path aliases add additional resolution time when defined.
- Path aliases are only supported by Metro (including Metro web) and not by the deprecated `@expo/webpack-config`.
- Bare projects require additional setup for this feature. See the [Metro setup guide](/versions/latest/config/metro#bare-workflow-setup) for more information.
Step 5: 
### Absolute imports (Optional)
To enable absolute imports from a project's root directory, define [`compilerOptions.baseUrl`](https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url) the **tsconfig.json** file:
```json tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "baseUrl": "./"
  }
}
```
For example, setting the above configuration allows importing `Button` component from the path **src/components/Button**:
```tsx
import Button from 'src/components/Button';
```
#### Considerations
When using absolute imports, consider the following:
- `compilerOptions.paths` are resolved relative to the `compilerOptions.baseUrl` if it is defined, otherwise they're resolved against the project root directory.
- `compilerOptions.baseUrl` is resolved before node modules. This means if you have a file named `./path.ts`, it can be imported instead of a node module named `path`.
- Restarting Expo CLI is necessary to update [`compilerOptions.baseUrl`](https://www.typescriptlang.org/docs/handbook/module-resolution.html#base-url) after modifying the **tsconfig.json**.
- If you're not using TypeScript, **jsconfig.json** can serve as an alternative to **tsconfig.json**.
- Absolute imports are only supported by Metro (including Metro web) and not by `@expo/webpack-config`.
- Bare projects require additional setup for this feature. See the [versioned Metro setup guide](/versions/latest/config/metro#bare-workflow-setup) for more information.
## Type generation
Some Expo libraries provide both static types and type generation capabilities. These types are automatically generated when the project builds or by running the `npx expo customize tsconfig.json` command.
## TypeScript for project's config files
Additional setup is required to use TypeScript for configuration files such as **metro.config.js** or **app.config.js**.
Install [`tsx`](https://tsx.is/) as a dev dependency and utilize its [`tsx/cjs` require hook](https://tsx.is/dev-api/entry-point#commonjs-mode-only) to import TypeScript files within your JS configuration file. This hook allows TypeScript imports while keeping the root file as JavaScript. The command below adds `tsx` so `import 'tsx/cjs'` works in the following sub-section examples.
For macOS/Linux: 
```sh
$ npx expo install tsx --dev
```
For Windows: 
```sh
$ npx expo install tsx "--" --dev
```
### metro.config.js
Update **metro.config.js** to require **metro.config.ts** file:
```js metro.config.js
require('tsx/cjs'); // Add this to import TypeScript files
module.exports = require('./metro.config.ts');
```
Update **metro.config.ts** file with your project's metro configuration:
```ts metro.config.ts
import { getDefaultConfig } from 'expo/metro-config';
const config = getDefaultConfig(__dirname);
module.exports = config;
```
Note: Deprecated: webpack.config.js
---
Install the `@expo/webpack-config` package.
```js webpack.config.js
require('tsx/cjs'); // Add this to import TypeScript files
module.exports = require('./webpack.config.ts');
```
```ts webpack.config.ts
import createExpoWebpackConfigAsync from '@expo/webpack-config/webpack';
import { Arguments, Environment } from '@expo/webpack-config/webpack/types';
module.exports = async function (env: Environment, argv: Arguments) {
  const config = await createExpoWebpackConfigAsync(env, argv);
  // Customize the config before returning it.
  return config;
};
```
---
### app.config.js
**app.config.ts** is supported by default. However, it doesn't support external TypeScript modules, or **tsconfig.json** customization. You can use the following approach to get a more comprehensive TypeScript setup:
```ts app.config.ts
import 'tsx/cjs'; // Add this to import TypeScript files
import { ExpoConfig } from 'expo/config';
const config: ExpoConfig = {
  name: 'my-app',
  slug: 'my-app',
};
export default config;
```
## Other TypeScript features
Some language features may require additional configuration. For example, if you want to use decorators you'll need to add the `experimentalDecorators` option. For more information on the available properties see the [TypeScript compiler options](https://www.typescriptlang.org/docs/handbook/compiler-options.html) documentation.
## Learn how to use TypeScript
A good place to start learning TypeScript is the official [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html).
**For TypeScript and React components,** we recommend referring to the [React TypeScript CheatSheet](https://github.com/typescript-cheatsheets/react) to learn how to type your React components in a variety of common situations.


# TV apps

## Build Expo apps for TV

A guide for building an Expo app for an Android TV or Apple TV target.

> **Warning** Not all Expo features and SDK libraries are available on TV. For more details, check the [See which libraries are supported](#see-which-libraries-are-supported).
React Native is supported on Android TV and Apple TV through the [React Native TV project](https://github.com/react-native-tvos/react-native-tvos). This technology extends beyond TV, offering a comprehensive core repo fork with support for phone and TV targets, including Hermes and Fabric.
Using the React Native TV library as the `react-native` dependency in an Expo project, it becomes capable of targeting both mobile (Android, iOS) and TV (Android TV, Apple TV) devices.
## Prerequisites
The necessary changes to the native Android and iOS files are minimal and can be automated with a [config plugin](https://github.com/react-native-tvos/config-tv/tree/main/packages/config-tv) if you use [prebuild](/workflow/prebuild/). Below is a list of changes made by the config plugins, which you can alternatively apply manually:
### Android
- **AndroidManifest.xml** is modified:
  - The default phone portrait orientation is removed
  - The required intent for TV apps is added
- **MainApplication.kt** is modified to remove unsupported Flipper invocations
### iOS
- **ios/Podfile** is modified to target tvOS instead of iOS
- The Xcode project is modified to target tvOS instead of iOS
- The splash screen (**SplashScreen.storyboard**) is modified to work on tvOS
## System requirements for TV development
### Android TV
- [Node.js (LTS)](https://nodejs.org/en/) on macOS or Linux.
- Android Studio (Iguana or later).
- In the Android Studio SDK manager, select the dropdown for the Android SDK you are using (API version 31 or later), and make sure an Android TV system image is selected for installation. (For Apple silicon, choose the ARM 64 image. Otherwise, choose the Intel x86_64 image).
- After installing the Android TV system image, create an Android TV emulator using that image (the process is the same as creating an Android phone emulator).
### Apple TV
- [Node.js (LTS)](https://nodejs.org/en/) on macOS.
- Xcode 16 or later.
- tvOS SDK 17 or later. (This is not installed automatically with Xcode. You can install it later with `xcodebuild -downloadAllPlatforms`).
## Quick start
The fastest way to generate a new project is described in the [TV example](https://github.com/expo/examples/tree/master/with-tv) within the Expo examples repository:
```sh
$ npx create-expo-app MyTVProject -e with-tv
```
You can start with the [TV Router example](https://github.com/expo/examples/tree/master/with-router-tv):
```sh
$ npx create-expo-app MyTVProject -e with-router-tv
```
This creates a new project that uses [Expo Router](/router/introduction/) for file-based navigation, modeled after the [**create-expo-app** default template](/get-started/create-a-project/).
Note: See which libraries are supported
---
At this time, TV applications work with the following libraries and APIs listed below:
- [AppleAuthentication](/versions/latest/sdk/apple-authentication/)
- [Application](/versions/latest/sdk/application/)
- [Audio](/versions/latest/sdk/audio)
- [Asset](/versions/latest/sdk/asset/)
- [AsyncStorage](/versions/latest/sdk/async-storage/)
- [AV](/versions/latest/sdk/av/)
- [BackgroundTask](/versions/latest/sdk/background-task/)
- [BlurView](/versions/latest/sdk/blur-view/)
- [BuildProperties](/versions/latest/sdk/build-properties/)
- [Constants](/versions/latest/sdk/constants/)
- [Crypto](/versions/latest/sdk/crypto/)
- [DevClient](/versions/latest/sdk/dev-client/)
- [Device](/versions/latest/sdk/device/)
- [Expo UI](/versions/latest/sdk/ui/)
- [FileSystem](/versions/latest/sdk/filesystem/)
- [FlashList](/versions/latest/sdk/flash-list/)
- [Font](/versions/latest/sdk/font/)
- [GlassEffect](/versions/latest/sdk/glass-effect/)
- [Image](/versions/latest/sdk/image)
- [ImageManipulator](/versions/latest/sdk/imagemanipulator/)
- [KeepAwake](/versions/latest/sdk/keep-awake/)
- [LinearGradient](/versions/latest/sdk/linear-gradient/)
- [Localization](/versions/latest/sdk/localization/)
- [Manifests](/versions/latest/sdk/manifests/)
- [MediaLibrary](/versions/latest/sdk/media-library/)
- [NetInfo](/versions/latest/sdk/netinfo/)
- [Network](/versions/latest/sdk/network/)
- [Reanimated](/versions/latest/sdk/reanimated/)
- [SafeAreaContext](/versions/latest/sdk/safe-area-context/)
- [SecureStore](/versions/latest/sdk/securestore/)
- [Skia](/versions/latest/sdk/skia/)
- [SplashScreen](/versions/latest/sdk/splash-screen/)
- [SQLite](/versions/latest/sdk/sqlite/)
- [Svg](/versions/latest/sdk/svg/)
- [SystemUI](/versions/latest/sdk/system-ui/)
- [TaskManager](/versions/latest/sdk/task-manager/)
- [TrackingTransparency](/versions/latest/sdk/tracking-transparency/)
- [Updates](/versions/latest/sdk/updates/)
- [Video](/versions/latest/sdk/video/)
- [VideoThumbnails](/versions/latest/sdk/video-thumbnails/)
TV also works with [React Navigation](https://reactnavigation.org/), [React Native Skia](https://shopify.github.io/react-native-skia/), and many other commonly used third-party React Native libraries. See [React Native directory](https://reactnative.directory/?tvos=true) to learn more about supported third-party libraries.
#### Limitations
- The [Expo DevClient](/versions/latest/sdk/dev-client/) library is only supported in SDK 54 and later:
  - **Android TV**: All operations are supported, similar to an Android phone.
  - **Apple TV**: Basic operations with a local or tunneled packager are supported. Authentication to EAS and listing of EAS builds and updates is not yet supported.
---
## Integration with an existing Expo project
The following walkthrough describes the steps required to modify an Expo project for TV.
Step 1: 
### Modify dependencies for TV
In **package.json**, modify the `react-native` dependency to use the TV repo, and exclude this dependency from [`npx expo install` version validation](/more/expo-cli/#configuring-dependency-validation).
> **Warning** The `react-native-tvos` version should match the Expo SDK you are using. For example, Expo SDK 54 uses React Native 0.81, so you should use `react-native-tvos@0.81-stable` (the latest 0.81 version) as shown below. See the [SDK compatibility table](/versions/latest/#each-expo-sdk-version-depends-on-a-react-native-version) for the correct version to use for older SDKs.
```json package.json
{
  "dependencies": {
    "react-native": "npm:react-native-tvos@0.81-stable",
  },
  "expo": {
    "install": {
      "exclude": [
        "react-native"
      ]
    }
  }
}
```
Step 2: 
### Add the TV config plugin
```sh
$ npx expo install @react-native-tvos/config-tv -- --dev
```
When installed, the plugin will modify the project for TV when either:
- The environment variable `EXPO_TV` is set to `1`
- The plugin parameter `isTV` is set to `true`
Verify that this plugin appears in **app.json**:
```json app.json
{
  "plugins": ["@react-native-tvos/config-tv"]
}
```
To see additional information on the plugin's actions during prebuild, you can set [debug environment variables](https://github.com/debug-js/debug#conventions) before running prebuild. (See also our documentation on [Expo CLI environment variables](/more/expo-cli/#environment-variables).)
```sh
$ export DEBUG=expo:*
$ export DEBUG=expo:react-native-tvos:config-tv
```
Step 3: 
### Run prebuild
Set the `EXPO_TV` environment variable, and run prebuild to make the TV modifications to the project.
```sh
$ export EXPO_TV=1
$ npx expo prebuild --clean
```
> **Note**: The `--clean` argument is recommended, and is required if you have existing Android and iOS directories in the project.
Step 4: 
### Build for Android TV
Start an Android TV emulator and use the following command to start the app on the emulator:
```sh
$ npx expo run:android
```
Step 5: 
### Build for Apple TV
Run the following command to build and run the app on an Apple TV simulator:
```sh
$ npx expo run:ios
```
Step 6: 
### Revert TV changes and build for phone
You can revert the changes for TV and go back to phone development by unsetting `EXPO_TV` and running prebuild again:
```sh
$ unset EXPO_TV
$ npx expo prebuild --clean
```
Step 7: 
### Create EAS Build profiles for both TV and phone
Since the TV build can be driven by the value of an environment variable, it is easy to set up EAS Build profiles that build from the same source but target TV instead of phone.
The following example **eas.json** shows how to extend existing profiles (`development` and `preview`) to create TV profiles (`development_tv` and `preview_tv`).
```json eas.json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "base": {
      "distribution": "internal",
      "ios": {
        "simulator": true
      },
      "android": {
        "buildType": "apk",
        "withoutCredentials": true
      },
      "channel": "base"
    },
    "development": {
      "extends": "base",
      "android": {
        "gradleCommand": ":app:assembleDebug"
      },
      "ios": {
        "buildConfiguration": "Debug"
      },
      "channel": "development"
    },
    "development_tv": {
      "extends": "development",
      "env": {
        "EXPO_TV": "1"
      },
      "channel": "development"
    },
    "preview": {
      "extends": "base",
      "channel": "preview"
    },
    "preview_tv": {
      "extends": "preview",
      "env": {
        "EXPO_TV": "1"
      },
      "channel": "preview"
    }
  },
  "submit": {}
}
```
## Examples and demonstration projects


# Web apps

## Using Next.js with Expo for Web

A guide for integrating Next.js with Expo for the web.

> **warning** Using Next.js is not an official part of Expo's universal app development workflow.
[Next.js](https://nextjs.org/) is a React framework that provides simple page-based routing as well as server-side rendering. To use Next.js with the Expo SDK, we recommend using [`@expo/next-adapter`](https://github.com/expo/expo-cli/tree/main/packages/next-adapter) library to handle the configuration.
Using Expo with Next.js means you can share some of your existing components and APIs across your mobile and web app. Next.js has its own CLI that you'll need to use when developing for the web platform, so **you'll need to start your web projects with the Next.js CLI and not with `npx expo start`**.
> Next.js can only be used with Expo for web as there is no support for Server-Side Rendering (SSR) for native apps.
## Automatic setup
To quickly get started, create a new project using [with-nextjs](https://github.com/expo/examples/tree/master/with-nextjs) template:
```sh
$ npx create-expo-app -e with-nextjs
```
- **Native**: `npx expo start` &mdash; start the Expo project
- **Web**: `npx next dev` &mdash; start the Next.js project
## Manual setup
### Install dependencies
Ensure you have `expo`, `next`, `@expo/next-adapter` installed in your project:
```sh
$ yarn add expo next @expo/next-adapter
```
### Transpilation
Configure Next.js to transform language features:
Note: Next.js with swc. (Recommended)
---
Using Next.js with SWC is recommended. You can configure the [**babel.config.js**](/versions/latest/config/babel/) to only account for native:
```js babel.config.js
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
  };
};
```
You will also have to [force Next.js to use SWC](https://nextjs.org/docs/messages/swc-disabled) by adding the following to your **next.config.js**:
```js next.config.js
module.exports = {
  experimental: {
    forceSwcTransforms: true,
  },
};
```
---
Note: Next.js with Babel. (Not recommended)
---
Adjust your **babel.config.js** to conditionally add `next/babel` when bundling with webpack for web:
```js babel.config.js
module.exports = function (api) {
  // Detect web usage (this may change in the future if Next.js changes the loader)
  const isWeb = api.caller(
    caller =>
      caller && (caller.name === 'babel-loader' || caller.name === 'next-babel-turbo-loader')
  );
  return {
    presets: [
      // Only use next in the browser, it'll break your native project
      isWeb && require('next/babel'),
      'babel-preset-expo',
    ].filter(Boolean),
  };
};
```
---
### Next.js configuration
Add the following to your **next.config.js**:
```js next.config.js
const { withExpo } = require('@expo/next-adapter');
module.exports = withExpo({
  // transpilePackages is a Next.js +13.1 feature.
  // older versions can use next-transpile-modules
  transpilePackages: [
    'react-native',
    'react-native-web',
    'expo',
    // Add more React Native/Expo packages here...
  ],
});
```
The fully qualified Next.js config may look like:
```js next.config.js
const { withExpo } = require('@expo/next-adapter');
/** @type {import('next').NextConfig} */
const nextConfig = withExpo({
  reactStrictMode: true,
  swcMinify: true,
  transpilePackages: [
    'react-native',
    'react-native-web',
    'expo',
    // Add more React Native/Expo packages here...
  ],
  experimental: {
    forceSwcTransforms: true,
  },
});
module.exports = nextConfig;
```
### React Native Web styling
The package `react-native-web` builds on the assumption of reset CSS styles. Here's how you reset styles in Next.js using the **pages** directory.
```jsx pages/_document.js
import { Children } from 'react';
import Document, { Html, Head, Main, NextScript } from 'next/document';
import { AppRegistry } from 'react-native';
// Follows the setup for react-native-web:
// https://necolas.github.io/react-native-web/docs/setup/#root-element
// Plus additional React Native scroll and text parity styles for various
// browsers.
// Force Next-generated DOM elements to fill their parent's height
const style = `
html, body, #__next {
  -webkit-overflow-scrolling: touch;
}
#__next {
  display: flex;
  flex-direction: column;
  height: 100%;
}
html {
  scroll-behavior: smooth;
  -webkit-text-size-adjust: 100%;
}
body {
  /* Allows you to scroll below the viewport; default value is visible */
  overflow-y: auto;
  overscroll-behavior-y: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -ms-overflow-style: scrollbar;
}
`;
export default class MyDocument extends Document {
  static async getInitialProps({ renderPage }) {
    AppRegistry.registerComponent('main', () => Main);
    const { getStyleElement } = AppRegistry.getApplication('main');
    const page = await renderPage();
    const styles = [
      <style key="react-native-style" dangerouslySetInnerHTML={{ __html: style }} />,
      getStyleElement(),
    ];
    return { ...page, styles: Children.toArray(styles) };
  }
  render() {
    return (
      <Html style={{ height: '100%' }}>
        <Head />
        <body style={{ height: '100%', overflow: 'hidden' }}>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}
```
```jsx pages/_app.js
import Head from 'next/head';
export default function App({ Component, pageProps }) {
  return (
    <>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>
      <Component {...pageProps} />
    </>
  );
}
```
## Transpiling modules
By default, modules in the React Native ecosystem are not transpiled to run in web browsers. React Native relies on advanced caching in Metro to reload quickly. Next.js uses webpack, which does not have the same level of caching, so no node modules are transpiled by default. You will have to manually mark every module you want to transpile with the `transpilePackages` option in **next.config.js**:
```js next.config.js
const { withExpo } = require('@expo/next-adapter');
module.exports = withExpo({
  experimental: {
    transpilePackages: [
      // NOTE: Even though `react-native` is never used in Next.js,
      // you need to list `react-native` because `react-native-web`
      // is aliased to `react-native`.
      'react-native',
      'react-native-web',
      'expo',
      // Add more React Native/Expo packages here...
    ],
  },
});
```
## Deploy to Vercel
This is Vercel's preferred method for deploying Next.js projects to production.
Step 1: 
Add a `build` script to your **package.json**:
```json package.json
{
  "scripts": {
    "build": "next build"
  }
}
```
Step 2: 
Install the Vercel CLI:
```sh
$ npm i -g vercel
```
Step 3: 
Deploy to Vercel:
```sh
$ vercel
```
## Limitations or differences compared to the default Expo for Web
Using Next.js for the web means you will be bundling with the Next.js webpack config. This will lead to some core differences in how you develop your app vs your website.
- Expo Next.js adapter does not support the experimental **app** directory.
- For file-based routing on native, we recommend using [Expo Router](https://github.com/expo/router).
## Contributing
If you would like to help make Next.js support in Expo better, feel free to open a PR or submit an issue:
- [@expo/next-adapter](https://github.com/expo/expo-cli/tree/main/packages/next-adapter)
## Troubleshooting
### Cannot use import statement outside a module
Figure out which module has the import statement and add it to the `transpilePackages` option in **next.config.js**:
```js next.config.js
const { withExpo } = require('@expo/next-adapter');
module.exports = withExpo({
  experimental: {
    transpilePackages: [
      'react-native',
      'react-native-web',
      'expo',
      // Add the failing package here, and restart the server...
    ],
  },
});
```


# More

## Upgrade Expo SDK

Learn how to incrementally upgrade the Expo SDK version in your project.

> **info** We recommend upgrading SDK versions incrementally, one at a time. Doing so will help you pinpoint breakages and issues that arise during the upgrade process.
With a new SDK release, the latest version enters the current release status. This applies to Expo Go as it only supports the latest SDK version and previous versions are no longer supported. We recommend using [development builds](/develop/development-builds/introduction/) for production apps as the backwards compatibility for older SDK versions on EAS services tends to be much longer, but not forever.
If you are looking to install a specific version of Expo Go, visit [expo.dev/go](https://expo.dev/go). It supports downloads for Android devices/emulators and iOS simulators. However, due to iOS platform restrictions, only the latest version of Expo Go is available for installation on physical iOS devices.
Video Tutorial: [Watch: How to upgrade from Expo SDK 53 to SDK 54 in 5 minutes](https://www.youtube.com/watch?v=QuN63BRRhAM)
## How to upgrade to the latest SDK version
Step 1: 
### Upgrade the Expo SDK
Install the new version of the Expo package:
  For npm: 
    ```sh
$ npm install expo@^54.0.0
```
  For Yarn: 
    ```sh
$ yarn add expo@^54.0.0
```
  For pnpm: 
    ```sh
$ pnpm add expo@^54.0.0
```
  For Bun: 
    ```sh
$ bun install expo@^54.0.0
```
Depending on which SDK you're upgrading to, substitute the `expo@^54.0.0` with the version range of the Expo SDK version you're targeting. For example, `expo@^54.0.0` stands for SDK 54.
Step 2: 
### Upgrade dependencies
Upgrade all dependencies to match the installed SDK version. Then run [`expo-doctor`](/develop/tools/#expo-doctor) command to check for common problems.
```sh
$ npx expo install --fix
$ npx expo-doctor
```
Step 3: 
### Update native projects
- **If you use [Continuous Native Generation](/workflow/continuous-native-generation/)**: Delete the **android** and **ios** directories if you generated them for a previous SDK version in your local project directory. They'll be re-generated next time you run a build, either with `npx expo run:ios`, `npx expo prebuild`, or with EAS Build.
- **If you don't use [Continuous Native Generation](/workflow/continuous-native-generation/)**: Run `npx pod-install` if you have an **ios** directory. Apply any relevant changes from the [Native project upgrade helper](/bare/upgrade/). Alternatively, you could consider [adopting prebuild](/guides/adopting-prebuild/) for easier upgrades in the future.
Step 4: 
### Follow the release notes for any other instructions
Read the [SDK changelogs](#sdk-changelogs) for the SDK version you are upgrading to. They contain important information about breaking changes, deprecations, and other changes that may affect your app. Refer to the "Upgrading your app" section at the bottom of the release notes page for any additional instructions.
## SDK Changelogs
Each SDK announcement release notes post contains information deprecations, breaking changes, and anything else that might be unique to that particular SDK version. When upgrading, be sure to check these out to make sure you don't miss anything.
- **SDK 54**: [Release notes](https://expo.dev/changelog/sdk-54)
- **SDK 53**: [Release notes](https://expo.dev/changelog/sdk-53)
- **SDK 52**: [Release notes](https://expo.dev/changelog/2024-11-12-sdk-52)
  - **React Native 0.77 is available with Expo SDK 52**. To upgrade, see these [Release notes](https://expo.dev/changelog/2025/01-21-react-native-0.77).
### Deprecated SDK Version Changelogs
The following blog posts may included outdated information, but they are still useful for reference if you happen to fall far behind on SDK upgrades.
Note: See a full list of deprecated SDK release changelogs
---
- **SDK 51**: [Release notes](https://expo.dev/changelog/2024-05-07-sdk-51)
- **SDK 50**: [Release notes](https://expo.dev/changelog/2024-01-18-sdk-50)
- **SDK 49**: [Release notes](https://blog.expo.dev/expo-sdk-49-c6d398cdf740)
- **SDK 48**: [Release notes](https://blog.expo.dev/expo-sdk-48-ccb8302e231)
- **SDK 47**: [Release notes](https://blog.expo.dev/expo-sdk-47-a0f6f5c038af)
- **SDK 46**: [Release notes](https://blog.expo.dev/expo-sdk-46-c2a1655f63f7)
- **SDK 45**: [Release notes](https://blog.expo.dev/expo-sdk-45-f4e332954a68)
- **SDK 44**: [Release notes](https://blog.expo.dev/expo-sdk-44-4c4b8306584a)
- **SDK 43**: [Release notes](https://blog.expo.dev/expo-sdk-43-aa9b3c7d5541)
- **SDK 42**: [Release notes](https://blog.expo.dev/expo-sdk-42-579aee2348b6)
- **SDK 41**: [Release notes](https://blog.expo.dev/expo-sdk-41-12cc5232f2ef)
- **SDK 40**: [Release notes](https://dev.to/expo/expo-sdk-40-is-now-available-1in0)
- **SDK 39**: [Release notes](https://dev.to/expo/expo-sdk-39-is-now-available-1lm8)
- **SDK 38**: [Release notes](https://dev.to/expo/expo-sdk-38-is-now-available-5aa0)
- **SDK 37**: [Release notes](https://dev.to/expo/expo-sdk-37-is-now-available-69g)
- **SDK 36**: [Release notes](https://blog.expo.dev/expo-sdk-36-is-now-available-b91897b437fe)
- **SDK 35**: [Release notes](https://blog.expo.dev/expo-sdk-35-is-now-available-beee0dfafbf4)
---


# Assorted

## Authentication with OAuth or OpenID providers

Learn how to utilize the expo-auth-session library to implement authentication with OAuth or OpenID providers.

[`expo-auth-session`](/versions/latest/sdk/auth-session) provides a unified API for implementing OAuth and OpenID Connect providers on Android, iOS, and web. This guide will show you how to use the `AuthSession` API using a few examples.
## Rules for all authentication providers
When using the `AuthSession` API, the following rules apply to all authentication providers:
- Use `WebBrowser.maybeCompleteAuthSession()` to dismiss the web popup. If you forget to add this then the popup window will not close.
- Create redirects with `AuthSession.makeRedirectUri()` this does a lot of the heavy lifting involved with universal platform support. Behind the scenes, it uses `expo-linking`.
- Build requests using `AuthSession.useAuthRequest()`, the hook allows for async setup which means mobile browsers won't block the authentication.
- Be sure to disable the prompt until `request` is defined.
- You can only invoke `promptAsync` in user interaction on the web.
- Expo Go cannot be used for local development and testing of OAuth or OpenID Connect-enabled apps due to the inability to customize your app scheme. You can instead use a [Development Build](/develop/development-builds/introduction/), which enables an Expo Go-like development experience and supports OAuth redirects back to your app after login in a manner that works just like it would in production.
## Obtaining access tokens
Most providers use the [OAuth 2](https://oauth.net/2/) standard for secure authentication and authorization. In the authorization code grant, the identity provider returns a one-time code. This code is then exchanged for the user's access token.
Since [your client application code is not a secure place to store secrets](https://reactnative.dev/docs/security#storing-sensitive-info), it is necessary to exchange the authorization code in a server such as with [API routes](/router/web/api-routes) or [React Server Components](/guides/server-components). This will allow you to securely store and use a client secret to access the provider's token endpoint.
## Examples
The following examples show how to use the `AuthSession` API to authenticate with a few popular providers.
<Box
  name="GitHub"
  createUrl="https://github.com/settings/developers"
  image={ASSETS.github}
>
| Website                                                   | Provider  | PKCE      | Auto Discovery |
| --------------------------------------------------------- | --------- | --------- | -------------- |
| [Get Your Config](https://github.com/settings/developers) | OAuth 2.0 | Supported | Not Available  |
- Provider only allows one redirect URI per app. You'll need an individual app for every method you want to use:
  - Standalone / development build: `com.your.app://*`
  - Web: `https://yourwebsite.com/*`
- The `redirectUri` requires two slashes (`://`).
- `revocationEndpoint` is dynamic and requires your `config.clientId`.
```tsx GitHub Auth Example
import { useEffect } from 'react';
import * as WebBrowser from 'expo-web-browser';
import { makeRedirectUri, useAuthRequest } from 'expo-auth-session';
import { Button } from 'react-native';
WebBrowser.maybeCompleteAuthSession();
// Endpoint
const discovery = {
  authorizationEndpoint: 'https://github.com/login/oauth/authorize',
  tokenEndpoint: 'https://github.com/login/oauth/access_token',
  revocationEndpoint: 'https://github.com/settings/connections/applications/<CLIENT_ID>',
};
export default function App() {
  const [request, response, promptAsync] = useAuthRequest(
    {
      clientId: 'CLIENT_ID',
      scopes: ['identity'],
      redirectUri: makeRedirectUri({
        scheme: 'your.app'
      }),
    },
    discovery
  );
  useEffect(() => {
    if (response?.type === 'success') {
      const { code } = response.params;
    }
  }, [response]);
  return (
    <Button
      disabled={!request}
      title="Login"
      onPress={() => {
        promptAsync();
      }}
    />
  );
}
```
</Box>
<Box
  name="Okta"
  createUrl="https://developer.okta.com/signup"
  image={ASSETS.okta}
>
| Website                                                      | Provider | PKCE      | Auto Discovery |
| ------------------------------------------------------------ | -------- | --------- | -------------- |
| [Sign-up](https://developer.okta.com/signup/) > Applications | OpenID   | Supported | Available      |
- You cannot define a custom `redirectUri`, Okta will provide you with one.
```tsx Okta Auth Example
import { useEffect } from 'react';
import * as WebBrowser from 'expo-web-browser';
import { makeRedirectUri, useAuthRequest, useAutoDiscovery } from 'expo-auth-session';
import { Button, Platform } from 'react-native';
WebBrowser.maybeCompleteAuthSession();
export default function App() {
  // Endpoint
  const discovery = useAutoDiscovery('https://<OKTA_DOMAIN>.com/oauth2/default');
  // Request
  const [request, response, promptAsync] = useAuthRequest(
    {
      clientId: 'CLIENT_ID',
      scopes: ['openid', 'profile'],
      redirectUri: makeRedirectUri({
        native: 'com.okta.<OKTA_DOMAIN>:/callback',
      }),
    },
    discovery
  );
  useEffect(() => {
    if (response?.type === 'success') {
      const { code } = response.params;
    }
  }, [response]);
  return (
    <Button
      disabled={!request}
      title="Login"
      onPress={() => {
        promptAsync();
      }}
    />
  );
}
```
</Box>
{/* End Okta */}
## Redirect URI patterns
Here are a few examples of some common redirect URI patterns you may end up using.
### Standalone/development build
> `yourscheme://path`
In some cases there will be anywhere between 1 to 3 slashes (`/`).
- **Environment:**
  - Bare workflow
    - `npx expo prebuild`
  - Standalone builds in the App or Play Store or testing locally
    - Android: `eas build` or `npx expo run:android`
    - iOS: `eas build` or `npx expo run:ios`
- **Create:** Use `AuthSession.makeRedirectUri({ native: '<YOUR_URI>' })` to select native when running in the correct environment.
  - `your.app://redirect` -> `makeRedirectUri({ scheme: 'your.app', path: 'redirect' })`
  - `your.app:///` -> `makeRedirectUri({ scheme: 'your.app', isTripleSlashed: true })`
  - `your.app:/authorize` -> `makeRedirectUri({ native: 'your.app:/authorize' })`
  - `your.app://auth?foo=bar` -> `makeRedirectUri({ scheme: 'your.app', path: 'auth', queryParams: { foo: 'bar' } })`
  - `exp://u.expo.dev/[project-id]?channel-name=[channel-name]&runtime-version=[runtime-version]` -> `makeRedirectUri()`
  - This link can often be created automatically but we recommend you define the `scheme` property at least. The entire URL can be overridden in apps by passing the `native` property. Often this will be used for providers like Google or Okta which require you to use a custom native URI redirect. You can add, list, and open URI schemes using `npx uri-scheme`.
  - If you change the `expo.scheme` after ejecting then you'll need to use the `expo apply` command to apply the changes to your native project, then rebuild them (`yarn ios`, `yarn android`).
- **Usage:** `promptAsync({ redirectUri })`
## Improving user experience
The "login flow" is an important thing to get right, in a lot of cases this is where the user will _commit_ to using your app again. A bad experience can cause users to give up on your app before they've really gotten to use it.
Here are a few tips you can use to make authentication quick, easy, and secure for your users:
### Warming the browser
On Android you can optionally warm up the web browser before it's used. This allows the browser app to pre-initialize itself in the background. Doing this can significantly speed up prompting the user for authentication.
```tsx
import { useEffect } from 'react';
import * as WebBrowser from 'expo-web-browser';
function App() {
  useEffect(() => {
    WebBrowser.warmUpAsync();
    return () => {
      WebBrowser.coolDownAsync();
    };
  }, []);
  // Do authentication ...
}
```
### Implicit login
Because there was no secure way to do this to store client secrets in your app bundle, historically, many providers have offered an "Implicit flow" which enables you to request an access token without the client secret. **This is no longer recommended** due to inherent security risks, including the risk of access token injection. Instead, most providers now support the authorization code with PKCE (Proof Key for Code Exchange) extension to securely exchange an authorization code for an access token within your client app code. Learn more about [transitioning from Implicit flow to authorization code with PKCE](https://oauth.net/2/grant-types/implicit/).
`expo-auth-session` still supports Implicit flow for legacy code purposes. Below is an example implementation of the Implicit flow.
```tsx
import { useEffect } from 'react';
import * as WebBrowser from 'expo-web-browser';
import { makeRedirectUri, useAuthRequest, ResponseType } from 'expo-auth-session';
WebBrowser.maybeCompleteAuthSession();
// Endpoint
const discovery = {
  authorizationEndpoint: 'https://accounts.spotify.com/authorize',
};
function App() {
  const [request, response, promptAsync] = useAuthRequest(
    {
      responseType: ResponseType.Token,
      clientId: 'CLIENT_ID',
      scopes: ['user-read-email', 'playlist-modify-public'],
      redirectUri: makeRedirectUri({
        scheme: 'your.app'
      }),
    },
    discovery
  );
  useEffect(() => {
    if (response && response.type === 'success') {
      const token = response.params.access_token;
    }
  }, [response]);
  return <Button disabled={!request} onPress={() => promptAsync()} title="Login" />;
}
```
### Storing data
On native platforms such as Android and iOS, you can secure things like access tokens locally using a library called [`expo-secure-store`](/versions/latest/sdk/securestore) (This is different to `AsyncStorage` which is not secure). It provides native access to encrypted [`SharedPreferences`](https://developer.android.com/training/basics/data-storage/shared-preferences.html) on Android and [keychain services](https://developer.apple.com/documentation/security/keychain_services) on iOS and . There is no web equivalent to this functionality.
You can store your authentication results and rehydrate them later to avoid having to prompt the user to login again.
```tsx
import * as SecureStore from 'expo-secure-store';
const MY_SECURE_AUTH_STATE_KEY = 'MySecureAuthStateKey';
function App() {
  const [, response] = useAuthRequest({});
  useEffect(() => {
    if (response && response.type === 'success') {
      const auth = response.params;
      const storageValue = JSON.stringify(auth);
      if (Platform.OS !== 'web') {
        // Securely store the auth on your device
        SecureStore.setItemAsync(MY_SECURE_AUTH_STATE_KEY, storageValue);
      }
    }
  }, [response]);
  // More login code...
}
```


## Using Hermes Engine

A guide on configuring Hermes for both Android and iOS in an Expo project.

[Hermes](https://hermesengine.dev/) is a JavaScript engine optimized for React Native. By compiling JavaScript into bytecode ahead of time, Hermes can improve your app start-up time. The binary size of Hermes is also smaller than other JavaScript engines, such as JavaScriptCore (JSC). It also uses less memory at runtime, which is particularly valuable on lower-end Android devices.
## Support
The Hermes engine is the default JavaScript engine used by Expo and it is fully supported across all Expo tooling.
### Switch JavaScript engine on a specific platform
You may want to use Hermes on one platform and JSC on another. One way to do this is to set the `"jsEngine"` to `"hermes"` at the top level in app config and then override it with `"jsc"` under the `"ios"` key. You may alternatively prefer to explicitly set `"hermes"` on just the `"android"` key in this case.
```json app.json
{
  "expo": {
    "jsEngine": "hermes",
    "ios": {
      "jsEngine": "jsc"
    }
  }
}
```
## Publish updates
Publishing updates with `eas update` and `npx expo export` will generate Hermes bytecode bundles and their source maps.
Note that the Hermes bytecode format may change between different Hermes versions &mdash; an update produced for a specific version of Hermes will not run on a different version of Hermes. Starting from Expo SDK 46 (React Native 0.69), [Hermes is bundled within React Native](https://reactnative.dev/architecture/bundled-hermes). Updating React Native version or Hermes version can be thought of in the same way as updating any other native module. So if you update the `react-native` version you should also update the `runtimeVersion` in **app.json**. If you don't do this, your app may crash on launch because the update may be loaded by an existing binary that uses an older Hermes version that is incompatible with the updated bytecode format. See [`runtimeVersion`](/eas-update/runtime-versions/) for more information.
## JavaScript debugger
To debug JavaScript code running with Hermes, you can start your project with `npx expo start` then press <kbd>j</kbd> to open the debugger in Google Chrome or Microsoft Edge. The developer menu of development builds and Expo Go also have the **Open JS Debugger** option to do the same.
Alternatively, you can use the JavaScript inspector by opening [Google Chrome DevTools manually](https://reactnative.dev/docs/other-debugging-methods#remote-javascript-debugging-deprecated)
### Troubleshooting
> **warning** `No compatible apps connected. JavaScript Debugging can only be used with the Hermes engine.` when opening the debugger.
- Make sure you [set up Hermes in the `jsEngine` field](#setup).
- If your app is built by `eas build`, `npx expo run:android` or `npx expo run:ios`, make sure it is a debug build.
- Internally, the app will establish a WebSocket connection, make sure your app is connected to the development server.
  - Try to reload the app by pressing <kbd>r</kbd> in the Expo CLI Terminal UI.
  - Test debugging availability by running the command: `curl http://127.0.0.1:8081/json/list` (adjust the `127.0.0.1:8081` to match your dev server URL). The HTTP response should be an array, as shown below. If it is an empty response, add either the `--localhost` or `--tunnel` flag to the `npx expo start` command.
  ```json
  [
    {
      "id": "0-2",
      "description": "host.exp.Exponent",
      "title": "Hermes ABI47_0_0React Native",
      "faviconUrl": "https://react.dev/favicon.ico",
      "devtoolsFrontendUrl": "devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=%5B%3A%3A1%5D%3A8081%2Finspector%2Fdebug%3Fdevice%3D0%26page%3D2",
      "type": "node",
      "webSocketDebuggerUrl": "ws://[::1]:8081/inspector/debug?device=0&page=2",
      "vm": "Hermes"
    },
    {
      "id": "0--1",
      "description": "host.exp.Exponent",
      "title": "React Native Experimental (Improved Chrome Reloads)",
      "faviconUrl": "https://react.dev/favicon.ico",
      "devtoolsFrontendUrl": "devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=%5B%3A%3A1%5D%3A8081%2Finspector%2Fdebug%3Fdevice%3D0%26page%3D-1",
      "type": "node",
      "webSocketDebuggerUrl": "ws://[::1]:8081/inspector/debug?device=0&page=-1",
      "vm": "don't use"
    }
  ]
  ```
### Can I use Remote Debugging with Hermes?
One of the many limitations of [remote debugging](/more/glossary-of-terms/#remote-debugging) is that it does not work with modules built on top of [JSI](https://github.com/react-native-community/discussions-and-proposals/issues/91), such as [`react-native-reanimated`](https://github.com/software-mansion/react-native-reanimated) version 2 or higher.
Hermes supports [Chrome DevTools Protocol](https://chromedevtools.github.io/devtools-protocol/v8/) to debug JavaScript in place by connecting to the engine running on the device, as opposed to remote debugging, which executes JavaScript within a desktop Chrome tab. Hermes apps use this debugging technique automatically when you open the debugger in Expo Go or a development build.


## iOS Developer Mode

Learn how to enable iOS Developer Mode setting on iOS 16 and above to run internal distribution builds and local development builds.

> This does not apply to builds signed using enterprise provisioning or to any builds installed on an iOS Simulator.
Devices running iOS 16 and above need to enable OS-level **Developer Mode** setting before they can run [internal distribution](/build/internal-distribution) builds (including those built with EAS) or local development builds after installing them on the device.
There are two ways you can enable Developer Mode on your device:
- Directly on an iOS device
- By connecting an iOS device with a Mac that has Xcode installed
## Prerequisites
The instructions specified below need to be followed once per device.
## Enable Developer Mode
### Directly on an iOS device
To follow the steps below, **install your development build on your device before enabling the Developer Mode.** When the build is created, follow the instructions on the EAS dashboard to install it on your iOS device.
Step 1: 
Once the build is installed on your device, press the app icon. This will open an alert asking you to enable Developer Mode. Press **OK**.
Step 2: 
Go to the Settings app, and navigate to **Privacy & Security** > **Developer Mode**.
Step 3: 
Enable the toggle. You will receive a prompt from iOS to restart your device. Press **Restart**.
Step 4: 
After the device restarts, unlock your device. A system alert should appear. Press **Turn On** and then, when prompted, enter your device's passcode.
Developer Mode is now enabled. You can now interact with your internal distribution builds and local development builds.
You can turn off Developer Mode at any time. However, you'll need to repeat this same process to re-enable it.
### Connect an iOS device with a Mac
> **Note:** Xcode must be installed on the Mac device before following the steps below.
You don't need to install the development build on your iOS device first to enable Developer Mode by connecting it to a Mac. You can:
Step 1: 
Connect your iOS device to a Mac using a USB cable. Press **Trust** on your iOS device when **Trust This Computer?** alert is prompted.
Step 2: 
Open Xcode, and from the menu bar, navigate to **Window** > **Devices and Simulators**.
Under **Devices**, you'll see a warning "Previous preparation error: Developer Mode disabled" with instructions on enabling Developer Mode on the iOS device.
Step 3: 
On the iOS device, open **Settings** > **Privacy & Security** > **Developer Mode**.
Enable the toggle. You will receive a prompt from iOS to restart your device. Press **Restart**.
Step 4: 
After the device restarts, unlock your device. A system alert should appear. Press **Turn On**, and enter your device's passcode when prompted.
Developer Mode is now enabled. You can now interact with your internal distribution builds and local development builds.
You can turn off Developer Mode at any time. However, you'll need to repeat this same process to re-enable it.


## Expo Vector Icons

Learn how to use various types of icons in your Expo app, including react native vector icons, custom icon fonts, icon images, and icon buttons.

Not every app needs to use emojis for icons. You can use a popular icon set through an icon font such as FontAwesome, Glyphicons, or Ionicons, or choose PNGs from [The Noun Project](https://thenounproject.com/). This guide explains various ways to use icons in your Expo app.
## `@expo/vector-icons`
The `@expo/vector-icons` library is installed by default on the template project using `npx create-expo-app` and is part of the `expo` package. It is built on top of [`react-native-vector-icons`](https://github.com/oblador/react-native-vector-icons) and uses a similar API. It includes popular icon sets you can browse at [icons.expo.fyi](https://icons.expo.fyi).
The component loads the `Ionicons` font and renders a checkmark icon in the following example:
<SnackInline label='Vector icons' dependencies={['@expo/vector-icons']}>
```jsx collapseHeight=350
import { View, StyleSheet } from 'react-native';
import Ionicons from '@expo/vector-icons/Ionicons';
export default function App() {
  return (
    <View style={styles.container}>
      <Ionicons name="checkmark-circle" size={32} color="green" />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```
> As with [any custom font](/develop/user-interface/fonts/#use-a-local-font-file) in Expo, you can preload icon fonts before rendering your app. The font object is available as a static property on the font component. So, in the case above, it is `Ionicons.font`, which evaluates to `{ionicons: require('path/to/ionicons.ttf')}`.
## Custom icon fonts
To use a custom icon font, first import it into your project. Only after the font has loaded, can you create an Icon set. [Learn more about loading custom fonts](/develop/user-interface/fonts/#handle-expovector-icons-initial-load).
`@expo/vector-icons` exposes three methods to help you create an icon set:
### `createIconSet`
The `createIconSet` method returns a custom font based on the `glyphMap` where the key is the icon name and the value is either a UTF-8 character or its character code.
In the example below, the `glyphMap` object is defined and then passed as the first argument to the `createIconSet` method. The second argument `fontFamily` is the name of the font (not the filename). Optionally, you can pass the third argument for Android support, which is the custom font file name.
```jsx createIconSet example
import createIconSet from '@expo/vector-icons/createIconSet';
const glyphMap = { 'icon-name': 1234, test: '∆' };
const CustomIcon = createIconSet(glyphMap, 'fontFamily', 'custom-icon-font.ttf');
export default function CustomIconExample() {
  return <CustomIcon name="icon-name" size={32} color="red" />;
}
```
### `createIconSetFromIcoMoon`
The `createIconSetFromIcoMoon` method is used to create a custom font based on an [IcoMoon](https://icomoon.io/) config file. You have to save the **selection.json** and **.ttf** in your project, preferably in the **assets** directory, and then load the font using either `useFonts` hook or `Font.loadAsync` method from `expo-font`.
See the example below that uses the `useFonts` hook to load the font:
<SnackInline
label='Icomoon Icons'
files={{
    'assets/icomoon/icomoon.ttf': 'https://snack-code-uploads.s3.us-west-1.amazonaws.com/~asset/71ce651cbddbee5366aef87c456a80bb',
    'assets/icomoon/selection.json': 'https://snack-code-uploads.s3.us-west-1.amazonaws.com/~asset/a06aa5b6e7eb1df1fa1c8d06d4ab8463'
  }}
dependencies={['@expo/vector-icons', 'expo-font']}>
```jsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { useFonts } from 'expo-font';
import createIconSetFromIcoMoon from '@expo/vector-icons/createIconSetFromIcoMoon';
const Icon = createIconSetFromIcoMoon(
  require('./assets/icomoon/selection.json'),
  'IcoMoon',
  'icomoon.ttf'
);
export default function App() {
  const [fontsLoaded] = useFonts({
    IcoMoon: require('./assets/icomoon/icomoon.ttf'),
  });
  if (!fontsLoaded) {
    return null;
  }
  return (
    <View style={styles.container}>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```
### `createIconSetFromFontello`
The `createIconSetFromFontello` method is used to create a custom font based on a [Fontello](http://fontello.com/) config file. You have to save the **config.json** and **.ttf** somewhere convenient in your project, preferably in the **assets** directory, and then load the font using either `useFonts` hook or `Font.loadAsync` method from `expo-font`.
It follows a similar configuration as `createIconSetFromIcoMoon` as shown in the example:
```js Fontello Icons
// Import the createIconSetFromFontello method
import createIconSetFromFontello from '@expo/vector-icons/createIconSetFromFontello';
// Import the config file
import fontelloConfig from './config.json';
// Both the font name and files exported from Fontello are most likely called "fontello".
// Ensure this is the `fontname.ttf` and not the file path.
const Icon = createIconSetFromFontello(fontelloConfig, 'fontello', 'fontello.ttf');
```
## Button component
You can create an Icon Button using the `Font.Button` syntax where the `Font` is the icon set that you import from `@expo/vector-icons`.
In the example below, a login button uses the `FontAwesome` icon set. Notice that the `FontAwesome.Button` component accepts props to handle action when a button is pressed and can wrap the text of the button.
<SnackInline label='Icon Button Component' dependencies={['@expo/vector-icons']}>
```jsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import FontAwesome from '@expo/vector-icons/FontAwesome';
export default function App() {
  const loginWithFacebook = () => {
    console.log('Button pressed');
  };
  return (
    <View style={styles.container}>
      <FontAwesome.Button name="facebook" backgroundColor="#3b5998" onPress={loginWithFacebook}>
        Login with Facebook
      </FontAwesome.Button>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```
### Properties
Any [`Text`](http://reactnative.dev/docs/text), [`TouchableHighlight`](http://reactnative.dev/docs/touchablehighlight), or [`TouchableWithoutFeedback`](http://reactnative.dev/docs/touchablewithoutfeedback) property in addition to these:
| Prop              | Description                                                                                                                                      | Default             |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- |
| `color`           | Text and icon color, use `iconStyle` or nest a `Text` component if you need different colors.                                                    | `white`             |
| `size`            | Icon size.                                                                                                                                       | `20`                |
| `iconStyle`       | Styles applied to the icon only, good for setting margins or a different color. _Note: use `iconStyle` for margins or expect unstable behavior._ | `{marginRight: 10}` |
| `backgroundColor` | Background color of the button.                                                                                                                  | `#007AFF`           |
| `borderRadius`    | Border radius of the button, set to `0` to disable.                                                                                              | `5`                 |
| `onPress`         | A function called when the button is pressed.                                                                                                    | _None_              |


## Localization

Learn about getting started and configuring localization in an Expo project using expo-localization.

If you want your app to be easy to use for users who speak different languages or come from different cultures, you should localize it. Localizing an app makes it adapt to the locale of the user's device. The app will show translations and currencies that the user knows and understands. Numbers, lists, and more will be formatted in a way that the user is used to.
This guide uses the `expo-localization` library for accessing user language settings and adding support for multiple languages. It uses `i18n-js` as an example to add multi-language support.
## Getting the user's language
Use the [`expo-localization`](/versions/latest/sdk/localization/) library to get the user's current language. Install the package by running the following command:
```sh
$ npx expo install expo-localization
```
Then, you will be able to access localization methods and data in your app:
```tsx
import { getLocales } from 'expo-localization';
const deviceLanguage = getLocales()[0].languageCode;
```
The `getLocales` method returns the current locale based on the system settings of the device. On newer Android and iOS versions, app language can be set per app, so you usually don't need to build a custom UI to allow users to change the current locale inside of your app.
Sometimes, it makes sense to build a UI to allow the user to set other localization preferences on a per-app basis. As a general rule, you should allow the user to change the following:
- Localized units if your app makes at least a moderate use of them (such as metric/imperial measurements, currency, temperature, and more)
- Other preferences if there's no API to get the default value on platforms you want to support (check [`expo-localization`](/versions/latest/sdk/localization) API documentation for details)
### Enabling per-app language selection via system settings
Both Android and iOS allow users to choose a preferred language for individual apps via the system settings. To support this feature, your app must declare its supported locales to the system.
To do so, use the [`expo-localization`](/versions/latest/sdk/localization/#installation) config plugin and pass the `supportedLocales` property to the `expo-localization` config plugin.
You can either provide an array of supported locales directly, or use the `supportedLocales.ios` and `supportedLocales.android` fields to specify platform-specific values:
```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-localization",
        {
          "supportedLocales": {
            "ios": ["en", "ja"],
            "android": ["en", "ja"]
          }
        }
      ]
    ]
  }
}
```
> On Android, refer to the [locale naming guidelines](https://developer.android.com/guide/topics/resources/app-languages#locale-names) and the [list of most commonly used locales](https://developer.android.com/guide/topics/resources/app-languages#sample-config).
>
> On iOS, use the language name or ISO language designator.
## Translating an app
Creating and managing translations quickly becomes a large task. You can handle translations manually, but it's best to use a library to handle this for you.
Let's make the app support English and Japanese. To achieve that, this guide uses the `i18n-js` package:
```sh
$ npx expo install i18n-js
```
Take a look at [other translation libraries](#other-translation-libraries) to find one that best suits your needs.
Then, configure the languages for your app:
```tsx
import { getLocales } from 'expo-localization';
import { I18n } from 'i18n-js';
// Set the key-value pairs for the different languages you want to support.
const i18n = new I18n({
  en: { welcome: 'Hello' },
  ja: { welcome: 'こんにちは' },
});
// Set the locale once at the beginning of your app.
i18n.locale = getLocales()[0].languageCode;
console.log(i18n.t('welcome'));
```
Now, you can use the `i18n.t` function to translate strings throughout your application.
You can refrain from localizing text for certain things, for example, names. In this case, you can define them _once_ in your default language and reuse them with `i18n.enableFallback = true;`.
On Android, when a user changes the device's language, the app will not reset. You can use the [`AppState`](https://reactnative.dev/docs/appstate#basic-usage) API to listen for changes to the app's state and call the `getLocales()` function each time the app's state changes.
On iOS, when a user changes the device's language, the app will reset. This means you can set the language once without updating any of your React components to account for the language changes.
### Complete example
#### Localization
```tsx
import { View, StyleSheet, Text } from 'react-native';
import { getLocales } from 'expo-localization';
import { I18n } from 'i18n-js';
// Set the key-value pairs for the different languages you want to support.
const translations = {
  en: { welcome: 'Hello', name: 'Charlie' },
  ja: { welcome: 'こんにちは' },
};
const i18n = new I18n(translations);
// Set the locale once at the beginning of your app.
i18n.locale = getLocales()[0].languageCode ?? 'en';
// When a value is missing from a language it'll fall back to another language with the key present.
i18n.enableFallback = true;
// To see the fallback mechanism uncomment the line below to force the app to use the Japanese language.
// i18n.locale = 'ja';
export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>
        {i18n.t('welcome')} {i18n.t('name')}
      </Text>
      <Text>Current locale: {i18n.locale}</Text>
      <Text>Device locale: {getLocales()[0].languageCode}</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
    flex: 1,
  },
  text: {
    fontSize: 20,
    marginBottom: 16,
  },
});
```
### Other translation libraries
This guide uses `i18n-js` as an example, but other libraries can also help you with the task. Creating translations is a major effort. Some pointers to consider when choosing a library:
- Integration with translation management tools for easier strings management and automations.
- Ability to provide context to strings, so that AI translation tools and/or human reviewers can understand the context of the string and provide better translations.
- Developer experience - usage in the context of React / JSX. Some libraries come with ESLint plugins and other tools to help in development.
- Don't worry about localizing dates or numbers - use standardized `Intl` APIs for that.
Here is a non-exhaustive list of other libraries you can consider:
- [Lingui](https://lingui.dev/) is a mature library with first-class React (including React Server Components (RSC)) support and integrates well with translation management tools.
- [fbtee](https://fbtee.dev/) is an internationalization framework for JavaScript and React designed to be powerful, flexible, and intuitive.
- [React i18next](https://react.i18next.com/) is a stable, well-maintained library based on `i18next`.
### Translating app metadata
If you plan on shipping your app to different countries or regions or want it to support various languages, you can provide [localized](/versions/latest/sdk/localization) strings for things like the display name and system dialogs. This is easily set up [in the app config](/workflow/configuration) file. First, set `ios.infoPlist.CFBundleAllowMixedLocalizations: true`, then provide a list of file paths to `locales`.
```json app.json
{
  "expo": {
    "ios": {
      "infoPlist": {
        "CFBundleAllowMixedLocalizations": true
      }
    },
    "locales": {
      "ja": "./languages/japanese.json"
    }
  }
}
```
The keys provided to `locales` should be the [language identifier](https://developer.apple.com/documentation/xcode/choosing-localization-regions-and-scripts), made up of a [2-letter language code](https://www.loc.gov/standards/iso639-2/php/code_list.php) of your desired language, with an optional region code (for example, `en-US` or `en-GB`), and the value should point to a JSON file that looks something like below:
```json japanese.json
{
  "ios": {
    "CFBundleDisplayName": "こんにちは",
    "NSContactsUsageDescription": "日本語のこれらの言葉",
    "Localizable.strings": {
      "HELLO_NOTIFICATION_KEY": "こんにちは世界"
    }
  },
  "android": {
    "app_name": "こんにちは",
    "HELLO_NOTIFICATION_KEY": "こんにちは世界"
  }
}
```
Now, the display name of your app is set to `こんにちは` whenever it's installed on a device with the language set to Japanese.
In SDK 55 and later, there is an iOS-only option to specify a `Localizable.strings` object whose entries are used to create native localization files. The entries can be used in [iOS localized notifications](https://developer.apple.com/documentation/usernotifications/generating-a-remote-notification#Localize-your-alert-messages).
## Enabling RTL support
Several regions around the world write text from right to left. If you want to localize your app, so it looks as expected in RTL languages, you need to make sure your app handles these layout and text direction changes accordingly.
To enable RTL support, use the [`expo-localization`](/versions/latest/sdk/localization/#installation) config plugin and enable `extra.supportsRTL` property in app config:
```json app.json
{
  "expo": {
    "extra": {
      "supportsRTL": true
    },
    "plugins": ["expo-localization"]
  }
}
```
This enables RTL when your app is loaded in Expo Go, in Expo dev Client, and in applications built using EAS Build or `npx expo prebuild`.
When an application starts, Expo checks if the current device locale should render in RTL layout to look correctly. For example, an app marked to support RTL in the app config file will render in RTL mode in Hebrew or Arabic locale.
### Forcing RTL layout
You can also force the RTL layout for testing or for applications that are only localized for RTL locales by enabling `extra.forcesRTL` property in the app config:
```json app.json
{
  "expo": {
    "extra": {
      "supportsRTL": true,
      "forcesRTL": true
    },
    "plugins": ["expo-localization"]
  }
}
```
Note: Dynamically overriding RTL settings
---
If you want to override the default RTL detection from your application code dynamically, you cannot use the static configuration in app config. Instead, apply these changes dynamically from your application code.
This does not work in Expo Go, as Expo Go resets RTL preferences when opening the launcher or individual projects.
#### Overriding RTL settings
```tsx
import { Text, View, StyleSheet, I18nManager, Platform } from 'react-native';
import Constants from 'expo-constants';
import * as Updates from 'expo-updates';
export default function App() {
  const shouldBeRTL = true;
  if (shouldBeRTL !== I18nManager.isRTL && Platform.OS !== 'web') {
    I18nManager.allowRTL(shouldBeRTL);
    I18nManager.forceRTL(shouldBeRTL);
    Updates.reloadAsync();
  }
  return (
    <View style={styles.container}>
      <Text style={styles.paragraph}>{I18nManager.isRTL ? ' RTL' : ' LTR'}</Text>
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    paddingTop: Constants.statusBarHeight,
    padding: 8,
  },
  paragraph: {
    fontSize: 18,
    fontWeight: 'bold',
    textAlign: 'left',
    width: '50%',
    backgroundColor: 'pink',
  },
});
```
---
## Making an app behave correctly on RTL locales
### Layouts and views
You don't need to manually adjust `<View>` styling properties based on locale. You can use properties like `justifyContent`, `alignItems`, and others. Their property values change behavior as required.
- On LTR locales, `start` and `end` are the same as `left` and `right`.
- On RTL locales, `start` and `end` are the same as `right` and `left`.
> **info** For more details on how RTL works in React Native check out the React Native [blog article](https://reactnative.dev/blog/2016/08/19/right-to-left-support-for-react-native-apps) introducing RTL support.
#### Web support
Web support for RTL layouts requires no app config changes.
Expo uses `react-native-web` for running Expo projects in the browser. To make `react-native-web` automatically adapt to locale direction, add a `dir` property to your root `<View>` component.
```tsx App.tsx
import { View } from 'react-native';
import { getLocales } from 'expo-localization';
// ...
return <View dir={getLocales()[0].textDirection || 'ltr'}>...</View>;
```
> **warning** `textDirection` is not available on Firefox and older browser versions. [Detect it manually](https://stackoverflow.com/a/15726039) if needed.
### Text alignment
The React Native's `textDirection` property does not accept `start` or `end` values that you can use in flex properties. Instead, `left` effectively works as `start` (aligns to the left on LTR and the right on RTL), and `right` works as `end`.
However, the default unset value of `textDirection` property signifies the actual left (aligns to the left both on LTR and RTL). This means each `<Text>` tag should have the `textDirection: left` or `textDirection: right` style set if you want it to be aligned correctly.
It's best to define this style in your custom reusable `<Text>` component that you can then import everywhere you need to render text strings.
```tsx MobileText.tsx
import { Text as RNText, TextProps as RNTextProps } from 'react-native';
const MobileText = (props: RNTextProps) => {
  return <RNText style={{ textAlign: 'left', ...props.style }} {...props} />;
};
export default MobileText;
```
#### Web support
For each text tag, you need to add the `lang` property with the current locale identifier. It's best to define this style in a custom reusable component.
```tsx WebText.tsx
import { getLocales } from 'expo-localization';
const deviceLanguage = getLocales()[0].languageCode;
const WebText = (props: RNTextProps) => {
  return <RNText lang={deviceLanguage} {...props} />;
};
export default WebText;
```
You can then pick either the mobile or web Text component based on the current platform.
```tsx Text.tsx
const Text = Platform.OS === 'web' ? WebText : MobileText;
export default Text;
```
### Selecting assets based on locale direction
If you need to use different icons for LTR/RTL or change styles based on this setting, you can use [`I18nManager.isRTL`](https://reactnative.dev/docs/next/i18nmanager#isrtl) to get the current layout direction.
```tsx
import { I18nManager } from 'react-native';
const isRTL = I18nManager.isRTL;
```
## Locale settings and units
Expo provides the `expo-localization` library to allow you to read the user's locale and other preferences. You can use synchronous `getLocales()` and `getCalendars()` methods to get the current locale settings of the user device:
- `getLocales()` returns a list of locales based on the order in which the user prefers them. There will always be at least one locale in the list.
- `getCalendars()` returns a list of calendars based on the order in which the user prefers them. There will always be at least one calendar on the list.
```ts
import { getLocales, getCalendars } from 'expo-localization';
const {
  languageTag,
  languageCode,
  textDirection,
  digitGroupingSeparator,
  decimalSeparator,
  measurementSystem,
  currencyCode,
  currencySymbol,
  regionCode,
} = getLocales()[0];
const { calendar, timeZone, uses24hourClock, firstWeekday } = getCalendars()[0];
```
Note: Limitations
---
There are a few limitations to keep in mind when relying on auto-detected locale preferences from `expo-localization`.
- There is yet to be a way to read temperature units from user preferences. On Android, you can use a lookup table based on locale. However, on iOS, the user can change it in device preferences.
- Some properties can be null when they are unavailable on the current platform.
---
## Intl API
If you're using Hermes in your app, you can use the [`Intl`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl) API on all platforms.
It provides a set of utilities you can use to format lists, dates, numbers, monetary amounts, units, plural forms, and more.
If you pass `default` as the locale string, the `Intl` API will use the device's locale, so you don't need to rely on `expo-localization` to get the current locale (such as `"en-US"`).
```ts
new Intl.NumberFormat('default', { style: 'currency', currency: 'EUR' }).format(5.0);
```
> You can use `Intl` APIs to format strings and values once you know what the user expects to see.
>
> `Intl` APIs do not provide information about the device or current locale, so you can't use the `Intl` APIs to get current locale units, currencies, or measurement systems.
>
> For this you need to use `expo-localization`, JS code on the web, or third-party or custom native code on Android and iOS.


## Configure JS engines

A guide on configuring JS engines for both Android and iOS in an Expo project.

JavaScript engines execute your application code and provide various features such as memory management, optimization, and error handling. By default, Expo projects use [Hermes](https://hermesengine.dev/) as the JavaScript engine. Switching to other engines, such as JSC or V8, for Android and iOS platforms is possible. However, not for the web because the JavaScript engine is included in the web browser.
## Configuring the `jsEngine` through app config
> **warning** Changing the JS engine is unavailable in Expo Go from SDK 52 (only the Hermes engine is available). A [development build](/develop/development-builds/introduction/) is required to use this customization.
We recommend Hermes because it is purpose built and optimized for React Native apps, and it has the best debugging experience. If you are familiar with the tradeoffs of different JavaScript engines and would like to change away from Hermes, the [`jsEngine`](/versions/latest/config/app/#jsengine) field inside [app config](/workflow/configuration/) allows you to specify the JavaScript engine for your app. The default value is `hermes`.
If you want to use JSC instead, set the `jsEngine` field in the app config:
```json app.json
{
  "expo": {
    "jsEngine": "jsc"
  }
}
```
Note: Usage in bare React Native projects
---
To change the JavaScript engine in a bare React Native project, update the `expo.jsEngine` value in **android/gradle.properties** and **ios/Podfile.properties.json**.
---
It's important to highlight that changing the JS engine will require you to recompile development builds with `eas build` to work properly.
## Using the V8 engine
To use the V8 engine, you need to install [`react-native-v8`](https://github.com/Kudo/react-native-v8), an opt-in package that adds V8 runtime support for React Native. You can install it by running the following command:
```sh
$ npx expo install react-native-v8 v8-android-jit
```
Make sure to remove the `jsEngine` field from the app config.
Note: Usage with Expo Prebuild
---
Run `npx expo prebuild -p android --clean` after the installation to prebuild again.
---
## Switch JavaScript engine on a specific platform
To use a different engine on one specific platform, you can set the `"jsEngine"` value at the top level and then override it with a different value under the `"android"` or `"ios"` key. The value specified for the platform will take precedence over the common field.
```json app.json
{
  "expo": {
    "jsEngine": "hermes",
    "ios": {
      "jsEngine": "jsc"
    }
  }
}
```


## Using Bun

A guide on using Bun with Expo and EAS.

[Bun](https://bun.sh/) is a JavaScript runtime and a drop-in alternative for [Node.js](https://nodejs.org/en). In Expo projects, Bun can be used to install npm packages and run Node.js scripts. The benefits of using Bun are faster package installation than npm, pnpm, or Yarn and [at least 4x faster startup time compared to Node.js](https://bun.sh/docs#design-goals), which gives a huge boost to your local development experience.
## Prerequisites
> **Note:** While Bun replaces Node.js for most use cases in your project, at this time, a [Node.js LTS version](https://nodejs.org/) is still required to be installed for the `bun create expo` and `bun expo prebuild` commands. These commands use `npm pack` to download project templates.
To create a new app using Bun, [install Bun on your local machine](https://bun.sh/docs/installation#installing).
## Start a new Expo project with Bun
To create a new project, run the command:
```sh
$ bun create expo-app my-app
```
You can also run any **package.json** script with `bun run`:
```sh
$ bun run ios
```
To install any Expo library, you can use `bun expo install`:
```sh
$ bun expo install expo-audio
```
## Use Bun for EAS builds
EAS decides which package manager to use based on the lockfile in your codebase. If you want EAS to use Bun, run `bun install` in your codebase which will create a **bun.lockb** (the Bun lockfile). As long as this lockfile is in your codebase, Bun will be used as the package manager for your builds. Make sure to delete any lockfiles generated by other package managers.
### Customize Bun version on EAS
Bun is installed by default when using EAS. See the [Android server images](/build-reference/infrastructure/#android-server-images) and [iOS server images](/build-reference/infrastructure/#ios-server-images) to learn which version of Bun is used by your build's image.
To use an [exact version of Bun](/eas/json/#bun) with EAS, add the version number in **eas.json** under the build profile's configuration. For example, the configuration below specifies Bun version `1.0.0` for the `development` build profile:
```json eas.json
{
  "build": {
    "development": {
      "bun": "1.0.0"
    }
  }
}
```
## Trusted dependencies
Unlike other package managers, Bun does not automatically execute lifecycle scripts from installed libraries, as this is considered a security risk. However, if a package you are installing has a `postinstall` script that you want to run, you have to explicitly state that by including that library in your [`trustedDependencies`](https://bun.sh/guides/install/trusted) array in your **package.json**.
For example, if you install `packageA`, which has a dependency on `packageB` and `packageB` has a `postinstall` script, you must add `packageB` in your `trustedDependencies`.
To add a trusted dependency in your **package.json**, add:
```json package.json
"trustedDependencies": ["your-dependency"]
```
Then, remove your lockfile and re-install the dependencies:
```sh
$ rm -rf node_modules
$ rm bun.lockb
$ bun install
```
## Common errors
### EAS Build fails when using Sentry and Bun
If you're using `sentry-expo` or `@sentry/react-native`, these depend on `@sentry/cli`, which updates source maps to Sentry during your build. The `@sentry/cli` package has a `postinstall` script which needs to run for the "upload source maps" script to become available.
To fix this, add `@sentry/cli` to your [trusted dependencies](/#trusted-dependencies) array in **package.json**:
```json package.json
"trustedDependencies": ["@sentry/cli"]
```


## Edit rich text

Learn about current approaches to preview and edit rich text in React Native.

A lot of applications need to allow users to type in text. For example, if you want to build a messaging or social media app, you will probably rely heavily on text inputs. React Native has a built-in `<TextInput>` component to implement this without much effort for many simple cases.
However, sometimes you need to be more flexible. Think of long social media posts, note apps, or document editors. Ideally, you need to allow different text styles, lists, headings, embedded images, and more. This is called a rich text editor, and it's a difficult problem to solve everywhere, including in React Native.
There is currently no default solution for that in the React Native ecosystem. However, this guide explores some options and promising approaches, each with its own tradeoffs.
Video Tutorial: [Watch: How to implement a Rich Text Editor using DOM components](https://www.youtube.com/watch?v=CxORa1tXMjw)
## Render rich text
There are a lot of good options to display rich text:
- For markdown content, you can use a markdown renderer such as [`react-native-markdown-display`](https://www.npmjs.com/package/react-native-markdown-display) or another.
- For HTML content, you can use [`@expo/html-elements`](https://www.npmjs.com/package/@expo/html-elements) or a webview ([`react-native-webview`](/versions/latest/sdk/webview/)).
- To have a custom format and more control, you can take advantage of nesting `<Text>` components to render styles and layouts.
  ```jsx
  <TextInput>
    <Text>
      <Text style={{ fontWeight: 900 }}>Some bold text</Text>Some regular text
    </Text>
  </TextInput>
  ```
- You can also use [Expo Modules API](/modules/overview/) to write a custom renderer component with native platform primitives using third-party libraries such as [Markwon](https://github.com/noties/Markwon) on Android and `AttributedString` on iOS.
## Approaches to edit rich text
There are a few approaches to get rich text rendering to work. However, all have different limitations.
### Webview-based editors
While most React Native UI components wrap native platform primitives and are fast, performant, and **native feeling** as a result, the webview-based rich text editors use a different approach.
They wrap an existing rich text editor built for web with JavaScript inside a [`react-native-webview`](/versions/latest/sdk/webview/). It works on all platforms (Android, iOS, Web) and can take advantage of popular rich text editors available for the Web platform, but it has a performance and UX penalty.
You will not be able to use native UI components inside the editor. Any implementation of features like mentions or image embedding will duplicate features and require significant effort to implement.
### Existing webview-based React Native libraries
There are a couple of existing React Native libraries to allow rich-text editing. These are the easiest options to get started if you need a basic rich text editor with limited configuration and don't have strict performance or UX requirements:
- [`react-native-rich-editor`](https://github.com/wxik/react-native-rich-editor)
- [`react-native-cn-quill`](https://github.com/imnapo/react-native-cn-quill)
- [`@10play/tentap-editor`](https://github.com/10play/10Tap-Editor)
### Custom webview-based editor
If you need more configurability, you can build a similar library with an existing web-only editor. However, you have to handle the message passing and web implementation yourself. This gives you all the options that the underlying editor offers and lets you implement more features.
- [Quill](https://quilljs.com/)
- [lexical](https://github.com/facebook/lexical)
- [slate](https://github.com/ianstormtaylor/slate)
You will need to use message passing to pass text and `onChange` events to and from the webview. Since rich texts often end up long, it's better to model it as an uncontrolled component to prevent lag on each keystroke. Also, if you can avoid serializing and sending the entire state on each keystroke that also improves performance.
## Building on top of React Native TextInput
In this section, let's discuss if it is possible to have a feature complete rich text input for general purposes.
React Native allows nested `<Text>` components and allows them to be used as children of `<TextInput>` to render and edit styled text. It is synchronous with the new React Native architecture (the `onChange` event fires immediately after a new character is typed into the text input field).
Unfortunately, the `<TextInput>` component is built toward working with regular text, and it only returns a string in it's `onTextChange` callback. This is a significant limitation.
Here is a quick example. Let's start by rendering a text input with the following bold text:
```jsx
<TextInput>
  <Text>
    {/* The following will render a bold text in this format: **aa**aa */}
    <Text style={{ fontWeight: 900 }}>aa</Text>aa
  </Text>
</TextInput>
```
Then, let's append a fifth letter `a` to the text input. The position of your cursor should determine if the new letter is a part of the bold string or not. Unfortunately, the callback only returns `aaaaa`.
There is an additional `onSelectionChange` prop that can be used to get that information. However, it makes the task significantly harder. Inserting additional characters (such as newlines for lists or bullet points) also desynchronizes the selection.
There are some attempts to build such an editor, such as [`markdown-editor`](https://github.com/shakogegia/markdown-editor) (not actively maintained) and [`rn-text-editor`](https://github.com/amjadbouhouch/rn-text-editor) (in beta), but no widely used packages exist.
## Markdown editors with visible styling markers
If using a markdown to style text fulfills your requirement, you can render the markdown in a separate, non-editable view while editing. It is not complex to build on your own using any markdown renderer. You can also use a third-party library such as [`react-native-markdown-editor`](https://github.com/kunall17/react-native-markdown-editor).
This editing experience suits power users or programming/tech applications. You can also explore rendering rich text while showing markdown only in the selected chunk of text or other hybrid approaches.
## Native editors
You can use a native Android or iOS rich text editor wrapped into a React Native module. There are a few options:
- [`react-native-aztec`](https://github.com/WordPress/gutenberg/tree/trunk/packages/react-native-aztec)
- [`gutenberg-mobile`](https://github.com/wordpress-mobile/gutenberg-mobile)
- [`react-native-live-markdown`](https://github.com/Expensify/react-native-live-markdown)
- [`react-native-enriched`](https://github.com/software-mansion-labs/react-native-enriched)
You can also wrap any native rich text editor using [Expo Modules API](/modules/overview/), but if you use different ones on each platform, you need to unify their APIs and input formats.
> Rich text is usually represented using [abstract syntax trees](https://en.wikipedia.org/wiki/Abstract_syntax_tree). For example, a bullet list can be a node of type `bulleted-list` with several children of type `list-item`. You can convert both HTML and markdown to a suitable AST format.
There is also an effort to port the lexical editor to Android and iOS and provide a React Native wrapper, [track it here](https://github.com/facebook/lexical/discussions/2410).
## Summary
While there are many great options for showing rich text, there is no one-size-fits-all solution for rich text editing in React Native. There's no popular solution that is sufficient in most use cases. Further contribution from the community is needed to improve existing solutions or add new ones.
For now, you need to carefully choose between a more complex, native editor that offers more features but may be harder to maintain, or an editor built on top of react-native primitives. This depends on how core the feature is to your app, how many features you need in your editor, and how much effort you are willing to spend on building it out.


## Create app store assets

Learn how to create screenshots and previews for your app's store pages.

Before submitting your app to the Google Play Store and Apple App Store, you need to provide some assets for your store listing page. The goal of these images and videos is to give your prospective users an idea of what your app experience is going to be like.
You will need to upload app screenshots for both app stores. Even though they are called "app screenshots" on both stores, they _do_ have to include accurate visuals of your app. There is no rule citing that these images have to be screenshots taken on specific devices.
Both app stores have requirements on image format and size. However, within these restrictions, you can be creative. For example, a common approach is to design the assets using a design tool such as Figma and incorporate actual app screenshots (or designs) with supplementary messaging.
## Different approaches for creating "screenshots"
There are three commonly used approaches to creating your store screenshots. You can choose whichever approach works best for your app's needs and resources.
### Option 1: actual screenshots
The most straightforward option &mdash; open up your app on a real device and take screenshots.
**Pros**: Straightforward to do. Most accurate representation of your app.
**Cons**: Need to load the app on different devices for a full range of screenshots.
### Option 2: screenshots within a design
The majority of apps use this approach. It involves taking screenshots of the app (or in some cases, using existing designs instead of actual screenshots) and embedding them in the store assets along with appropriate messaging.
**Pros:** Allows to convey additional messaging within the assets.
**Cons:** The assets need to be created using a design program.
### Option 3: make it fancy
In this option, on the app store pages, you can incorporate elements of your app design and creative messaging to highlight your product.
**Pros:** You can make your store page creative and fun.
**Cons:** Need an experienced designer to create and maintain the assets.
## Google Play Store Asset Requirements
Google has specific requirements for the store asset format and dimensions, which are different from Apple's. For the most up-to-date specifications, see [official documentation](https://support.google.com/googleplay/android-developer/answer/9866151) for detailed requirements for your Google Play Store assets.
### App icon
Unlike on the Apple App Store, where the app icon is always taken automatically from the app bundle, on the Google Play Store, you must also upload a separate App Icon for your store listing.
### Feature graphic
A feature graphic must be provided to publish your Store Listing. It is a banner that is displayed at the top of your store listing page.
### Screenshots
You need to upload at least four screenshots to publish your app.
### Video (optional)
You can add one preview video to your Store Listing. The video needs to be uploaded to YouTube, and you can add it by entering a YouTube URL in the **preview video** field.
## iOS App Store Asset Requirements
For the iOS App Store, you can upload screenshots (images) and previews (videos). For each, Apple requires specific widths and heights. Make sure to reference the [Screenshot specifications from Apple](https://developer.apple.com/help/app-store-connect/reference/screenshot-specifications/) for the exact sizing. Even a single pixel-off will mean you cannot submit the images.
### Screenshots
At a minimum, Apple requires you to upload screenshots for iPhone with the dynamic island (6.9 inch). You can optionally upload additional screenshots for other screen sizes. If specific screenshots are not provided, scaled down screenshots from the closest uploaded size will be used instead.
If your app runs on iPad, you must also provide one set of iPad screenshots (13 inch).
You can upload up to ten screenshots per localization. If your app is available in multiple languages and your screenshots include text, you should upload screenshots with the appropriate language for each localization.
Screenshots can be portrait or landscape.
### Preview (optional)
You can include An app preview video to demonstrate how your app works. You can add up to three app previews for each screen size.
See [App Preview Specifications](https://developer.apple.com/help/app-store-connect/reference/app-preview-specifications/) from Apple documentation for a summary of video size and format.
## Bare minimum
Below is the bare minimum needed to publish your apps.
### Play Store - Android
| Type            | Amount | Dimensions                                                          | Requirements                                        |
| --------------- | ------ | ------------------------------------------------------------------- | --------------------------------------------------- |
| App Icon        | 1      | 512 × 512                                                           | 32-bit PNG (with alpha); Maximum file size: 1024 KB |
| Feature Graphic | 1      | 1024 × 500                                                          | JPEG or 24-bit PNG (no alpha)                       |
| Screenshots     | 4-10   | minimum: 1024 × 500maximum width: 3840px9:16 aspect ratio | JPEG or 24-bit PNG (no alpha)                       |
### App Store - iPhone
| Type                                         | Amount | Dimensions (choose one)     | Requirements          |
| -------------------------------------------- | ------ | --------------------------- | --------------------- |
| Screenshots (iPhone with the dynamic island) | 2-10   | 1320 × 28681290 × 2796 | JPG or PNG (no alpha) |
### App Store - iPad
If your app also runs on an iPad, you need to supply additional screenshots.
| Type        | Amount | Dimensions (choose one)     | Requirements          |
| ----------- | ------ | --------------------------- | --------------------- |
| Screenshots | 2-10   | 2064 × 27522048 × 2732 | JPG or PNG (no alpha) |


## Local-first architecture with Expo

An introduction to the emerging local-first software movement, including links to relevant learning resources and tools.

> **info** This guide is a work in progress. If you have any feedback, [open an issue](https://github.com/expo/expo/issues/new/choose) in our GitHub repository.
The term "local-first" was first coined in the paper ["Local-first software"](https://www.inkandswitch.com/local-first/), written by the research lab [Ink & Switch](https://www.inkandswitch.com/), but the ideas behind it have been around for a long time. It's the architecture that powers some of our favorite apps, like [Linear](https://linear.app/), [Superhuman](https://superhuman.com/), [Excalidraw](https://excalidraw.com/), and even [Apple Notes](<https://en.wikipedia.org/wiki/Notes_(Apple)>).
In local-first software, "the availability of another computer should never prevent you from working" ([via Martin Kleppmann](https://www.youtube.com/watch?v=NMq0vncHJvU)). When you are offline, you can still read and write directly from/to a database on your device. You can trust the software to work offline, and you know that when you are connected to the internet, your data will be seamlessly synced and available on any of your devices running the app. When you're online, this architecture is well suited for "multiplayer" apps, [as popularized by Figma](https://www.figma.com/blog/how-figmas-multiplayer-technology-works/).
To dig deeper into what local-first is and how it works, refer to the [additional resources](#additional-resources) below.
## Why use local-first architecture?
### User experience benefits
Local-first software feels **fast** because interactions are no longer network-bound, you can read and write directly from/to a database on your device.
You can trust the software to work offline, and you know that when you are connected to the internet, your data will be seamlessly synced and available on any of your devices running the app.
Another characteristic of local-first software is that it is collaborative &mdash; multiple devices can work on the same data, and changes are synced across all of them. This can happen in real-time when you collaborate on a design in [Figma](https://www.figma.com/) or asynchronously when you create a task while offline in Linear and it is synced when you are online again.
### Developer experience benefits
You no longer have to manage various states of your app for each network request &mdash; "loaded", "loading", "error", and so on, with their corresponding UI states and other logic. Write to a local database, and the app will automatically sync the changes to the server. This means that you can focus on building the app, and not worry as much about the networking and offline states.
Your server availability may still be important, but in the event of an outage your users can still access the app and continue working. You may even provide a mechanism to sync the data without going through your server.
## Challenges in building local-first apps
The tools available today are still in their early stages, and so you may find yourself solving problems that you would expect to be solved by the tools you are using today. For example, you may need to implement a custom sync layer, or you may have to figure out how to handle permissions for multiple users operating on the same data. As the ecosystem evolves, we expect it to become easier to build local-first apps. If you're not prepared to be an early adopter, and everything that comes with that, you might want to wait for the tools to mature before you start building your app with local-first tools.
## Tools for building local-first apps
A comprehensive list of tools is available on the ["Local-first software" community website](https://localfirstweb.dev/). The following is a shorter list of tools that we at Expo have had direct experience working with.
One way to think of local-first tools is to group them by the following categories: persistence, state management, and syncing. Some tools will fit into multiple categories if they handle multiple aspects of the problem. Syncing can be further subdivided into syncable data structures and transport layers.
### Legend-State
[Legend-State](https://legendapp.com/open-source/state/v3/) is a super fast all-in-one state and sync library that lets you write less code to make faster apps. It has the following primary goals:
- Faster state management for React apps
- Fine-grained reactivity for minimal renders
- Powerful sync and persistence (with Supabase support built-in)
It works with Expo and React Native (via [`react-native-async-storage`](https://github.com/react-native-async-storage/async-storage?tab=readme-ov-file#react-native-async-storage)). This makes it a perfect match for building local-first mobile and web apps. Get started by using the [Legend-State Supabase example](https://github.com/expo/examples/tree/master/with-legend-state-supabase):
```sh
$ npx create-expo-app --example with-legend-state-supabase
```
### TinyBase
[TinyBase](https://tinybase.org/) calls itself "the reactive data store for local-first apps". It is a state management library that plugs in to many of the most popular syncing and persistence layers, such as [Yjs](#yjs) and [SQLite](#sqlite). It's a great choice for building local-first apps that need to persist and sync data. Get started by using the [TinyBase example](https://github.com/expo/examples/tree/master/with-tinybase):
```sh
$ npx create-expo-app --example with-tinybase
```
TinyBase works seamlessly with Expo Go, allowing you to develop quickly. On Android and iOS, it uses the [`expo-sqlite`](/versions/latest/sdk/sqlite/) library to persist data. On the web, it relies on the [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) API. [Beto Moedano](https://github.com/betomoedano) demonstrates how to build a [Universal Local-first Shopping List App](https://github.com/betomoedano/groceries-shopping-list-app) in the following video:
Video Tutorial: [Watch: Build a Local-First Real-Time Shopping List App with Expo and TinyBase](https://www.youtube.com/watch?v=HqOiB2tDM8Q)
### SQLite
[Expo SQLite](/versions/latest/sdk/sqlite/) is a SQLite library that is a great choice for persistence for local-first apps. You can use SQLite with different state management and syncing layers in front of it, such as [`y-expo-sqlite`](https://github.com/brentvatne/y-expo-sqlite) to persist [Yjs](#yjs) documents, and [TinyBase](#tinybase) as a state management layer. Using SQLite is flexible, but you will need to combine it with other tools or build your own tools to get a complete local-first solution. See [Expo SQLite API reference](/versions/latest/sdk/sqlite/) for more information.
### Yjs
[Yjs](https://github.com/yjs/yjs) is a [CRDT implementation](https://github.com/yjs/yjs?tab=readme-ov-file#yjs-crdt-algorithm) that provides data types that can be synced across multiple clients. When building an app with Yjs and working with data that you would like to be able to sync, then you would use `Y.Array` and `Y.Map` to represent your data rather than `Array` and `Object`. You may use a library like [TinyBase](#tinybase) for state management on top of Yjs, and persistence can be handled by a variety of tools, from a JSON file on your filesystem to a full-fledged database (such as [`y-expo-sqlite`](https://github.com/brentvatne/y-expo-sqlite)) and everything in between. See [Yjs's GitHub repository](https://github.com/yjs/yjs) for more information.
### Prisma
[Prisma](https://prisma.io) is well known as the most popular ORM for Node.js and TypeScript backends, and it's now available for [Expo and React Native in early access](https://www.prisma.io/blog/bringing-prisma-orm-to-react-native-and-expo). Prisma aims to provide a complete local-first solution, with state management, syncing, and persistence all covered for you. While it's still early, [Beto Moedano](https://github.com/betomoedano) has put together a full walkthrough of using Prisma with Expo to build a local-first Notion clone, [check out the code on GitHub](https://github.com/betomoedano/React-Native-Notion-Clone).
Video Tutorial: [Watch: Building a Local-first Notion Clone with React Native Expo and Prisma](https://www.youtube.com/watch?v=uTrPte0sCiw)
### Jazz
[Jazz.tools](https://jazz.tools/docs/react-native) is a framework for building local-first apps. It is open source, provides first-class support for Expo and you can self-host it or use [Jazz Cloud](https://jazz.tools/cloud) to start quickly. [Jazz](https://jazz.tools). To learn more, check out the [examples](https://jazz.tools/examples#react-native) or see the [Getting Started Guide](https://jazz.tools/docs/react-native) for detailed instructions.
### LiveStore
[LiveStore](https://docs.livestore.dev/getting-started/expo/) is a client-centric local-first data layer for high-performance applications. It provides first-class support for Expo, and it's a great choice for building local-first apps. See the blog post on [LiveStore: SQLite-based data layer for local-first apps](https://expo.dev/blog/local-first-application-development-with-livestore).
Video Tutorial: [Watch: How to build local-first native apps with LiveStore and Expo](https://www.youtube.com/watch?v=zQIhJqYU1Qw)
### Turso
[Turso](https://turso.tech) is a modern database service built on SQLite. It now supports [Offline Sync](https://turso.tech/blog/turso-offline-sync-public-beta), which enables true local-first experiences. You can sync databases between local and remote sources with bidirectional sync and built-in conflict detection. While automatic conflict resolution isn't available yet, this feature is still a major step forward. You can use Turso today with [expo-sqlite](/versions/latest/sdk/sqlite). To learn more, read the [Turso: Offline Sync Public Beta](https://turso.tech/blog/turso-offline-sync-public-beta) blog post. For an example integration, check out the [Notes App](https://github.com/betomoedano/notes-app).
Video Tutorial: [Watch: How to build a local-first Notes App with Turso and Expo](https://www.youtube.com/watch?v=SBv32tmyb3k)
### Instant
[Instant](https://www.instantdb.com/) is a modern alternative to Firebase. It gives you a real-time database so you can focus on building your app's frontend. To get started, check out the [Getting Started Guide](https://www.instantdb.com/docs/start-rn). You can also explore the [Sketch App](https://github.com/betomoedano/sketch-app) featured in the video below.
Video Tutorial: [Watch: Build a Local-First Sketch App with Expo, Instant & Reanimated](https://www.youtube.com/watch?v=DEJIcaGN3vY)
### Other tools
The following list, far from being comprehensive, provides other tools that have caught our attention and that you may find interesting to explore. For a more thorough list of tools, see ["Local-first software" community website](https://localfirstweb.dev/).
- [Automerge](https://automerge.org/)
- [ElectricSQL](https://electric-sql.com/)
- [PowerSync](https://www.powersync.com/)
## Additional resources
- ["The past, present, and future of local-first"](https://www.youtube.com/watch?v=NMq0vncHJvU) by Martin Kleppmann
- ["Local-first software"](https://www.inkandswitch.com/local-first/) by Ink & Switch
- ["Local-first software" community website](https://localfirstweb.dev/) and [meetup playlist on YouTube](https://www.youtube.com/playlist?list=PLTbD2QA-VMnXFsLbuPGz1H-Najv9MD2-H)
- [localfirst.fm podcast](https://localfirst.fm/) by Johannes Schickling


## Keyboard handling

A guide for handling common keyboard interactions on an Android or iOS device.

Keyboard handling is crucial for creating an excellent user experience in your Expo app. React Native provides [`Keyboard`](https://reactnative.dev/docs/keyboard) and [`KeyboardAvoidingView`](https://reactnative.dev/docs/keyboardavoidingview), which are commonly used to handle keyboard events. For more complex or custom keyboard interactions, you can consider using [`react-native-keyboard-controller`](https://kirillzyusko.github.io/react-native-keyboard-controller), which is a library that offers advanced keyboard handling capabilities.
This guide covers common keyboard interactions and how to manage them effectively.
Video Tutorial: [Keyboard Handling tutorial for React Native apps](https://www.youtube.com/watch?v=Y51mDfAhd4E)
## Keyboard handling basics
The following sections explain how to handle keyboard interactions with common APIs.
### Keyboard avoiding view
The `KeyboardAvoidingView` is a component that automatically adjusts a view's height, position, or bottom padding based on the keyboard height to remain visible while it is displayed.
Android and iOS interact with the `behavior` property differently. On iOS, `padding` is usually what works best, and for Android, just having the `KeyboardAvoidingView` prevents covering the input. This is why the following example uses `undefined` for Android. Playing around with the `behavior` is a good practice since a different option could work best for your app.
```tsx HomeScreen.tsx
import { KeyboardAvoidingView, TextInput } from 'react-native';
export default function HomeScreen() {
  return (
    <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : undefined} style={{ flex: 1 }}>
      <TextInput placeholder="Type here..." />
    </KeyboardAvoidingView>;
  );
}
```
In the above example, the height of the `KeyboardAvoidingView` automatically adjusts based on the device's keyboard height, which ensures that the input is always visible.
When using a Bottom Tab navigator on Android, you might notice that focusing on an input field causes the bottom tabs to be pushed above the keyboard. To address this issue, add the `softwareKeyboardLayoutMode` property to your Android configuration in [app config](/workflow/configuration/) and set it to `pan`.
```json app.json
"expo" {
  "android": {
    "softwareKeyboardLayoutMode": "pan"
  }
}
```
After adding this property, restart the development server and reload your app to apply the changes.
It's also possible to hide the bottom tab when the keyboard opens using [`tabBarHideOnKeyboard`](https://reactnavigation.org/docs/bottom-tab-navigator/#tabbarhideonkeyboard). It is an option with the Bottom Tab Navigator. If set to `true`, it will hide the bar when the keyboard opens.
```tsx app/_layout.tsx
import { Tabs } from 'expo-router';
export default function TabLayout() {
  return (
    <Tabs
      screenOptions={{
        tabBarHideOnKeyboard: true,
      }}>
      <Tabs.Screen name="index" />
    </Tabs>
  );
}
```
### Keyboard events
The `Keyboard` module from React Native allows you to listen for native events, react to them, and make changes to the keyboard, such as dismissing it.
To listen for keyboard events, use the `Keyboard.addListener` method. This method accepts an event name and a callback function as arguments. When the keyboard is shown or hidden, the callback function is called with the event data.
The following example illustrates a use case for adding a keyboard listener. The state variable `isKeyboardVisible` is toggled each time the keyboard shows or hides. Based on this variable, a button allows the user to dismiss the keyboard only if the keyboard is active. Also, notice that the button uses the `Keyboard.dismiss` method.
```tsx HomeScreen.tsx
import { useEffect, useState } from 'react';
import { Keyboard, View, Button, TextInput } from 'react-native';
export default function HomeScreen() {
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);
  useEffect(() => {
    const showSubscription = Keyboard.addListener('keyboardDidShow', handleKeyboardShow);
    const hideSubscription = Keyboard.addListener('keyboardDidHide', handleKeyboardHide);
    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, []);
  const handleKeyboardShow = event => {
    setIsKeyboardVisible(true);
  };
  const handleKeyboardHide = event => {
    setIsKeyboardVisible(false);
  };
  return (
    <View>
      {isKeyboardVisible && <Button title="Dismiss keyboard" onPress={Keyboard.dismiss} />}
      <TextInput placeholder="Type here..." />
    </View>
  );
}
```
## Advanced keyboard handling with Keyboard Controller
For more complex keyboard interactions, such as larger scrollable entry forms with several text input fields, consider using the [`react-native-keyboard-controller` (Keyboard Controller)](https://kirillzyusko.github.io/react-native-keyboard-controller) library. It offers additional functionality beyond the built-in React Native keyboard APIs, providing consistency across Android and iOS with minimal configuration and offering the native feel users expect.
### Prerequisites
The following steps are described using a [development build](/develop/development-builds/introduction/) since the Keyboard Controller library is not included in Expo Go. See [Create a development build](/develop/development-builds/create-a-build/) for more information.
[Keyboard Controller](https://kirillzyusko.github.io/react-native-keyboard-controller) also requires `react-native-reanimated` to work correctly. To install it, follow these [installation instructions](/versions/latest/sdk/reanimated/#installation).
### Install
Start by installing the Keyboard Controller library in your Expo project:
```sh
$ npx expo install react-native-keyboard-controller
```
### Set up provider
To finalize the setup, add the `KeyboardProvider` to your app.
```tsx app/_layout.tsx
import { Stack } from 'expo-router';
import { KeyboardProvider } from 'react-native-keyboard-controller';
export default function RootLayout() {
  return (
    <KeyboardProvider>
      <Stack>
        <Stack.Screen name="home" />
        <Stack.Screen name="chat" />
      </Stack>
    </KeyboardProvider>
  );
}
```
### Handling multiple inputs
The [`KeyboardAvoidingView`](#keyboard-avoiding-view) component is excellent for prototyping, but it requires platform-specific configuration and is not very customizable.
As a more powerful alternative, you can use the [`KeyboardAwareScrollView`](https://kirillzyusko.github.io/react-native-keyboard-controller/docs/api/components/keyboard-aware-scroll-view) component. It automatically scrolls to a focused `TextInput` and provides native-like performance. For simple screens with only a few elements, using `KeyboardAwareScrollView` is a great approach.
For screens with multiple inputs, the Keyboard Controller library also provides a `KeyboardToolbar` component to use alongside `KeyboardAwareScrollView`. Together, these components handle input navigation and prevent the keyboard from covering the screen without custom configuration:
```tsx FormScreen.tsx
import { TextInput, View, StyleSheet } from 'react-native';
import { KeyboardAwareScrollView, KeyboardToolbar } from 'react-native-keyboard-controller';
export default function FormScreen() {
  return (
    <>
      <KeyboardAwareScrollView bottomOffset={62} contentContainerStyle={styles.container}>
        <View>
          <TextInput placeholder="Type a message..." style={styles.textInput} />
          <TextInput placeholder="Type a message..." style={styles.textInput} />
        </View>
        <TextInput placeholder="Type a message..." style={styles.textInput} />
        <View>
          <TextInput placeholder="Type a message..." style={styles.textInput} />
          <TextInput placeholder="Type a message..." style={styles.textInput} />
          <TextInput placeholder="Type a message..." style={styles.textInput} />
        </View>
        <TextInput placeholder="Type a message..." style={styles.textInput} />
      </KeyboardAwareScrollView>
      <KeyboardToolbar />
    </>
  );
}
const styles = StyleSheet.create({
  container: {
    gap: 16,
    padding: 16,
  },
  listStyle: {
    padding: 16,
    gap: 16,
  },
  textInput: {
    width: 'auto',
    flexGrow: 1,
    flexShrink: 1,
    height: 45,
    borderWidth: 1,
    borderRadius: 8,
    borderColor: '#d8d8d8',
    backgroundColor: '#fff',
    padding: 8,
    marginBottom: 8,
  },
});
```
The above example wraps the inputs with `KeyboardAwareScrollView` to prevent the keyboard from covering them. The `KeyboardToolbar` component displays navigation controls and a dismiss button. While it works without configuration, you can customize the toolbar content if needed.
### Animating views in sync with keyboard height
For a more advanced and customizable approach, you can use [`useKeyboardHandler`](https://kirillzyusko.github.io/react-native-keyboard-controller/docs/api/hooks/keyboard/use-keyboard-handler). It provides access to keyboard lifecycle events. It allows us to determine when the keyboard starts animating and its position in every frame of the animation.
Using the `useKeyboardHandler` hook, you can create a custom hook to access the height of the keyboard at each frame. It uses `useSharedValue` from reanimated to return the height, as shown below.
```tsx ChatScreen.tsx
import { useKeyboardHandler } from 'react-native-keyboard-controller';
import Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated';
const useGradualAnimation = () => {
  const height = useSharedValue(0);
  useKeyboardHandler(
    {
      onMove: event => {
        'worklet';
        height.value = Math.max(event.height, 0);
      },
    },
    []
  );
  return { height };
};
```
You can use the `useGradualAnimation` hook to animate a view and give it a smooth animation when the keyboard is active or dismissed, for example, in a chat screen component (shown in the example below). This component gets the keyboard height from the hook. It then creates an animated style called `fakeView` using the `useAnimatedStyle` hook from reanimated. This style only contains one property: `height`, which is set to the keyboard's height.
The `fakeView` animated style is used in an animated view after the `TextInput`. This view's height will animate based on the keyboard's height at each frame, which effectively pushes the content above the keyboard with a smooth animation. It also decreases its height to zero when the keyboard is dismissed.
```tsx ChatScreen.tsx
import { StyleSheet, Platform, FlatList, View, StatusBar, TextInput } from 'react-native';
import Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated';
import { useKeyboardHandler } from 'react-native-keyboard-controller';
import MessageItem from '@/components/MessageItem';
import { messages } from '@/messages';
const useGradualAnimation = () => {
};
export default function ChatScreen() {
  const { height } = useGradualAnimation();
  const fakeView = useAnimatedStyle(() => {
    return {
      height: Math.abs(height.value),
    };
  }, []);
  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => <MessageItem message={item} />}
        keyExtractor={item => item.createdAt.toString()}
        contentContainerStyle={styles.listStyle}
      />
      <TextInput placeholder="Type a message..." style={styles.textInput} />
      <Animated.View style={fakeView} />
    </View>
  );
}
const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: Platform.OS === 'android' ? StatusBar.currentHeight : 0,
  },
  listStyle: {
    padding: 16,
    gap: 16,
  },
  textInput: {
    width: '95%',
    height: 45,
    borderWidth: 1,
    borderRadius: 8,
    borderColor: '#d8d8d8',
    backgroundColor: '#fff',
    padding: 8,
    alignSelf: 'center',
    marginBottom: 8,
  },
});
```
## Additional resources


## Building SwiftUI apps with Expo UI

Learn how to use Expo UI to integrate SwiftUI into your Expo apps.

> **info** Available in **SDK 54 and later**.
Expo UI brings SwiftUI to React Native. You can use modern SwiftUI primitives to build your apps.
This guide covers the basics of using Expo UI to integrate SwiftUI into your Expo apps.
Video Tutorial: [Expo UI iOS Liquid Glass Tutorial](https://www.youtube.com/watch?v=2wXYLWz3YEQ)
## Features
- **SwiftUI primitives**: Expo UI is not another UI library. It brings SwiftUI primitives to Expo.
- **1-to-1 mapping**: The components in Expo UI have a 1-to-1 mapping to SwiftUI views. You can easily explore available views in the SwiftUI ecosystem, such as [Explore SwiftUI](https://exploreswiftui.com/) or the [Libraried app](https://apps.apple.com/us/app/libraried-ui-components/id1642862540), and find the corresponding Expo UI component.
- **Full-app support**: Expo UI is designed to be used throughout the entire app. You can write your app entirely in Expo UI, while maintaining flexibility at the same time. The integration works at the component level. You can also mix [React Native components](https://reactnative.dev/docs/components-and-apis), [Expo UI components](/versions/latest/sdk/ui/), [DOM components](/guides/dom-components/), or custom 2D components using [`react-native-skia`](https://shopify.github.io/react-native-skia/).
## Installation
You'll need to install the `@expo/ui` package in your Expo project. Run the following command to install it:
```sh
$ npx expo install @expo/ui
```
## Usage
Expo UI has several SwiftUI components available. You can use them in your app by importing them from `@expo/ui/swift-ui`. However, to cross the boundary from React Native (UIKit) to SwiftUI, you need to use the [`Host`](/versions/latest/sdk/ui/#host) component. The [`Host`](/versions/latest/sdk/ui/#host) is the container for SwiftUI views. You can think of it like [`<svg>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/svg) in the DOM or [`<Canvas>`](https://shopify.github.io/react-native-skia/docs/canvas/overview/) in [`react-native-skia`](https://shopify.github.io/react-native-skia/). Under the hood, it uses [`UIHostingController`](https://developer.apple.com/documentation/swiftui/uihostingcontroller) to render SwiftUI views in UIKit.
### Basic usage with `Host`
  For Code: 
    ```tsx SwiftUI loading view
    import { CircularProgress, Host } from '@expo/ui/swift-ui';
    import { View, Text } from 'react-native';
    export default function LoadingView() {
      return (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <Host matchContents>
            <CircularProgress />
          </Host>
          <Text>Loading...</Text>
        </View>
      );
    }
    ```
  For Preview: 
### Using `HStack` and `VStack`
You can also use the `HStack` and `VStack` components to build the entire layout in SwiftUI.
  For Code: 
    ```tsx SwiftUI loading with HStack and VStack
    import { CircularProgress, Host, HStack, LinearProgress, VStack } from '@expo/ui/swift-ui';
    export default function LoadingView() {
      return (
        <Host style={{ flex: 1, margin: 32 }}>
          <VStack spacing={32}>
            <HStack spacing={32}>
              <CircularProgress />
              <CircularProgress color="orange" />
            </HStack>
            <LinearProgress progress={0.5} />
            <LinearProgress color="orange" progress={0.7} />
          </VStack>
        </Host>
      );
    }
    ```
  For Preview: 
### Modifiers
[SwiftUI modifier](<https://developer.apple.com/documentation/swiftui/view/modifier(_:)>) is a powerful way to customize the appearance and behavior of SwiftUI components. Expo UI also provides modifiers for SwiftUI components. You can import modifiers from `@expo/ui/swift-ui/modifiers` and pass them as an array to the `modifiers` prop. In the following example, the [`expo-mesh-gradient`](/versions/latest/sdk/mesh-gradient/) and `glassEffect` modifier are combined to create Liquid Glass text.
  For Code: 
    > **Note**: `glassEffect` modifier requires Xcode 26+ and iOS 26+.
    ```tsx SwiftUI modifiers
    import { Host, Text } from '@expo/ui/swift-ui';
    import { glassEffect, padding } from '@expo/ui/swift-ui/modifiers';
    import { MeshGradientView } from 'expo-mesh-gradient';
    import { View } from 'react-native';
    export default function Page() {
      return (
        <View style={{ flex: 1 }}>
          <MeshGradientView
            style={{ flex: 1 }}
            columns={3}
            rows={3}
            colors={['red', 'purple', 'indigo', 'orange', 'white', 'blue', 'yellow', 'green', 'cyan']}
            points={[
              [0.0, 0.0],
              [0.5, 0.0],
              [1.0, 0.0],
              [0.0, 0.5],
              [0.5, 0.5],
              [1.0, 0.5],
              [0.0, 1.0],
              [0.5, 1.0],
              [1.0, 1.0],
            ]}
          />
          <Host style={{ position: 'absolute', top: 0, right: 0, left: 0, bottom: 0 }}>
            <Text
              size={32}
              modifiers={[
                padding({
                  all: 16,
                }),
                glassEffect({
                  glass: {
                    variant: 'clear',
                  },
                }),
              ]}>
              Glass effect text
            </Text>
          </Host>
        </View>
      );
    }
    ```
  For Preview: 
### iOS Settings app example
Combining the Expo UI components and modifiers, you can build a UI like iOS Settings app.
  For Code: 
    ```tsx SwiftUI Form example to build iOS Settings app
    import {
      Button,
      Form,
      Host,
      HStack,
      Image,
      Section,
      Spacer,
      Switch,
      Text,
    } from '@expo/ui/swift-ui';
    import { background, clipShape, frame } from '@expo/ui/swift-ui/modifiers';
    import { Link } from 'expo-router';
    import { useState } from 'react';
    export default function SettingsView() {
      const [isAirplaneMode, setIsAirplaneMode] = useState(true);
      return (
        <Host style={{ flex: 1 }}>
          <Form>
            <Section>
              <HStack spacing={8}>
                <Image
                  systemName="airplane"
                  color="white"
                  size={18}
                  modifiers={[
                    frame({ width: 28, height: 28 }),
                    background('#ffa500'),
                    clipShape('roundedRectangle'),
                  ]}
                />
                <Text>Airplane Mode</Text>
                <Spacer />
                <Switch value={isAirplaneMode} onValueChange={setIsAirplaneMode} />
              </HStack>
              <Link href="/wifi" asChild>
                <Button>
                  <HStack spacing={8}>
                    <Image
                      systemName="wifi"
                      color="white"
                      size={18}
                      modifiers={[
                        frame({ width: 28, height: 28 }),
                        background('#007aff'),
                        clipShape('roundedRectangle'),
                      ]}
                    />
                    <Text color="primary">Wi-Fi</Text>
                    <Spacer />
                    <Image systemName="chevron.right" size={14} color="secondary" />
                  </HStack>
                </Button>
              </Link>
            </Section>
          </Form>
        </Host>
      );
    }
    ```
  For Preview: 
## Common questions
Note: Can I use flexbox or other styles in SwiftUI components?
---
Flexbox styles can be applied to the `Host` component itself. Once you're inside the SwiftUI context, however, [`Yoga`](https://www.yogalayout.dev/) is not available &mdash; layouts should be defined using `<HStack>` and `<VStack>` instead.
---
Note: What's the  component?
---
`Host` is the container for SwiftUI views. You can think of it like [`<svg>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Element/svg) in the DOM or [`<Canvas>`](https://shopify.github.io/react-native-skia/docs/canvas/overview/) in [`react-native-skia`](https://shopify.github.io/react-native-skia/). Under the hood, it uses [`UIHostingController`](https://developer.apple.com/documentation/swiftui/uihostingcontroller) to render SwiftUI views in UIKit.
---
Note: How is Expo UI different from libraries like  or ?
---
Expo UI is not "yet another" UI library and not an opinionated design kit. Instead, it's a primitives library. It exposes native SwiftUI and Jetpack Compose components directly to JavaScript, rather than re-implementing or simulating UI in JavaScript.
---
Note: Can I use  on Android or web?
---
The first milestone for Expo UI is achieving a 1-to-1 mapping from SwiftUI to Expo UI. Universal support will come in the next stage of the roadmap. Our priority is to establish strong SwiftUI support first, and then expand to Jetpack Compose on Android and DOM support on the Web.
---
Note: Can I use React Native components inside SwiftUI components?
---
Yes, you can place React Native components as JSX children of Expo UI components. Expo UI automatically creates a [`UIViewRepresentable`](https://developer.apple.com/documentation/swiftui/uiviewrepresentable) wrapper for you.
However, keep in mind that the SwiftUI layout system works differently from UIKit and has some limitations. According to Apple's documentation:
> **Warning** SwiftUI fully controls the layout of the UIKit view's [`center`](https://developer.apple.com/documentation/UIKit/UIView/center), [`bounds`](https://developer.apple.com/documentation/UIKit/UIView/bounds), [`frame`](https://developer.apple.com/documentation/UIKit/UIView/frame), and [`transform`](https://developer.apple.com/documentation/UIKit/UIView/transform) properties. Don't directly set these layout-related properties on the view managed by a [`UIViewRepresentable`](https://developer.apple.com/documentation/swiftui/uiviewrepresentable) instance from your own code because that conflicts with SwiftUI and results in undefined behavior.
Also note that once you render React Native components, you're leaving the SwiftUI context. If you want to add Expo UI components again, you'll need to reintroduce a `Host` wrapper.
We recommend keeping SwiftUI layouts self-contained. Interop is possible, but it works best when boundaries are clearly defined.
---
Note: I'm a SwiftUI developer. Why should I learn Expo UI?
---
Because React's promise of _"learn once, write anywhere"_, it now extends to SwiftUI and Jetpack Compose. With Expo UI, you can apply your SwiftUI knowledge to build apps that run in the React Native ecosystem, extend to the Web through [DOM components](/guides/dom-components/), and even integrate [2D](https://shopify.github.io/react-native-skia/) and [3D](https://github.com/wcandillon/react-native-webgpu) rendering. The system is flexible enough that different parts of your app can use different approaches &mdash; giving you seamless integration at the component level.
---
## Additional resources


# Troubleshooting

## Troubleshooting overview

An overview of troubleshooting guides for app development with Expo and EAS.

This page lists a collection of various troubleshooting guides for Expo and EAS.
## Error and warnings
## Runtime issues in development and production
## Expo Router
## Push notifications
## EAS


## "Application has not been registered" error

Learn about what the Application has not been registered error means and how to resolve it in an Expo or React Native app.

When developing an Expo or React Native app, it's common to run into an error that looks like:
```sh
Application "main" has not been registered.
Invariant Violation: "main" has not been registered.
```
In this particular error, `"main"` can be any string.
## What this error means
### An exception may be preventing your app from registering itself
The most common cause of this error is that there is an exception thrown in your application before it's able to register itself. When a React Native application loads, there are two steps:
1. Load the JavaScript code, and if everything is successful, then your application will be registered. If there is any exception when loading the bundle then execution will be aborted and it will never reach the part where your application is registered.
2. Run the registered application. If loading the code failed, then the application won't be registered and you will see the error that is the subject of this page.
If you're in this situation, the error message you're seeing is a [red herring](https://en.wikipedia.org/wiki/Red_herring), it's distracting you from the real error that led to the application not being registered.
Look at your logs before this error message to see what may have caused it. A frequent cause is multiple versions of a native module dependency that registers itself as a view &mdash; for example [this Stack Overflow thread](https://stackoverflow.com/questions/67543844/invariant-violation-main-has-not-been-registered-while-running-react-native-a/67550379) where the poster has multiple versions of `react-native-safe-area-context` in their dependencies.
### Your app root component may not be registered
Another possibility is that there is a mismatch between the `AppKey` being provided to [`AppRegistry.registerComponent`](https://reactnative.dev/docs/appregistry#registercomponent), and the `AppKey` being registered on the native iOS or Android side.
In managed projects, the default behavior is to use "main" as the `AppKey`. This is handled for you automatically, and as long as you don't change the `"main"` field in your **package.json** from the default value then this will just work. If you want to customize the app entry point, see [registerRootComponent](/versions/latest/sdk/expo/#registerrootcomponentcomponent) API reference.
In projects with native code, you will see something like this in your **index.js** by default:
```js
import { registerRootComponent } from 'expo';
import App from './App';
registerRootComponent(App);
```
where `registerRootComponent` is implemented as:
```js
function registerRootComponent(component) {
  AppRegistry.registerComponent('main', () => component);
}
```
And on the native side, in **AppDelegate.m** you should see:
```objectivec
RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge moduleName:@"main" initialProperties:nil];
```
and in **MainActivity.java**:
```java
@Override
protected String getMainComponentName() {
  return "main";
}
```
By default, "main" is consistently used throughout the project. If you're running into this error, something has likely changed and these values no longer coincide. Ensure that the names you are registering on the JavaScript side are the ones expected on the native side (if you're using Expo's `registerRootComponent` function, that would be "main").
## Other considerations
This error can also occur in a few other scenarios, but it's less predictable and the fixes would be more specific to your project. For example, some other cases are:
- You're connecting to the wrong project's local development server. Try closing out other Expo CLI or React Native community CLI processes (find them with `ps -A | grep "expo\|react-native"`).
- If this error is only occurring in your production app, then try running the app locally in production mode with `npx expo start --no-dev --minify` to find the source of the error.


## Clear bundler caches on macOS and Linux

Learn how to clear the bundler cache when using Yarn or npm with Expo CLI or React Native CLI on macOS and Linux.

> Need to clear development caches on Windows? [Find the relevant commands here.](/troubleshooting/clear-cache-windows/)
There are a number of different caches associated with your project that can prevent your project from running as intended. Clearing a cache sometimes can help you work around issues related to stale or corrupt data and is often useful when troubleshooting and debugging.
To clear the various caches, run:
## Expo CLI and Yarn
```sh
you may need to delete node_modules in each workspace
$ rm -rf node_modules
$ yarn cache clean
$ yarn
$ watchman watch-del-all
$ rm -fr $TMPDIR/haste-map-*
$ rm -rf $TMPDIR/metro-cache
$ npx expo start --clear
```
## Expo CLI and npm
```sh
$ rm -rf node_modules
$ npm cache clean --force
$ npm install
$ watchman watch-del-all
$ rm -fr $TMPDIR/haste-map-*
$ rm -rf $TMPDIR/metro-cache
$ npx expo start --clear
```
## React Native CLI and Yarn
```sh
you may need to delete node_modules in each workspace
$ rm -rf node_modules
$ yarn cache clean
$ yarn
$ watchman watch-del-all
$ rm -fr $TMPDIR/haste-map-*
$ rm -rf $TMPDIR/metro-cache
$ yarn start -- --reset-cache
```
## React Native CLI and npm
```sh
$ rm -rf node_modules
$ npm cache clean --force
$ npm install
$ watchman watch-del-all
$ rm -fr $TMPDIR/haste-map-*
$ rm -rf $TMPDIR/metro-cache
$ npm start -- --reset-cache
```
## What these commands are doing
It is a good habit to understand commands you find on the internet before you run them. We explain each command below for Expo CLI, npm, and Yarn, but the corresponding commands React Native CLI have the same behavior.
| Command                   | Description                                                                   |
| ------------------------- | ----------------------------------------------------------------------------- |
| `rm -rf node_modules`     | Clear all of the dependencies of your project                                 |
| `yarn cache clean`        | Clear the global Yarn cache                                                   |
| `npm cache clean --force` | Clear the global npm cache                                                    |
| `yarn`/`npm install`      | Reinstall all dependencies                                                    |
| `watchman watch-del-all`  | Reset the `watchman` file watcher                                             |
| `rm -rf $TMPDIR/<cache>`  | Clear the given packager/bundler cache file or directory                      |
| `npx expo start --clear`  | Restart the development server and clear the JavaScript transformation caches |


## Clear bundler caches on Windows

Learn how to clear the bundler cache when using Yarn or npm with Expo CLI or React Native CLI on Windows.

> Need to clear development caches on macOS or Linux? [Find the relevant commands here.](/troubleshooting/clear-cache-macos-linux/)
There are a number of different caches associated with your project that can prevent your project from running as intended. Clearing a cache sometimes can help you work around issues related to stale or corrupt data and is often useful when troubleshooting and debugging.
## Expo CLI and Yarn
```sh
you may need to delete node_modules in each workspace
$ rm -rf node_modules
$ yarn cache clean
$ yarn
$ watchman watch-del-all
$ del %localappdata%\Temp\haste-map-*
$ del %localappdata%\Temp\metro-cache
$ npx expo start --clear
```
## Expo CLI and npm
```sh
$ rm -rf node_modules
$ npm cache clean --force
$ npm install
$ watchman watch-del-all
$ del %localappdata%\Temp\haste-map-*
$ del %localappdata%\Temp\metro-cache
$ npx expo start --clear
```
## React Native CLI and Yarn
```sh
you may need to delete node_modules in each workspace
$ rm -rf node_modules
$ yarn cache clean
$ yarn
$ watchman watch-del-all
$ del %localappdata%\Temp\haste-map-*
$ del %localappdata%\Temp\metro-cache
$ yarn start -- --reset-cache
```
## React Native CLI and npm
```sh
$ rm -rf node_modules
$ npm cache clean --force
$ npm install
$ watchman watch-del-all
$ del %localappdata%\Temp\haste-map-*
$ del %localappdata%\Temp\metro-cache
$ npm start -- --reset-cache
```
## What these commands are doing
It is a good habit to understand commands you find on the internet before you run them. We explain each command below for Expo CLI, npm, and Yarn, but the corresponding commands React Native CLI have the same behavior.
| Command                           | Description                                                                   |
| --------------------------------- | ----------------------------------------------------------------------------- |
| `del node_modules`                | Clear all of the dependencies of your project                                 |
| `yarn cache clean`                | Clear the global Yarn cache                                                   |
| `npm cache clean --force`         | Clear the global npm cache                                                    |
| `yarn`/`npm install`              | Reinstall all dependencies                                                    |
| `watchman watch-del-all`          | Reset the `watchman` file watcher                                             |
| `del %localappdata%\Temp/<cache>` | Clear the given packager/bundler cache file or directory                      |
| `npx expo start --clear`          | Restart the development server and clear the JavaScript transformation caches |


## "React Native version mismatch" errors

Learn about what React Native version mismatch means and how to resolve it in an Expo or React Native app.

When developing an Expo or React Native app, it's common to run into an error that looks like:
```sh
React Native version mismatch.
JavaScript version: X.XX.X
Native version: X.XX.X
Make sure you have rebuilt the native code...
```
## What this error means
The bundler that you're running in your terminal (using `npx expo start`) is using a different JavaScript version of `react-native` than the native app on your device or emulator. This can happen after upgrading your React Native or Expo SDK version, _or_ when connecting to the wrong local development server.
## How to fix it
- Close out any development servers that you have running (you can list all terminal processes with the `ps` command, and search for Expo CLI or React Native community CLI processes with `ps -A | grep "expo\|react-native"`).
- If this is a Expo project, either remove the `sdkVersion` field from your **app.json** file, or make sure it matches the value of the `expo` dependency in your **package.json** file.
- If this is a Expo project, you should make sure your `react-native` version is correct. Run `npx expo-doctor` will show a warning where the `react-native` version you should install. If you did upgrade to a newer SDK, make sure to run `npx expo install --fix` and follow the prompts. Expo CLI will make sure that your dependency versions for packages like `expo` and `react-native` are aligned.
- If this is a bare React Native project, and this error is occurring right after upgrading your React Native version, you should double-check that you have performed each of the upgrade steps correctly.
- Finally:
  - Clear your bundler caches by running `rm -rf node_modules && npm cache clean --force && npm install && watchman watch-del-all && rm -rf $TMPDIR/haste-map-* && rm -rf $TMPDIR/metro-cache && npx expo start --clear`
    - Commands if you are using npm can be found [here.](clear-cache-macos-linux)
    - Commands if you are using Windows can be found [here.](clear-cache-windows)
  - If this is a bare React Native project, run `npx pod-install`, then rebuild your native projects (run `yarn android` to rebuild for Android, and `yarn ios` to rebuild iOS)


## Troubleshooting Proxies

Learn about troubleshooting proxies with a set of recommended tools.

## macOS proxy configuration (Sierra)
> If anything goes wrong, you can revert to the "Automatic Proxy settings" in System Network Preferences using Automatic Proxy Configuration `your-corporate-proxy-uri:port-number/proxy.pac`.
### Overview
To run this in the local iOS Simulator while on your corporate Wi-Fi network, a local proxy manager is required. You can use a local proxy application such as [Charles](http://charlesproxy.com).
#### Open macOS network preferences
1. Open `System Preferences` for your Mac (Apple Menu > System Preferences).
2. Go to Network.
3. Be sure your `Location` is set to your proxy network, and not "Automatic".
4. With Wi-Fi selected on the left and/or ethernet connection, click `Advanced...` on the bottom right side of the window.
#### Configure proxy address
1. Disable/uncheck "Automatic Proxy Configuration" if it is set.
2. Check "Web Proxy (HTTP)" and set "Web Proxy Server" to 127.0.0.1 : 8888
3. Check "Secure Web Proxy (HTTPS)" and set "Secure Web Proxy Server" to 127.0.0.1 : 8888
### Configure `Charles`
1. Open Charles
2. If it asks, don't allow it to manage your macOS Network Configuration, the previous steps do that. (If you change Charles port, update the previous step to the correct port instead of default 8888)
3. In the menu of Charles go to `Proxy > External Proxy Settings`, check `Use external proxy servers`
4. Check `Web Proxy (HTTP)`, and enter `your-corporate-proxy-uri:port-number`
5. Check `Proxy server requires a password`
6. Domain: YOUR DOMAIN,
   Username: YOUR USERNAME
   Password: YOUR PASSWORD
7. Same for Secure Web Proxy (HTTPS). _Be sure to fill in the same proxy, username, and password address_ fields.
8. In the text area for `Bypass external proxies for the following hosts:` enter:
   ```text
   localhost
   *.local
   ```
   You may need to include your mail server or other corporate network addresses.
9. Check "Always bypass external proxies for localhost"
### iOS Simulator configuration
If you have an existing iOS Simulator custom setup going that is not working, "Simulator > Reset Content and Settings" from the menu.
If you have the Simulator open still, quit it.
Now, in Charles under the "Help" menu > Install Charles Root Certificate, and then again for Install Charles Root Certificate in iOS Simulators
> **Technical note:** This whole process is required because the iOS Simulator is served a bum proxy certificate instead of the actual certificate, and doesn't allow it, for https://exp.host/ which is required to run Expo.  **Also note:** Configure applications that need internet access, such as Spotify, to use http://localhost:8888 as your proxy. Some apps, such as Chrome and Firefox, you can configure in the settings to use your "System Network Preferences" which will use Charles : 8888, or no proxy, depending on how you have your "Location" set in the Apple menu/network preferences. If you are set to "Automatic" no proxy is used, if it is set to "your proxy network" the proxy is used and Charles will need to be running.
## Command line application proxy configuration
npm, git, Brew, Curl, and any other command line applications need proxy access too.
#### For npm
Open `~/.npmrc` and set:
```ini .npmrc
http_proxy=http://localhost:8888
https_proxy=http://localhost:8888
```
### For git
Open `~/.gitconfig` and set
```ini .gitconfig
[http]
  proxy = http://localhost:8888
[https]
  proxy = http://localhost:8888
```
### For command line applications
Depending on your shell, and config, Open `~/.bashrc`, `~/.bash_profile`, or `~/.zshrc` or wherever you set your shell variables and set:
```bash
export HTTP_PROXY="http://localhost:8888"
export http_proxy="http://localhost:8888"
export ALL_PROXY="http://localhost:8888"
export all_proxy="http://localhost:8888"
export HTTPS_PROXY="http://localhost:8888"
export https_proxy="http://localhost:8888"
```
> If you switch your network location back to "Automatic" to use npm or git, you will need to comment these lines out using a `#` before the line you wish to disable. You could alternatively use a command-line proxy manager if you prefer.


# Regulatory compliance

## Data and Privacy protection

An overview of data and privacy protection policies that Expo offers.

At Expo, our team's aim is to provide developers with tools and services that enable them to create robust and high-quality apps. Our focus is not on gathering huge amounts of data. We only collect a minimal amount of data that aids us in making informed decisions about our products and services. Our ultimate goal is to provide excellent user experiences.
It's crucial that Expo is transparent with its users about the data it collects, how it does so, and why. This is particularly important as more laws, policies, and frameworks are being introduced to regulate how companies handle user data. As a developer, you need to be aware of how the tools you use treat your end users' data to ensure that you comply with relevant laws, frameworks, or guidelines in your industry.
To accomplish this, we provide not only our [privacy policy](https://expo.dev/privacy), (which is most useful if you're a lawyer) and also our [privacy explained page](https://expo.dev/privacy-explained). This page lays out exactly what data Expo collects, both from our developers and your end users, and why we collect it. In all scenarios regarding our users' data, Expo is GDPR-, CCPA-, and Data Privacy Framework-compliant.
Find out more about:


## GDPR compliance and Expo

Learn about how applications built with Expo can be GDPR compliant.

## Are apps built with Expo GDPR compliant?
**They can be! You can build GDPR compliant apps with Expo if you follow the requirements.**
While Expo ensures the proper handling and processing of developer data and end-user data, we cannot guarantee that the developers who build apps with Expo follow similar data privacy practices themselves.


## HIPAA compliance and Expo

Learn about how applications built with Expo can be HIPAA compliant.

## Are apps built with Expo HIPAA compliant?
**They can be! You can build HIPAA compliant apps with Expo if you follow the requirements.**
Expo doesn't collect any individually identifiable health data, and you can see all the data that Expo collects on [our privacy explained page](https://expo.dev/privacy-explained). That being said, you are ultimately in control of the data you collect from your users, so we cannot guarantee that all apps built with Expo are HIPAA compliant, as in the end, it is up to you as an individual application developer. But there should be no compliance issues with using Expo.


